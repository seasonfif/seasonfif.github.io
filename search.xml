<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>FlutterEngine初始化流程剖析</title>
      <link href="/2020/05/27/flutter/FlutterEngine%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E5%89%96%E6%9E%90/"/>
      <url>/2020/05/27/flutter/FlutterEngine%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E5%89%96%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="Flutter框架介绍"><a href="#Flutter框架介绍" class="headerlink" title="Flutter框架介绍"></a>Flutter框架介绍</h2><p>Flutter框架分三层即Framework，Engine， Embedder</p><p><img src="https://raw.githubusercontent.com/seasonfif/picture/master/flutter/FlutterArt.jpg" alt="FlutterArt"></p><p>Framework使用dart语言实现，包括UI，文本，图片，按钮等Widgets，渲染，动画，手势等。此部分的核心代码是flutter仓库下的flutter package，以及sky_engine仓库下的 io, async, ui(dart:ui库提供了Flutter框架和引擎之间的接口)等package。</p><p>Engine使用C++实现，是Flutter的核心引擎，主要包括Skia图形引擎、Dart运行时环境Dart VM、Text文本渲染引擎等。</p><p>Embedder是一个嵌入层，通过该层把Flutter嵌入到各个平台上去，Embedder的主要工作包括渲染Surface设置, 线程设置，以及插件等。平台(如iOS)只是提供一个画布，剩余的所有渲染相关的逻辑都在Flutter内部，这就使得它具有了很好的跨端一致性。</p><h2 id="FlutterEngine初始化流程剖析"><a href="#FlutterEngine初始化流程剖析" class="headerlink" title="FlutterEngine初始化流程剖析"></a>FlutterEngine初始化流程剖析</h2><p>既然FlutterEngine是整个flutter框架的核心，想要深入理解flutter跨平台UI渲染能力就必须对引擎逻辑有所了解以及掌握重要细节流程。下面我们就以android平台为例开始深入剖析FlutterEngine的启动流程。整个Flutter Engine源码包含了非常多的东西，DartVM、Render、Channel、Event等等，所以我们只能从相关的点去看，那么从FlutterEngine初始化来说，我们主要关注和Java层有关联的一些操作。相关的代码主要在flutter/shell/platform/android/io/flutter目录下。</p><h3 id="FlutterEngine初始化"><a href="#FlutterEngine初始化" class="headerlink" title="FlutterEngine初始化"></a>FlutterEngine初始化</h3><p>FlutterApplication启动时使用了Java层的FlutterMain来进行初始化。代码位置在<em>flutter/shell/platform/android/io/flutter/app/FlutterApplication.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    FlutterMain.startInitialization(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FlutterMain的startInitialization的最终调用方法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startInitialization</span><span class="params">(@NonNull Context applicationContext, @NonNull FlutterMain.Settings settings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isRunningInRobolectricTest) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Looper.myLooper() != Looper.getMainLooper()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"startInitialization must be called on the main thread"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sSettings == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sSettings = settings;</span><br><span class="line">            <span class="keyword">long</span> initStartTimestampMillis = SystemClock.uptimeMillis();</span><br><span class="line">            initConfig(applicationContext);</span><br><span class="line">            initResources(applicationContext);</span><br><span class="line">            System.loadLibrary(<span class="string">"flutter"</span>);</span><br><span class="line">            VsyncWaiter.getInstance((WindowManager)applicationContext.getSystemService(<span class="string">"window"</span>)).init();</span><br><span class="line">            <span class="keyword">long</span> initTimeMillis = SystemClock.uptimeMillis() - initStartTimestampMillis;</span><br><span class="line">            FlutterJNI.nativeRecordStartTimestamp(initTimeMillis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码我们可以看出flutter框架只会在主线程初始化，这也很好理解因为flutter本质是一个跨平台UI框架。初始化的过程也很简单一是配置一些启动参数，二是加载相关资源文件，还有就是注册GPU垂直同步信号。</p><h3 id="flutter配置项与资源加载"><a href="#flutter配置项与资源加载" class="headerlink" title="flutter配置项与资源加载"></a>flutter配置项与资源加载</h3><h4 id="initConfig"><a href="#initConfig" class="headerlink" title="initConfig"></a>initConfig</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initConfig</span><span class="params">(@NonNull Context applicationContext)</span> </span>&#123;</span><br><span class="line">        Bundle metadata = getApplicationInfo(applicationContext).metaData;</span><br><span class="line">        <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sAotSharedLibraryName = metadata.getString(PUBLIC_AOT_SHARED_LIBRARY_NAME, <span class="string">"libapp.so"</span>);</span><br><span class="line">            sFlutterAssetsDir = metadata.getString(PUBLIC_FLUTTER_ASSETS_DIR_KEY, <span class="string">"flutter_assets"</span>);</span><br><span class="line">            sVmSnapshotData = metadata.getString(PUBLIC_VM_SNAPSHOT_DATA_KEY, <span class="string">"vm_snapshot_data"</span>);</span><br><span class="line">            sIsolateSnapshotData = metadata.getString(PUBLIC_ISOLATE_SNAPSHOT_DATA_KEY, <span class="string">"isolate_snapshot_data"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从AndroidManfest.xml配置的applicaion节点获取meta-data数据，初始化以下默认值。这些值都是FlutterEngine加载过程中使用到的name，例如，抽取apk中asset资源时，flutter_assets打包目录，打包产物data名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sAotSharedLibraryName = <span class="string">"libapp.so"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sVmSnapshotData = <span class="string">"vm_snapshot_data"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sIsolateSnapshotData = <span class="string">"isolate_snapshot_data"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sFlutterAssetsDir = <span class="string">"flutter_assets"</span>;</span><br></pre></td></tr></table></figure><h4 id="initResources"><a href="#initResources" class="headerlink" title="initResources"></a>initResources</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initResources</span><span class="params">(@NonNull Context applicationContext)</span> </span>&#123;</span><br><span class="line">        (<span class="keyword">new</span> ResourceCleaner(applicationContext)).start();</span><br><span class="line">        String dataDirPath = PathUtils.getDataDirectory(applicationContext);</span><br><span class="line">        String packageName = applicationContext.getPackageName();</span><br><span class="line">        PackageManager packageManager = applicationContext.getPackageManager();</span><br><span class="line">        AssetManager assetManager = applicationContext.getResources().getAssets();</span><br><span class="line">        sResourceExtractor = <span class="keyword">new</span> ResourceExtractor(dataDirPath, packageName, packageManager, assetManager);</span><br><span class="line">        sResourceExtractor.addResource(fromFlutterAssets(sVmSnapshotData)).addResource(fromFlutterAssets(sIsolateSnapshotData)).addResource(fromFlutterAssets(<span class="string">"kernel_blob.bin"</span>));</span><br><span class="line">        sResourceExtractor.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在Flutter打包apk的asset目录下，包括fluttter_asset目录/资源项，将资源从apk中抽取，保存在<em>Context.getDir(“flutter”, 0)</em>目录下。</p><h3 id="flutter-so加载"><a href="#flutter-so加载" class="headerlink" title="flutter.so加载"></a>flutter.so加载</h3><p>在初始化Flutter App资源之后加载了flutter.so，这个就是Flutter Engine源码编译后的产物。 在我们编译Flutter App时，它存在Flutter SDK的flutter.jar中，当生产APK之后，它存在于APK的lib目录下。而当运行时，它被Android虚拟机加载到虚拟内存中。我们知道系统执行完<em>System.loadLibrary</em>后会在C++层执行一个回调函数就是<em>JNI_OnLoad</em>，所以在flutter引擎源码中找到相关函数，代码位于<em>flutter/shell/platform/android/library_loader.cc</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is called by the VM when the shared library is first loaded.*</span></span><br><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  *<span class="comment">// Initialize the Java VM.*</span></span><br><span class="line">  fml::jni::InitJavaVM(vm);</span><br><span class="line">  JNIEnv* env = fml::jni::AttachCurrentThread();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">  *<span class="comment">// Register FlutterMain.*</span></span><br><span class="line">  result = flutter::FlutterMain::Register(env);</span><br><span class="line">  FML_CHECK(result);</span><br><span class="line"></span><br><span class="line">  *<span class="comment">// Register PlatformView*</span></span><br><span class="line">  result = flutter::PlatformViewAndroid::Register(env);</span><br><span class="line">  FML_CHECK(result);</span><br><span class="line"></span><br><span class="line">  *<span class="comment">// Register VSyncWaiter.*</span></span><br><span class="line">  result = flutter::VsyncWaiterAndroid::Register(env);</span><br><span class="line">  FML_CHECK(result);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> JNI_VERSION_1_4;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始进行了Java VM的初始化，其实保存一下当前的Java VM对象到一个全局的变量中， JavaVM的初始化在zygote进程中已经进行了，每个Android进程都是fork出来的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> JavaVM* g_jvm = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitJavaVM</span><span class="params">(JavaVM* vm)</span> </span>&#123;</span><br><span class="line">  FML_DCHECK(g_jvm == <span class="literal">nullptr</span>);</span><br><span class="line">  g_jvm = vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个进程中只有一个JavaVM对象，如果要在线程中访问JavaVM，就需要把当前的thread和JavaVM关联起来。所以调用AttachCurrentThread 我们可以得到一个JNIEnv对象， 每个线程都有一个。JNIEnv定义了很多和JNI调用相关的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEnv* <span class="title">AttachCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FML_DCHECK(g_jvm != <span class="literal">nullptr</span>)</span><br><span class="line">      &lt;&lt; <span class="string">"Trying to attach to current thread without calling InitJavaVM first."</span>;</span><br><span class="line">  JNIEnv* env = <span class="literal">nullptr</span>;</span><br><span class="line">  jint ret = g_jvm-&gt;AttachCurrentThread(&amp;env, <span class="literal">nullptr</span>);</span><br><span class="line">  FML_DCHECK(JNI_OK == ret);</span><br><span class="line">  <span class="keyword">return</span> env;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面调用了三个Register方法，作用是注册jni方法，JNI_OnLoad中完成的是jni方法的动态注册，如果没有进行动态注册，JavaVM会默认按照java方法的package name + method name + params 来映射c++方法，这也是一种注册方式-静态注册。由于三个注册方法类似这里重点介绍一下 FlutterMain::Register方法，代码位于<em>flutter/shell/platform/android/flutter_main.cc</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> FlutterMain::Register(JNIEnv* env) &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">      &#123;</span><br><span class="line">          .name = <span class="string">"nativeInit"</span>,</span><br><span class="line">          .signature = <span class="string">"(Landroid/content/Context;[Ljava/lang/String;Ljava/"</span></span><br><span class="line">                       <span class="string">"lang/String;Ljava/lang/String;Ljava/lang/String;)V"</span>,</span><br><span class="line">          .fnPtr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;Init),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          .name = <span class="string">"nativeRecordStartTimestamp"</span>,</span><br><span class="line">          .signature = <span class="string">"(J)V"</span>,</span><br><span class="line">          .fnPtr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;RecordStartTimestamp),</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  jclass clazz = env-&gt;FindClass(<span class="string">"io/flutter/embedding/engine/FlutterJNI"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (clazz == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> env-&gt;RegisterNatives(clazz, methods, fml::size(methods)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是将C++方法Init和RecordStartTimestamp方法分别与ava层FlutterJNI中的nativeInit和nativeRecordStartTimestamp方法绑定，这样就能通过jni实现java代码调用C++代码。另外两个Register方法的作用是一样的，也是注册对应的native方法，具体代码在：<br><em>flutter_engine/shell/platform/android/platform_view_android.h</em><br><em>flutter_engine/shell/platform/android/vsync_waiter_android.h</em></p><h3 id="C-层的初始化"><a href="#C-层的初始化" class="headerlink" title="C++层的初始化"></a>C++层的初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FlutterMain::Init(JNIEnv* env,</span><br><span class="line">                       jclass clazz,</span><br><span class="line">                       jobject context,</span><br><span class="line">                       jobjectArray jargs,</span><br><span class="line">                       jstring kernelPath,</span><br><span class="line">                       jstring appStoragePath,</span><br><span class="line">                       jstring engineCachesPath) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; args;</span><br><span class="line">  args.push_back(<span class="string">"flutter"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; arg : fml::jni::StringArrayToVector(env, jargs)) &#123;</span><br><span class="line">    args.push_back(<span class="built_in">std</span>::move(arg));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> command_line = fml::CommandLineFromIterators(args.begin(), args.end());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> settings = SettingsFromCommandLine(command_line);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Restore the callback cache.</span></span><br><span class="line">  <span class="comment">// TODO(chinmaygarde): Route all cache file access through FML and remove this</span></span><br><span class="line">  <span class="comment">// setter.</span></span><br><span class="line">  flutter::DartCallbackCache::SetCachePath(</span><br><span class="line">      fml::jni::JavaStringToString(env, appStoragePath));</span><br><span class="line"></span><br><span class="line">  fml::paths::InitializeAndroidCachesPath(</span><br><span class="line">      fml::jni::JavaStringToString(env, engineCachesPath));</span><br><span class="line"></span><br><span class="line">  flutter::DartCallbackCache::LoadCacheFromDisk();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flutter::DartVM::IsRunningPrecompiledCode() &amp;&amp; kernelPath) &#123;</span><br><span class="line">    <span class="comment">// Check to see if the appropriate kernel files are present and configure</span></span><br><span class="line">    <span class="comment">// settings accordingly.</span></span><br><span class="line">    <span class="keyword">auto</span> application_kernel_path =</span><br><span class="line">        fml::jni::JavaStringToString(env, kernelPath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fml::IsFile(application_kernel_path)) &#123;</span><br><span class="line">      settings.application_kernel_asset = application_kernel_path;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  settings.task_observer_add = [](<span class="keyword">intptr_t</span> key, fml::closure callback) &#123;</span><br><span class="line">    fml::MessageLoop::GetCurrent().AddTaskObserver(key, <span class="built_in">std</span>::move(callback));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  settings.task_observer_remove = [](<span class="keyword">intptr_t</span> key) &#123;</span><br><span class="line">    fml::MessageLoop::GetCurrent().RemoveTaskObserver(key);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FLUTTER_RUNTIME_MODE == FLUTTER_RUNTIME_MODE_DEBUG</span></span><br><span class="line">  <span class="comment">// There are no ownership concerns here as all mappings are owned by the</span></span><br><span class="line">  <span class="comment">// embedder and not the engine.</span></span><br><span class="line">  <span class="keyword">auto</span> make_mapping_callback = [](<span class="keyword">const</span> <span class="keyword">uint8_t</span>* mapping, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="keyword">return</span> [mapping, size]() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;fml::NonOwnedMapping&gt;(mapping, size);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  settings.dart_library_sources_kernel =</span><br><span class="line">      make_mapping_callback(kPlatformStrongDill, kPlatformStrongDillSize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// FLUTTER_RUNTIME_MODE == FLUTTER_RUNTIME_MODE_DEBUG</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not thread safe. Will be removed when FlutterMain is refactored to no</span></span><br><span class="line">  <span class="comment">// longer be a singleton.</span></span><br><span class="line">  g_flutter_main.reset(<span class="keyword">new</span> FlutterMain(<span class="built_in">std</span>::move(settings)));</span><br><span class="line"></span><br><span class="line">  g_flutter_main-&gt;SetupObservatoryUriCallback(env);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码只是将java层传过来的初始化参数校验拼装成flutter::Settings对象，然后在创建FlutterMain时传入。查看FlutterMain的构造函数可以看到并没有什么特殊操作，只是将setting对象赋值给常量成员<code>_settings</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FlutterMain::FlutterMain(flutter::Settings settings)</span><br><span class="line">    : settings_(<span class="built_in">std</span>::move(settings)), observatory_uri_callback_() &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="注册垂直同步信号"><a href="#注册垂直同步信号" class="headerlink" title="注册垂直同步信号"></a>注册垂直同步信号</h3><p><code>startInitialization</code>方法中初始化了GPU垂直同步信号，用来将GPU发出的渲染信号通知给引擎和Dart层。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VsyncWaiter.getInstance((WindowManager)applicationContext.getSystemService(<span class="string">"window"</span>)).init();</span><br></pre></td></tr></table></figure><p>在android平台上<em>Choreographer</em>类管理GPU帧信号与View绘制相关工作，它有个<em>doFrame</em>回调通知业务层某一帧开始绘制，其实<em>VsyncWaiter</em>的<em>init</em>方法就是向<em>Choreographer</em>注册了一个<em>doFrame</em>回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AsyncWaitForVsyncDelegate asyncWaitForVsyncDelegate = <span class="keyword">new</span> AsyncWaitForVsyncDelegate() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncWaitForVsync</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> cookie)</span> </span>&#123;</span><br><span class="line">            Choreographer.getInstance().postFrameCallback(<span class="keyword">new</span> FrameCallback() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">float</span> fps = VsyncWaiter.<span class="keyword">this</span>.windowManager.getDefaultDisplay().getRefreshRate();</span><br><span class="line">                    <span class="keyword">long</span> refreshPeriodNanos = (<span class="keyword">long</span>)(<span class="number">1.0E9</span>D / (<span class="keyword">double</span>)fps);</span><br><span class="line">                    FlutterJNI.nativeOnVsync(frameTimeNanos, frameTimeNanos + refreshPeriodNanos, cookie);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>由以上代码可以看到在GPU发出Vsync信号后，会通过JNI调用C++层渲染逻辑，即上述代码中<em>FlutterJNI.nativeOnVsync</em>完成的逻辑</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>纵观FlutterApplication中的初始化逻辑，并没有很复杂和耗时的操作，都是一些准备工作，如下图：</p><p><img src="https://raw.githubusercontent.com/seasonfif/picture/master/flutter/FlutterApplication_create.jpg" alt="FlutterApplication_create"></p><p>总结其主要工作有以下几点：</p><ol><li>确保该方法必须运行在主线程，否则抛出异常；</li><li>初始化配置参数，vm_snapshot_data、vm_snapshot_instr、isolate_snapshot_data、isolate_snapshot_instr、flutter_assets的值</li><li>获取应用根目录下的所有assets资源路径，提取产物资源，加载到内存；</li><li>加载libflutter.so库，调用JNI_OnLoad()；<ul><li>Android进程自身会创建JavaVM，此处将当前进程的JavaVM实例保存在静态变量g_jvm，再将当前线程和JavaVM建立关联</li><li>注册FlutterMain的JNI方法，nativeInit()和nativeRecordStartTimestamp()</li><li>注册PlatformViewAndroid的一系列方法，完成Java和C++的一些方法互调；</li><li>注册VSyncWaiter的nativeOnVsync()用于Java调用C++，asyncWaitForVsync()用于C++调用Java；</li></ul></li><li>最终将FlutterApplication的启动耗时记录，通过engine_main_enter_ts变量。</li></ol>]]></content>
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python分布式进程</title>
      <link href="/2017/10/23/python/python%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%9B%E7%A8%8B/"/>
      <url>/2017/10/23/python/python%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%9B%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>　　Python的multiprocessing模块不但支持多进程，其中managers子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务发布到其他多个进程中，依靠网络通信。managers模块封装内部网络通信的细节，提供给我们精简的接口来编写分布式进程程序。<br>　　managers子模块使用Queue进行多进程的通信，通过managers模块把Queue注册到网络上面，就可以让其他机器的进程访问Queue了，进而获取列表中的任务执行，执行完成后可以将结果保存到Queue，然后在调度机器上轮训读取结果处理。</p><h3 id="调度进程"><a href="#调度进程" class="headerlink" title="调度进程"></a>调度进程</h3><p>　　调度进程负责启动Queue，把Queue注册到网络上，然后往Queue里面写入任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> job <span class="keyword">import</span> Job</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送任务的队列:</span></span><br><span class="line">task_queue = Queue(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 接收结果的队列:</span></span><br><span class="line">result_queue = Queue()</span><br><span class="line">dispatch_jobs = Queue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_task_queue</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">global</span> task_queue</span><br><span class="line"><span class="keyword">return</span> task_queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_result_queue</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">global</span> result_queue</span><br><span class="line"><span class="keyword">return</span> result_queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_job</span><span class="params">(manager)</span>:</span></span><br><span class="line"><span class="keyword">global</span> dispatch_jobs</span><br><span class="line">dispatch_jobs = manager.get_task_queue()</span><br><span class="line">job_id = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">job_id += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> dispatch_jobs.full():</span><br><span class="line">job = Job(job_id)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Dispatch job: %s'</span> % job.job_id</span><br><span class="line">dispatch_jobs.put(job)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Task full, please wait'</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_job_result</span><span class="params">(manager)</span>:</span></span><br><span class="line">finished_jobs = manager.get_result_queue()</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> dispatch_jobs.empty():</span><br><span class="line">job = finished_jobs.get()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Finished Job: %s'</span> % job.job_id</span><br><span class="line">manager.shutdown()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">multiprocessing.freeze_support()</span><br><span class="line">BaseManager.register(<span class="string">'get_task_queue'</span>, callable=return_task_queue)</span><br><span class="line">BaseManager.register(<span class="string">'get_result_queue'</span>, callable=return_result_queue)</span><br><span class="line"></span><br><span class="line">manager = BaseManager(address=(<span class="string">"127.0.0.1"</span>, <span class="number">5000</span>), authkey=<span class="string">"jobs"</span>)</span><br><span class="line">manager.start()</span><br><span class="line"></span><br><span class="line">threading.Thread(target=add_job, args=(manager,)).start()</span><br><span class="line">threading.Thread(target=handle_job_result, args=(manager,)).start()</span><br></pre></td></tr></table></figure></p><p>　　当我们在一台机器上写多进程程序时，创建的Queue可以直接拿来用，但是，在分布式多进程环境下，添加任务到Queue不可以直接对原始的task_queue进行操作，那样就绕过了QueueManager的封装，必须通过manager.get_task_queue()获得的Queue接口添加。</p><h3 id="任务进程"><a href="#任务进程" class="headerlink" title="任务进程"></a>任务进程</h3><p>　　然后，在另一台机器上启动任务进程（本机上启动也可以）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slave</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">self.dispatch_job_queue = Queue()</span><br><span class="line">self.finished_job_queue = Queue()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="comment"># 把派发作业队列和完成作业队列注册到网络上</span></span><br><span class="line">BaseManager.register(<span class="string">'get_task_queue'</span>)</span><br><span class="line">BaseManager.register(<span class="string">'get_result_queue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接master</span></span><br><span class="line">server = <span class="string">'127.0.0.1'</span></span><br><span class="line">print(<span class="string">'Connect to server %s...'</span> % server)</span><br><span class="line">manager = BaseManager(address=(server, <span class="number">5000</span>), authkey=<span class="string">'jobs'</span>)</span><br><span class="line">manager.connect()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用上面注册的方法获取队列</span></span><br><span class="line">dispatch_jobs = manager.get_task_queue()</span><br><span class="line">finished_jobs = manager.get_result_queue()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">job = dispatch_jobs.get()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"%s Run job %s"</span> % (os.getpid(), job.job_id)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">finished_jobs.put(job)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">slave = Slave()</span><br><span class="line">slave.start()</span><br></pre></td></tr></table></figure></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>　　因为任务进程要通过网络连接到调度进程，所以每个任务进程需要指定调度进程的IP。<br>　　注意Queue的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由任务进程再去共享的磁盘上读取文件。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>python学习-高阶特性</title>
      <link href="/2017/08/16/python/python%E5%AD%A6%E4%B9%A0-%E9%AB%98%E9%98%B6%E7%89%B9%E6%80%A7/"/>
      <url>/2017/08/16/python/python%E5%AD%A6%E4%B9%A0-%E9%AB%98%E9%98%B6%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<h3 id="python面向对象"><a href="#python面向对象" class="headerlink" title="python面向对象"></a>python面向对象</h3><p>Python是一门面向对象的语言，因此创建一个类和对象是很容易的。<br>回顾下面向对象的一些基本特征：</p><pre><code>类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。实例变量：定义在方法中的变量，只作用于当前实例的类。继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟&quot;是一个（is-a）&quot;关系（例图，Dog是一个Animal）。实例化：创建一个类的实例，类的具体对象。方法：类中定义的函数。对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</code></pre><h4 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h4><p>使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span></span><br><span class="line">   <span class="string">'类的帮助信息'</span>   <span class="comment">#类文档字符串</span></span><br><span class="line">   class_suite  <span class="comment">#类体</span></span><br></pre></td></tr></table></figure></p><p>类的帮助信息可以通过ClassName.<strong>doc</strong>查看。<br>class_suite 由类成员，方法，数据属性组成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">   <span class="string">'所有员工的基类'</span></span><br><span class="line">   empCount = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, salary)</span>:</span></span><br><span class="line">      self.name = name</span><br><span class="line">      self.salary = salary</span><br><span class="line">      Employee.empCount += <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayCount</span><span class="params">(self)</span>:</span></span><br><span class="line">     <span class="keyword">print</span> <span class="string">"Total Employee %d"</span> % Employee.empCount</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayEmployee</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">print</span> <span class="string">"Name : "</span>, self.name,  <span class="string">", Salary: "</span>, self.salary</span><br></pre></td></tr></table></figure></p><p>empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。<br>第一种方法<strong>init</strong>()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法<br>self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。</p><h4 id="创建实例对象"><a href="#创建实例对象" class="headerlink" title="创建实例对象"></a>创建实例对象</h4><p>实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。<br>以下使用类的名称 Employee 来实例化，并通过 <strong>init</strong> 方法接受参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"创建 Employee 类的第一个对象"</span></span><br><span class="line">emp1 = Employee(<span class="string">"Zara"</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="string">"创建 Employee 类的第二个对象"</span></span><br><span class="line">emp2 = Employee(<span class="string">"Manni"</span>, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure></p><h4 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h4><p>使用点(.)来访问对象的属性。使用如下类的名称访问类变量:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emp1.displayEmployee()</span><br><span class="line">emp2.displayEmployee()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Total Employee %d"</span> % Employee.empCount</span><br></pre></td></tr></table></figure></p><p>可以添加，删除，修改类的属性，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emp1.age = <span class="number">7</span>  <span class="comment"># 添加一个 'age' 属性</span></span><br><span class="line">emp1.age = <span class="number">8</span>  <span class="comment"># 修改 'age' 属性</span></span><br><span class="line"><span class="keyword">del</span> emp1.age  <span class="comment"># 删除 'age' 属性</span></span><br></pre></td></tr></table></figure></p><p>也可以使用以下函数的方式来访问属性：</p><pre><code>getattr(obj, name[, default]) : 访问对象的属性。hasattr(obj,name) : 检查是否存在一个属性。setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。delattr(obj, name) : 删除属性。</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hasattr(emp1, <span class="string">'age'</span>)    <span class="comment"># 如果存在 'age' 属性返回 True。</span></span><br><span class="line">getattr(emp1, <span class="string">'age'</span>)    <span class="comment"># 返回 'age' 属性的值</span></span><br><span class="line">setattr(emp1, <span class="string">'age'</span>, <span class="number">8</span>) <span class="comment"># 添加属性 'age' 值为 8</span></span><br><span class="line">delattr(emp1, <span class="string">'age'</span>)    <span class="comment"># 删除属性 'age'</span></span><br></pre></td></tr></table></figure><h4 id="Python内置类属性"><a href="#Python内置类属性" class="headerlink" title="Python内置类属性"></a>Python内置类属性</h4><pre><code>__dict__ : 类的属性（包含一个字典，由类的数据属性组成）__doc__ :类的文档字符串__name__: 类名__module__: 类定义所在的模块（类的全名是&apos;__main__.className&apos;，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod）__bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组）</code></pre><h4 id="python对象销毁-垃圾回收"><a href="#python对象销毁-垃圾回收" class="headerlink" title="python对象销毁(垃圾回收)"></a>python对象销毁(垃圾回收)</h4><p> Python 使用了引用计数这一简单技术来跟踪和回收垃圾。<br>在 Python 内部记录着所有使用中的对象各有多少引用。<br>一个内部跟踪变量，称为一个引用计数器。<br>当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是”立即”的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">40</span>      <span class="comment"># 创建对象  &lt;40&gt;</span></span><br><span class="line">b = a       <span class="comment"># 增加引用， &lt;40&gt; 的计数</span></span><br><span class="line">c = [b]     <span class="comment"># 增加引用.  &lt;40&gt; 的计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a       <span class="comment"># 减少引用 &lt;40&gt; 的计数</span></span><br><span class="line">b = <span class="number">100</span>     <span class="comment"># 减少引用 &lt;40&gt; 的计数</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="number">-1</span>   <span class="comment"># 减少引用 &lt;40&gt; 的计数</span></span><br></pre></td></tr></table></figure></p><p>垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（及未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。<br>析构函数 <strong>del</strong>，<strong>del</strong>在对象销毁的时候被调用，当对象不再被使用时，<strong>del</strong>方法运行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">( self, x=<span class="number">0</span>, y=<span class="number">0</span>)</span>:</span></span><br><span class="line">      self.x = x</span><br><span class="line">      self.y = y</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">      class_name = self.__class__.__name__</span><br><span class="line">      <span class="keyword">print</span> class_name, <span class="string">"销毁"</span></span><br><span class="line"> </span><br><span class="line">pt1 = Point()</span><br><span class="line">pt2 = pt1</span><br><span class="line">pt3 = pt1</span><br><span class="line"><span class="keyword">print</span> id(pt1), id(pt2), id(pt3) <span class="comment"># 打印对象的id</span></span><br><span class="line"><span class="keyword">del</span> pt1</span><br><span class="line"><span class="keyword">del</span> pt2</span><br><span class="line"><span class="keyword">del</span> pt3</span><br></pre></td></tr></table></figure></p><p>以上实例运行结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3083401324</span> <span class="number">3083401324</span> <span class="number">3083401324</span></span><br><span class="line">Point 销毁</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>python学习-基础语法</title>
      <link href="/2017/08/10/python/python%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2017/08/10/python/python%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h4 id="python变量"><a href="#python变量" class="headerlink" title="python变量"></a>python变量</h4><p>Python 中的变量赋值不需要类型声明。<br>每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。<br>每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。等号（=）用来给变量赋值。<br>等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">counter = <span class="number">100</span> <span class="comment"># 赋值整型变量</span></span><br><span class="line">miles = <span class="number">1000.0</span> <span class="comment"># 浮点型</span></span><br><span class="line">name = <span class="string">"John"</span> <span class="comment"># 字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> counter</span><br><span class="line"><span class="keyword">print</span> miles</span><br><span class="line"><span class="keyword">print</span> name</span><br></pre></td></tr></table></figure></p><h4 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h4><p>在内存中存储的数据可以有多种类型。<br>例如，一个人的年龄可以用数字来存储，他的名字可以用字符来存储。<br>Python 定义了一些标准类型，用于存储各种类型的数据。<br>Python有五个标准的数据类型：<br>    Numbers（数字）<br>    String（字符串）<br>    List（列表）<br>    Tuple（元组）<br>    Dictionary（字典）</p><h4 id="pytho数字"><a href="#pytho数字" class="headerlink" title="pytho数字"></a>pytho数字</h4><p>数字数据类型用于存储数值。<br>他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。<br>当你指定一个值时，Number对象就会被创建：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1 = <span class="number">1</span></span><br><span class="line">var2 = <span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>您也可以使用del语句删除一些对象的引用。<br>del语句的语法是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> var1[,var2[,var3[....,varN]]]]</span><br></pre></td></tr></table></figure></p><p>您可以通过使用del语句删除单个或多个对象的引用。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> var</span><br><span class="line"><span class="keyword">del</span> var_a, var_b</span><br></pre></td></tr></table></figure></p><p>Python支持四种不同的数字类型：</p><pre><code>int（有符号整型）long（长整型[也可以代表八进制和十六进制]）float（浮点型）complex（复数） </code></pre><h4 id="Python字符串"><a href="#Python字符串" class="headerlink" title="Python字符串"></a>Python字符串</h4><p>字符串或串(String)是由数字、字母、下划线组成的一串字符。<br>它是编程语言中表示文本的数据类型。<br>python的字串列表有2种取值顺序:</p><pre><code>从左到右索引默认0开始的，最大范围是字符串长度少1从右到左索引默认-1开始的，最大范围是字符串开头</code></pre><p>如果你要实现从字符串中获取一段子字符串的话，可以使用变量 [头下标:尾下标]，就可以截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。<br>比如:<br>s = ‘ilovepython’<br>s[1:5]的结果是love。<br>当使用以冒号分隔的字符串，python返回一个新的对象，结果包含了以这对偏移标识的连续的内容，左边的开始是包含了下边界。<br>上面的结果包含了s[1]的值l，而取到的最大范围不包括上边界，就是s[5]的值p。<br>加号（+）是字符串连接运算符，星号（*）是重复操作。如下实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">'Hello World!'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> str           <span class="comment"># 输出完整字符串</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">0</span>]        <span class="comment"># 输出字符串中的第一个字符</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">2</span>:<span class="number">5</span>]      <span class="comment"># 输出字符串中第三个至第五个之间的字符串</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">2</span>:]       <span class="comment"># 输出从第三个字符开始的字符串</span></span><br><span class="line"><span class="keyword">print</span> str * <span class="number">2</span>       <span class="comment"># 输出字符串两次</span></span><br><span class="line"><span class="keyword">print</span> str + <span class="string">"TEST"</span>  <span class="comment"># 输出连接的字符串</span></span><br></pre></td></tr></table></figure></p><p>以上实例输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">H</span><br><span class="line">llo</span><br><span class="line">llo World!</span><br><span class="line">Hello World!Hello World!</span><br><span class="line">Hello World!TEST</span><br></pre></td></tr></table></figure></p><h4 id="Python列表"><a href="#Python列表" class="headerlink" title="Python列表"></a>Python列表</h4><p>List（列表） 是 Python 中使用最频繁的数据类型。<br>列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。<br>列表用 [ ] 标识，是 python 最通用的复合数据类型。<br>列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。<br>加号 + 是列表连接运算符，星号 * 是重复操作。如下实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list = [ <span class="string">'seasonfif'</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span> ]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">'john'</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> list               <span class="comment"># 输出完整列表</span></span><br><span class="line"><span class="keyword">print</span> list[<span class="number">0</span>]            <span class="comment"># 输出列表的第一个元素</span></span><br><span class="line"><span class="keyword">print</span> list[<span class="number">1</span>:<span class="number">3</span>]          <span class="comment"># 输出第二个至第三个元素 </span></span><br><span class="line"><span class="keyword">print</span> list[<span class="number">2</span>:]           <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="keyword">print</span> tinylist * <span class="number">2</span>       <span class="comment"># 输出列表两次</span></span><br><span class="line"><span class="keyword">print</span> list + tinylist    <span class="comment"># 打印组合的列表</span></span><br></pre></td></tr></table></figure></p><p>以上实例输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'seasonfif'</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span>]</span><br><span class="line">seasonfif</span><br><span class="line">[<span class="number">786</span>, <span class="number">2.23</span>]</span><br><span class="line">[<span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span>]</span><br><span class="line">[<span class="number">123</span>, <span class="string">'john'</span>, <span class="number">123</span>, <span class="string">'john'</span>]</span><br><span class="line">[<span class="string">'seasonfif'</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span>, <span class="number">123</span>, <span class="string">'john'</span>]</span><br></pre></td></tr></table></figure></p><h4 id="Python元组"><a href="#Python元组" class="headerlink" title="Python元组"></a>Python元组</h4><p>元组是另一个数据类型，类似于List（列表）。<br>元组用”()”标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tuple = ( <span class="string">'seasonfif'</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span> )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">'john'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> tuple               <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="keyword">print</span> tuple[<span class="number">0</span>]            <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="keyword">print</span> tuple[<span class="number">1</span>:<span class="number">3</span>]          <span class="comment"># 输出第二个至第三个的元素 </span></span><br><span class="line"><span class="keyword">print</span> tuple[<span class="number">2</span>:]           <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="keyword">print</span> tinytuple * <span class="number">2</span>       <span class="comment"># 输出元组两次</span></span><br><span class="line"><span class="keyword">print</span> tuple + tinytuple   <span class="comment"># 打印组合的元组</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">'seasonfif'</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span>)</span><br><span class="line">seasonfif</span><br><span class="line">(<span class="number">786</span>, <span class="number">2.23</span>)</span><br><span class="line">(<span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span>)</span><br><span class="line">(<span class="number">123</span>, <span class="string">'john'</span>, <span class="number">123</span>, <span class="string">'john'</span>)</span><br><span class="line">(<span class="string">'seasonfif'</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span>, <span class="number">123</span>, <span class="string">'john'</span>)</span><br></pre></td></tr></table></figure></p><p>以下是元组无效的，因为元组是不允许更新的。而列表是允许更新的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tuple = ( <span class="string">'seasonfif'</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span> )</span><br><span class="line">list = [ <span class="string">'seasonfif'</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span> ]</span><br><span class="line">tuple[<span class="number">2</span>] = <span class="number">1000</span>    <span class="comment"># 元组中是非法应用</span></span><br><span class="line">list[<span class="number">2</span>] = <span class="number">1000</span>     <span class="comment"># 列表中是合法应用</span></span><br></pre></td></tr></table></figure></p><h4 id="Python-字典"><a href="#Python-字典" class="headerlink" title="Python 字典"></a>Python 字典</h4><p>字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。<br>两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。<br>字典用”{ }”标识。字典由索引(key)和它对应的值value组成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;&#125;</span><br><span class="line">dict[<span class="string">'one'</span>] = <span class="string">"This is one"</span></span><br><span class="line">dict[<span class="number">2</span>] = <span class="string">"This is two"</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;<span class="string">'name'</span>: <span class="string">'john'</span>,<span class="string">'code'</span>:<span class="number">6734</span>, <span class="string">'dept'</span>: <span class="string">'sales'</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> dict[<span class="string">'one'</span>]          <span class="comment"># 输出键为'one' 的值</span></span><br><span class="line"><span class="keyword">print</span> dict[<span class="number">2</span>]              <span class="comment"># 输出键为 2 的值</span></span><br><span class="line"><span class="keyword">print</span> tinydict             <span class="comment"># 输出完整的字典</span></span><br><span class="line"><span class="keyword">print</span> tinydict.keys()      <span class="comment"># 输出所有键</span></span><br><span class="line"><span class="keyword">print</span> tinydict.values()    <span class="comment"># 输出所有值</span></span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This <span class="keyword">is</span> one</span><br><span class="line">This <span class="keyword">is</span> two</span><br><span class="line">&#123;<span class="string">'dept'</span>: <span class="string">'sales'</span>, <span class="string">'code'</span>: <span class="number">6734</span>, <span class="string">'name'</span>: <span class="string">'john'</span>&#125;</span><br><span class="line">[<span class="string">'dept'</span>, <span class="string">'code'</span>, <span class="string">'name'</span>]</span><br><span class="line">[<span class="string">'sales'</span>, <span class="number">6734</span>, <span class="string">'john'</span>]</span><br></pre></td></tr></table></figure></p><h4 id="Python条件语句"><a href="#Python条件语句" class="headerlink" title="Python条件语句"></a>Python条件语句</h4><p>Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false。<br>Python 编程中 if 语句用于控制程序的执行，基本形式为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件：</span><br><span class="line">    执行语句……</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    执行语句……</span><br></pre></td></tr></table></figure></p><p>其中”判断条件”成立时（非零），则执行后面的语句，而执行内容可以多行，以缩进来区分表示同一范围。<br>else 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句，具体例子如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="keyword">False</span></span><br><span class="line">name = <span class="string">'java'</span></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">'python'</span>:         <span class="comment"># 判断变量否为'python'</span></span><br><span class="line">    flag = <span class="keyword">True</span>          <span class="comment"># 条件成立时设置标志为真</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span>    <span class="comment"># 并输出欢迎信息</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> name              <span class="comment"># 条件不成立时输出变量名称</span></span><br></pre></td></tr></table></figure></p><p>当判断条件为多个值时，可以使用以下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件<span class="number">1</span>:</span><br><span class="line">    执行语句<span class="number">1</span>……</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">2</span>:</span><br><span class="line">    执行语句<span class="number">2</span>……</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">3</span>:</span><br><span class="line">    执行语句<span class="number">3</span>……</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    执行语句<span class="number">4</span>……</span><br></pre></td></tr></table></figure></p><p>由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现</p><h4 id="Python循环语句"><a href="#Python循环语句" class="headerlink" title="Python循环语句"></a>Python循环语句</h4><p>Python提供了for循环和while循环（在Python中没有do..while循环）:</p><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">9</span>):</span><br><span class="line">   <span class="keyword">print</span> <span class="string">'The count is:'</span>, count</span><br><span class="line">   count = count + <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Good bye!"</span></span><br></pre></td></tr></table></figure><p>以上代码的运行结果是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">The count <span class="keyword">is</span>: <span class="number">0</span></span><br><span class="line">The count <span class="keyword">is</span>: <span class="number">1</span></span><br><span class="line">The count <span class="keyword">is</span>: <span class="number">2</span></span><br><span class="line">The count <span class="keyword">is</span>: <span class="number">3</span></span><br><span class="line">The count <span class="keyword">is</span>: <span class="number">4</span></span><br><span class="line">The count <span class="keyword">is</span>: <span class="number">5</span></span><br><span class="line">The count <span class="keyword">is</span>: <span class="number">6</span></span><br><span class="line">The count <span class="keyword">is</span>: <span class="number">7</span></span><br><span class="line">The count <span class="keyword">is</span>: <span class="number">8</span></span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure></p><p>while还可以和else搭配使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">   <span class="keyword">print</span> count, <span class="string">" is  less than 5"</span></span><br><span class="line">   count = count + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> count, <span class="string">" is not less than 5"</span></span><br></pre></td></tr></table></figure></p><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>1、最基础的循环：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">'Python'</span>:     <span class="comment"># 第一个实例</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">'当前字母 :'</span>, letter</span><br><span class="line"> </span><br><span class="line">fruits = [<span class="string">'banana'</span>, <span class="string">'apple'</span>,  <span class="string">'mango'</span>]</span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> fruits:        <span class="comment"># 第二个实例</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">'当前水果 :'</span>, fruit</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Good bye!"</span></span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">当前字母 : P</span><br><span class="line">当前字母 : y</span><br><span class="line">当前字母 : t</span><br><span class="line">当前字母 : h</span><br><span class="line">当前字母 : o</span><br><span class="line">当前字母 : n</span><br><span class="line">当前水果 : banana</span><br><span class="line">当前水果 : apple</span><br><span class="line">当前水果 : mango</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure></p><p>2、另外一种执行循环的遍历方式是通过索引，如下实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">'banana'</span>, <span class="string">'apple'</span>,  <span class="string">'mango'</span>]</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(len(fruits)):</span><br><span class="line">   <span class="keyword">print</span> <span class="string">'当前水果 :'</span>, fruits[index]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Good bye!"</span></span><br></pre></td></tr></table></figure></p><p>3、使用内置 enumerate 函数进行遍历:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequence = [<span class="number">12</span>, <span class="number">34</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">89</span>]</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(sequence):</span><br><span class="line">      <span class="keyword">print</span> i,j</span><br></pre></td></tr></table></figure></p><p>结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">12</span></span><br><span class="line"><span class="number">1</span> <span class="number">34</span></span><br><span class="line"><span class="number">2</span> <span class="number">34</span></span><br><span class="line"><span class="number">3</span> <span class="number">23</span></span><br><span class="line"><span class="number">4</span> <span class="number">45</span></span><br><span class="line"><span class="number">5</span> <span class="number">76</span></span><br><span class="line"><span class="number">6</span> <span class="number">89</span></span><br></pre></td></tr></table></figure></p><h4 id="Python函数"><a href="#Python函数" class="headerlink" title="Python函数"></a>Python函数</h4><h5 id="函数语法"><a href="#函数语法" class="headerlink" title="函数语法"></a>函数语法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">( parameters )</span>:</span></span><br><span class="line">   <span class="string">"函数_文档字符串"</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure><p>规则：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数代码块以 <span class="function"><span class="keyword">def</span> 关键词开头，后接函数标识符名称和圆括号<span class="params">()</span>。</span></span><br><span class="line"><span class="function">任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</span></span><br><span class="line"><span class="function">函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</span></span><br><span class="line"><span class="function">函数内容以冒号起始，并且缩进。</span></span><br><span class="line"><span class="function"><span class="title">return</span> [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的<span class="title">return</span>相当于返回 <span class="title">None</span>。</span></span><br></pre></td></tr></table></figure></p><h5 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h5><p>定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。<br>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python提示符执行。<br>如下实例调用了printme（）函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span><span class="params">( str )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> str;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">printme(<span class="string">"我要调用用户自定义函数!"</span>);</span><br><span class="line">printme(<span class="string">"再次调用同一函数"</span>);</span><br></pre></td></tr></table></figure></p><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>以下是调用函数时可使用的正式参数类型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">必备参数</span><br><span class="line">关键字参数</span><br><span class="line">默认参数</span><br><span class="line">不定长参数</span><br></pre></td></tr></table></figure></p><h5 id="必备参数"><a href="#必备参数" class="headerlink" title="必备参数"></a>必备参数</h5><p>必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。<br>调用printme()函数，你必须传入一个参数，不然会出现语法错误：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span><span class="params">( str )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> str;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printme函数</span></span><br><span class="line">printme();</span><br></pre></td></tr></table></figure></p><p>以上实例输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    printme();</span><br><span class="line">TypeError: printme() takes exactly <span class="number">1</span> argument (<span class="number">0</span> given)</span><br></pre></td></tr></table></figure></p><h5 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h5><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。<br>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。<br>以下实例在函数 printme() 调用时使用参数名：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span><span class="params">( str )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> str;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printme函数</span></span><br><span class="line">printme( str = <span class="string">"My string"</span>);</span><br></pre></td></tr></table></figure></p><p>以上实例输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My string</span><br></pre></td></tr></table></figure></p><h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p>调用函数时，默认参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( name, age = <span class="number">35</span> )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"Name: "</span>, name;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"Age "</span>, age;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">"miki"</span> );</span><br><span class="line">printinfo( name=<span class="string">"miki"</span> );</span><br></pre></td></tr></table></figure></p><p>以上实例输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name:  miki</span><br><span class="line">Age  <span class="number">50</span></span><br><span class="line">Name:  miki</span><br><span class="line">Age  <span class="number">35</span></span><br></pre></td></tr></table></figure></p><h5 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h5><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">([formal_args,] *var_args_tuple )</span>:</span></span><br><span class="line">   <span class="string">"函数_文档字符串"</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure></p><p>加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( arg1, *vartuple )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的参数"</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"输出: "</span></span><br><span class="line">   <span class="keyword">print</span> arg1</span><br><span class="line">   <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</span><br><span class="line">      <span class="keyword">print</span> var</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">10</span> );</span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> );</span><br></pre></td></tr></table></figure></p><p>以上实例输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输出:</span><br><span class="line"><span class="number">10</span></span><br><span class="line">输出:</span><br><span class="line"><span class="number">70</span></span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一致性hash</title>
      <link href="/2017/07/18/other/%E4%B8%80%E8%87%B4%E6%80%A7hash/"/>
      <url>/2017/07/18/other/%E4%B8%80%E8%87%B4%E6%80%A7hash/</url>
      <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>1、先来看下传统的取模方式</p><p>例如10条数据，3个节点，如果按照取模的方式，那就是</p><p>node a: 0,3,6,9</p><p>node b: 1,4,7</p><p>node c: 2,5,8</p><p>当增加一个节点的时候，数据分布就变更为</p><p>node a:0,4,8</p><p>node b:1,5,9</p><p>node c: 2,6</p><p>node d: 3,7</p><p>总结：数据3,4,5,6,7,8,9在增加节点的时候，都需要做搬迁，成本太高</p><p>2、一致性哈希方式</p><p>最关键的区别就是，对节点和数据，都做一次哈希运算，然后比较节点和数据的哈希值，数据取和节点最相近的节点做为存放节点。这样就保证当节点增加或者减少的时候，影响的数据最少。</p><p>还是拿刚刚的例子，（用简单的字符串的ascii码做哈希key）：</p><p>十条数据，算出各自的哈希值</p><p>0：192</p><p>1：196</p><p>2：200</p><p>3：204</p><p>4：208</p><p>5：212</p><p>6：216</p><p>7：220</p><p>8：224</p><p>9：228</p><p>有三个节点，算出各自的哈希值</p><p>node a: 203</p><p>node g: 209</p><p>node z: 228</p><p>这个时候比较两者的哈希值，如果大于228，就归到前面的203，相当于整个哈希值就是一个环，对应的映射结果：</p><p>node a: 0,1,2</p><p>node g: 3,4</p><p>node z: 5,6,7,8,9</p><p>这个时候加入node n, 就可以算出node n的哈希值：</p><p>node n: 216</p><p>这个时候对应的数据就会做迁移：</p><p>node a: 0,1,2</p><p>node g: 3,4</p><p>node n: 5,6</p><p>node z: 7,8,9</p><p>这个时候只有5和6需要做迁移</p><p>另外，这个时候如果只算出三个哈希值，那再跟数据的哈希值比较的时候，很容易分得不均衡，因此就引入了虚拟节点的概念，通过把三个节点加上ID后缀等方式，每个节点算出n个哈希值，均匀的放在哈希环上，这样对于数据算出的哈希值，能够比较散列的分布</p><p>通过这种算法做数据分布，在增减节点的时候，可以大大减少数据的迁移规模。</p>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android window理解</title>
      <link href="/2017/03/17/android/Android-window%E7%90%86%E8%A7%A3/"/>
      <url>/2017/03/17/android/Android-window%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>　　现在很多app会在桌面上显示一个类似悬浮窗的东西，这种效果就需要用 Window 来实现，Window 是一个抽象类，表示一个窗口，它的具体实现类是 PhoneWindow，实现位于 WindowManagerService中。</p><h3 id="Window分类"><a href="#Window分类" class="headerlink" title="Window分类"></a>Window分类</h3><p>　　Window 有三种类型，分别是应用 Window、子 Window 和系统 Window。应用类 Window 对应一个 Acitivity，子 Window 不能单独存在，需要依附在特定的父 Window 中，比如常见的一些 Dialog 就是一个子 Window。系统 Window是需要声明权限才能创建的 Window，比如 Toast 和系统状态栏都是系统 Window。<br>　　Window 是分层的，每个 Window 都有对应的 z-ordered，层级大的会覆盖在层级小的 Window 上面，这和 HTML 中的 z-index 概念是完全一致的。在三种 Window 中，应用 Window 层级范围是 1~99，子 Window 层级范围是 1000~1999，系统 Window 层级范围是 2000~2999。<br>　　这些层级范围对应着 WindowManager.LayoutParams 的 type 参数，如果想要 Window 位于所有 Window 的最顶层，那么采用较大的层级即可，很显然系统 Window 的层级是最大的，当我们采用系统层级时，需要声明权限。</p><h3 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h3><p>　　我们对 Window 的操作是通过 WindowManager 来完成的，WindowManager 是一个接口，它继承自只有三个方法的 ViewManager 接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewManager</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这三个方法其实就是 WindowManager 对外提供的主要功能，即添加 View、更新 View 和删除 View。<br>在实际使用中无法直接访问 Window，对 Window 的访问必须通过 WindowManager。WindowManager 提供的三个接口方法 addView、updateViewLayout 以及 removeView 都是针对 View 的，这说明 View 才是 Window 存在的实体，WindowManager 是一个接口，它的真正实现是 WindowManagerImpl 类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.updateViewLayout(view, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        mGlobal.removeView(view, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>　　可以看到，WindowManagerImpl 并没有直接实现 Window 的三大操作，而是交给了 WindowManagerGlobal 来处理，下面以 addView 为例，分析一下 WindowManagerGlobal 中的实现过程：</p><h4 id="检查参数合法性，如果是子-Window-做适当调整"><a href="#检查参数合法性，如果是子-Window-做适当调整" class="headerlink" title="检查参数合法性，如果是子 Window 做适当调整"></a>检查参数合法性，如果是子 Window 做适当调整</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (display == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"display must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Params must be WindowManager.LayoutParams"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">        <span class="keyword">if</span> (parentWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If there's no parent, then hardware acceleration for this view is</span></span><br><span class="line">            <span class="comment">// set from the application's hardware acceleration setting.</span></span><br><span class="line">            <span class="keyword">final</span> Context context = view.getContext();</span><br><span class="line">            <span class="keyword">if</span> (context != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; (context.getApplicationInfo().flags</span><br><span class="line">                            &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>) &#123;</span><br><span class="line">                wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="创建-ViewRootImpl-并将-View-添加到集合中"><a href="#创建-ViewRootImpl-并将-View-添加到集合中" class="headerlink" title="创建 ViewRootImpl 并将 View 添加到集合中"></a>创建 ViewRootImpl 并将 View 添加到集合中</h4><p>　　在 WindowManagerGlobal 内部有如下几个集合比较重要：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="keyword">new</span> ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams = <span class="keyword">new</span> ArrayList&lt;WindowManager.LayoutParams&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArraySet&lt;View&gt; mDyingViews = <span class="keyword">new</span> ArraySet&lt;View&gt;();</span><br></pre></td></tr></table></figure></p><p>　　其中 mViews 存储的是所有 Window 所对应的 View，mRoots 存储的是所有 Window 所对应的 ViewRootImpl，mParams 存储的是所有 Window 所对应的布局参数，mDyingViews 存储了那些正在被删除的 View 对象，或者说是那些已经调用了 removeView 方法但是操作删除还未完成的 Window 对象。<br>　　addView 操作时会将相关对象添加到对应集合中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="keyword">new</span> ViewRootImpl(view.getContext(),display);</span><br><span class="line">view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">mViews.add(view);</span><br><span class="line">mRoots.add(root);</span><br><span class="line">mParams.add(wparams);</span><br></pre></td></tr></table></figure></p><h4 id="通过-ViewRootImpl-来更新界面并完成-Window-的添加过程"><a href="#通过-ViewRootImpl-来更新界面并完成-Window-的添加过程" class="headerlink" title="通过 ViewRootImpl 来更新界面并完成 Window 的添加过程"></a>通过 ViewRootImpl 来更新界面并完成 Window 的添加过程</h4><p>　　在View 的工作原理中，我们知道 View 的绘制过程是由 ViewRootImpl 来完成的，这里当然也不例外，具体是通过 ViewRootImpl 的 setView 方法来实现的。在 setView 内部会通过 requestLayout 来完成异步刷新请求，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">           checkThread();</span><br><span class="line">           mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">           scheduleTraversals();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>　　绘制完添加到window：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                            getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                            mAttachInfo.mOutsets, mInputChannel);</span><br></pre></td></tr></table></figure></p><p>　　mWindowSession 的类型是 IWindowSession，它是一个 Binder 对象，真正的实现类是 Session，这也就是之前提到的 IPC 调用的位置。在 Session 内部会通过 WindowManagerService 来实现 Window 的添加，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addToDisplay</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams, attrs, <span class="keyword">int</span> viewVisibility, </span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> displayId, Rect outContentInsets, InputChannel outInputChannel)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> mService.addWindow(<span class="keyword">this</span>, window, seq, attrs, viewVisibility, displayId, outContentInsets, outInputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　终于，Window 的添加请求移交给 WindowManagerService 手上了，在 WindowManagerService 内部会为每一个应用保留一个单独的 Session，具体 Window 在 WindowManagerService 内部是怎么添加的，就不对其进一步的分析，因为到此为止我们对 Window 的添加这一从应用层到 Framework 的流程已经清楚了。<br>理解了 Window 的添加过程，Window 的删除过程和更新过程都是类似的，也就容易理解了，它们最终都会通过一个 IPC 过程将操作移交给 WindowManagerService 这个位于 Framework 层的窗口管理服务来处理。</p><h3 id="WindowManagerService"><a href="#WindowManagerService" class="headerlink" title="WindowManagerService"></a>WindowManagerService</h3><p>　　WindowManagerService 就是位于 Framework 层的窗口管理服务，它的职责就是管理系统中的所有窗口。窗口的本质是什么呢？其实就是一块显示区域，在 Android 中就是绘制的画布：Surface，当一块 Surface 显示在屏幕上时，就是用户所看到的窗口了。WindowManagerService 添加一个窗口的过程，其实就是 WindowManagerService 为其分配一块 Surface 的过程，一块块的 Surface 在 WindowManagerService 的管理下有序的排列在屏幕上，Android 才得以呈现出多姿多彩的界面。<br>　　一般的开发过程中，我们操作的是 UI 框架层，对 Window 的操作通过 WindowManager 即可完成，而 WindowManagerService 作为系统级服务运行在一个单独的进程，所以 WindowManager 和 WindowManagerService 的交互是一个 IPC 过程。</p><h3 id="Window的创建过程"><a href="#Window的创建过程" class="headerlink" title="Window的创建过程"></a>Window的创建过程</h3><p>　　View 是 Android 中的视图的呈现方式，但是 View 不能单独存在，它必须附着在 Window 这个抽象的概念上面，因此有视图的地方就有 Window。哪些地方有视图呢？Android 可以提供视图的地方有 Activity、Dialog、Toast，除此之外，还有一些依托 Window 而实现的视图，比如 PopUpWindow（自定义弹出窗口）、菜单，它们也是视图，有视图的地方就有 Window，因此 Activity、Dialog、Toast 等视图都对应着一个 Window。<br>下面分别分析 Activity、Dialog的 Window 创建过程。</p><h4 id="Activity的Window创建过程"><a href="#Activity的Window创建过程" class="headerlink" title="Activity的Window创建过程"></a>Activity的Window创建过程</h4><p>　　在了解了 Window 的概念及意义后，我们自然就清楚 Activity 的 Window 创建时机，Window 本质就是一块显示区域，所以关于 Activity 的 Window 创建应该发生在 Activity 的启动过程，Activity 的启动过程很复杂，最终会由 ActivityThread 中的 performLaunchActivity() 来完成整个启动过程，在这个方法内部会通过类加载器创建 Activity 的实例对象，并调用其 attach 方法为其关联运行过程中所依赖的一系列上下文环境变量。<br>　　Activity 的 Window 创建就发生在 attach 方法里，系统会创建 Activity 所属的 Window 对象并为其设置回调接口，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window);</span><br><span class="line">        mWindow.setWindowControllerCallback(<span class="keyword">this</span>);</span><br><span class="line">        mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">        mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p><p>　　可以看到， Window 对象的创建是通过 PolicyManager 的 makeNewWindow 方法实现的，由于 Activity 实现了 Window 的 Callback 接口，因此当 Window 接受到外界的状态改变时就会回调 Activity 的方法。Callback 接口中的方法很多，有几个是我们非常熟悉的，如 onAttachedToWindow、onDetachedFromWindow、dispatchTouchEvent 等等。<br>可以看出，Window 的具体实现类的确是 PhoneWindow。到这里 Window 以及创建完成了，下面分析 Activity 的视图是怎么附属到 Window 上的，而 Activity 的视图由 setContentView 提供，所以从 setContentView 入手，它的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        getWindow().setContentView(view, params);</span><br><span class="line">        initWindowDecorActionBar();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>　　可以看到，Activity 将具体实现交给了 Window，而 Window 的具体实现是 PhoneWindow，所以只需要看 PhoneWindow 的相关逻辑即可，它的处理步骤如下：<br>　　(1)、如果没有 DecorView 就创建一个<br>　　DecorView 是 Activity 中的顶级 View，是一个 FrameLayout，一般来说它的内部包含标题栏和内容栏，但是这个会随着主题的变化而改变，不管怎么样，内容栏是一定存在的，并且有固定的 id：”android.R.id.content”，在 PhoneWindow 中，通过 generateDecor 方法创建 DecorView，通过 generateLayout 初始化主题有关布局。<br>　　(2)、将 View 添加到 DecorView 的 mContentParent 中<br>　　这一步较为简单，直接将 Activity 的视图添加到 DecorView 的 mContentParent 中即可，由此可以理解 Activity 的 setContentView 这个方法的来历了，为什么不叫 setView 呢？因为 Activity 的布局文件只是被添加到 DecorView 的 mContentParent 中，因此叫 setContentView 更加具体准确。<br>　　(3)、回调 Activity 的 onContentChanged 方法通知 Activity 视图已经发生改变<br>　　前面分析到 Activity 实现了 Window 的 Callback 接口，这里当 Activity 的视图已经被添加到 DecorView 的 mContentParent 中了，需要通知 Activity，使其方便做相关的处理。<br>　　经过上面的三个步骤，DecorView 已经被创建并初始化完毕，Activity 的布局文件也已经成功添加到了 DecorView 的 mContentParent 中，但是这个时候 DecorView 还没有被 WindowManager 正式添加到 Window 中。在 　　ActivityThread 的 handleResumeActivity 方法中，首先会调用 Acitivy 的 onResume 方法，接着会调用 Acitivy 的 makeVisible() 方法，正是在 makeVisible 方法中，DecorView 才真正的完成了显示过程，到这里 Activity 的视图才能被用户看到，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">        ViewManager wm = getWindowManager();</span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dialog的Window创建过程"><a href="#Dialog的Window创建过程" class="headerlink" title="Dialog的Window创建过程"></a>Dialog的Window创建过程</h4><p>　　Dialog 的 Window 的创建过程与 Activity 类似，步骤如下：<br>　　(1)、创建 Window<br>　　Dialog 中 Window 同样是通过 PolicyManager 的 makeNewWindow 方法来完成的，创建后的对象也是 PhoneWindow。<br>　　(2)、初始化 DecorView 并将 Dialog 的视图添加到 DecorView 中<br>　　这个过程也和 Activity 类似，都是通过 Window 去添加指定布局文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the screen content to an explicit view.  This view is placed</span></span><br><span class="line"><span class="comment"> * directly into the screen's view hierarchy.  It can itself be a complex</span></span><br><span class="line"><span class="comment"> * view hierarchy.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> view The desired content to display.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params Layout parameters for the view.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@NonNull View view, @Nullable ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    mWindow.setContentView(view, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　在 Dialog 的 show 方法中，会通过 WindowManager 将 DecorView 添加到 Window 中，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Window对象创建DecorView</span></span><br><span class="line">mDecor = mWindow.getDecorView();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//WindowManager将DecorView显示出来</span></span><br><span class="line">mWindowManager.addView(mDecor, l);</span><br><span class="line">mShowing = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></p><p>　　从上面三个步骤可以发现，Dialog 的 Window 创建过程和 Activity 创建过程很类似，当 Dialog 关闭时，它会通过 WindowManager 来移除 DecorView。普通的 Dialog 必须采用 Activity 的 Context，如果采用 Application 的 Context 就会报错。这是因为没有应用 token 导致的，而应用 token 一般只有 Activity 拥有，另外，系统 Window 比较特殊，可以不需要 token。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于MaterialDesign的GitHub客户端</title>
      <link href="/2016/10/06/android/%E5%9F%BA%E4%BA%8EMaterialDesign%E7%9A%84GitHub%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>/2016/10/06/android/%E5%9F%BA%E4%BA%8EMaterialDesign%E7%9A%84GitHub%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      <content type="html"><![CDATA[<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a><strong>Github</strong></h1><p><img src="https://raw.githubusercontent.com/seasonfif/github/master/icon/icon_192.png" alt="icon"></p><p>Github是专为github精心打造的一款Android客户端，该客户端功能强大，包含常用的github浏览以及部分操作功能；界面绚丽，适配Material Design；操作简便，可以说是为githuber们量身而作的口袋神器！</p><hr><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a><strong>效果图</strong></h2><p><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/main_nav.png" alt="main_nav"></p><p><em>功能Tab选择界面</em></p><p><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/main_explore.png" alt="main_explore"></p><p><em>Explore界面</em></p><p>除此以外Github还支持夜间模式，让你的夜间浏览更舒心。</p><p><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/night_theme/main_nav_n.png" alt="main_nav_n"><br><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/night_theme/main_exlpore_n.png" alt="main_exlpore_n"></p><p>怎么样！看到这里你有没有想要上手试一试他的冲动呢？别着急，我们接着往下看。</p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a><strong>功能介绍</strong></h2><p>常用的github浏览功能以及部分操作功能，包括:</p><ol><li>启动的默认Tab支持自定义（Settings里面设置）</li><li>Explore，支持仓库和用户的搜索；支持个人喜好编程语言的设定（Settings里面设置）</li><li>Event，支持动态浏览以及相关用户和仓库的快速链接</li><li>Repository，浏览名下仓库（仓库详情页），支持预览详情，fork、star、watch和代码等资源（支持分支选择）的浏览以及删除仓库</li><li>Follow， 支持查看followings和followers；个人详情页里面还支持follow与unfollow</li><li>个人详情页，以下单独介绍</li><li>仓库详情页，以下单独介绍</li><li>Starred，浏览名下已经star的仓库</li><li>Issues，浏览相关的issues，支持新建issue，查看issue详情</li><li>Issues详情页支持增加评论以及评论的删除</li><li>Gists，浏览名下的gists，支持gists删除、评论，以及查看gists文件等</li><li>Settings，设置启动Tab、设置喜好语言、切换夜间模式、分享、清除缓存等</li><li>About， 软件相关信息、项目的github主页、商业合作、用户反馈意见软件更新，支持全量更新和差量更新</li><li>源代码里面的所有文件均支持缓存，第二次加载不耗费流量，Setting里面有删除缓存以节省存储空间</li></ol><h3 id="个人详情页"><a href="#个人详情页" class="headerlink" title="个人详情页"></a>个人详情页</h3><p>承载用户所有信息的展示以及操作平台</p><p><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/userinfo1.png" alt="userinfo1"><br><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/userinfo2.png" alt="userinfo2"> </p><h3 id="仓库详情页"><a href="#仓库详情页" class="headerlink" title="仓库详情页"></a>仓库详情页</h3><p>承载仓库所有信息的展示以及操作平台</p><p><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/repoinfo1.png" alt="repoinfo1"><br><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/repoinfo2.png" alt="repoinfo2"><br><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/repoinfo3.png" alt="repoinfo3"></p><h3 id="源码查看"><a href="#源码查看" class="headerlink" title="源码查看"></a>源码查看</h3><p>承载源码文件所有信息的展示以及操作平台</p><p><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/code1.png" alt="code1"><br><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/code2.png" alt="code2"><br><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/code_readme.png" alt="code_readme"><br><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/night_theme/code_n.png" alt="code_n"></p><p>看到这里相信你已经迫不及待想拥有它了！这就为客官奉上下载地址。</p><h2 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a><strong>下载链接</strong></h2><p>点击以下链接即可下载安装，或者在其对应的应用商店搜索<code>github</code>下载安装</p><blockquote><ul><li><a href="https://raw.githubusercontent.com/seasonfif/github/master/apk/github_release.apk" target="_blank" rel="noopener">Git Download</a></li><li><a href="http://shouji.baidu.com/software/10131158.html" target="_blank" rel="noopener">百度应用商店</a></li><li><a href="http://sj.qq.com/myapp/detail.htm?apkName=com.seasonfif.github" target="_blank" rel="noopener">腾讯应用商店</a></li><li><a href="http://zhushou.360.cn/detail/index/soft_id/3522595?recrefer=SE_D_github" target="_blank" rel="noopener">360应用商店</a></li></ul></blockquote><h2 id="建议与bug反馈"><a href="#建议与bug反馈" class="headerlink" title="建议与bug反馈"></a><strong>建议与bug反馈</strong></h2><p>如果您对软件有什么建议或是在使用过程中发现bug可以通过以下途径反馈：</p><blockquote><ul><li>软件About的<code>Feedback</code>途径</li><li>项目主页中新建<a href="https://github.com/seasonfif/github/issues/new" target="_blank" rel="noopener">issue</a></li><li>新浪微博<a href="http://weibo.com/seasonfif" target="_blank" rel="noopener">@seasonfif</a></li><li>邮件到<a href="mailto:seasonfif@gmail.com" target="_blank" rel="noopener">seasonfif@gmail.com</a></li></ul></blockquote><p>期待与诸位的交流。</p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a><strong>鸣谢</strong></h2><p>项目使用了优秀的第三方开源库，在此对以下作品表示致谢。</p><ol><li><a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a>  Type-safe HTTP client for Android and Java by Square, Inc.</li><li><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a>   RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.</li><li><a href="https://github.com/square/picasso" target="_blank" rel="noopener">picasso</a>   A powerful image downloading and caching library for Android</li><li><a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">leakcanary</a>   A memory leak detection library for Android and Java.</li><li><a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">butterknife</a>   Bind Android views and callbacks to fields and methods.</li><li><a href="https://github.com/futuresimple/android-floating-action-button" target="_blank" rel="noopener">android-floating-action-button</a>   android-floating-action-button</li><li><a href="https://github.com/Frank-Zhu/PullZoomView" target="_blank" rel="noopener">PullZoomView</a>   An Android custom ListView and ScrollView with pull to zoom-in.</li><li><a href="https://github.com/mukeshsolanki/MarkdownView-Android" target="_blank" rel="noopener">MarkdownView-Android</a>   MarkdownView is an Android webview with the capability of loading Markdown text or file and display it as HTML, it extends Android webview.</li><li><a href="https://github.com/pnikosis/materialish-progress" target="_blank" rel="noopener">Material-ish Progress</a>   A material style progress wheel compatible with 2.3</li></ol><p>再次感谢！</p><h2 id="商务合作"><a href="#商务合作" class="headerlink" title="商务合作"></a><strong>商务合作</strong></h2><p>邮件<a href="mailto:seasonfif@gmail.com" target="_blank" rel="noopener">seasonfif@gmail.com</a><br>诚挚希望与您合作</p><hr>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个轻量级的基于卡片模板的自动化布局框架</title>
      <link href="/2016/09/21/android/%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E5%9F%BA%E4%BA%8E%E5%8D%A1%E7%89%87%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E5%B1%80%E6%A1%86%E6%9E%B6/"/>
      <url>/2016/09/21/android/%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E5%9F%BA%E4%BA%8E%E5%8D%A1%E7%89%87%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E5%B1%80%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<h1 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h1><p>一个轻量级的基于卡片模板的自动化布局框架</p><p><strong>关于我</strong></p><blockquote><p>我的其他项目：<br><a href="https://github.com/seasonfif/github" target="_blank" rel="noopener">github第三方Android客户端（适配Material Design）</a></p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h2><p>该框架依据View叠加的树形结构，通过与之对应的树形json快捷简便的动态控制Card的布局结构。实现原理如下：</p><ol><li>解析服务端下发的树形json数据（节点类型需实现<code>INode</code>接口）；</li><li>布局引擎深度遍历树的节点，根据节点类型生成（生成方法为<code>IFactory</code>的实现类）各节点对应的Card（Card为使用时实现<code>ICard</code>接口的View或ViewGroup）；</li><li>将同一深度的兄弟节点依据权重（权重为使用时<code>INode</code>接口获得）排序；</li><li>递归遍历非叶子节点，将Card根据嵌套类型（<code>NestMode</code>）回调给具体的Card实现布局嵌套；</li><li>递归完成之后，布局引擎将返回根据树形json布局完成的View。</li></ol><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a><strong>特性</strong></h2><p>该框架具有强大的Card布局功能，其主要功能特性如下:</p><ol><li>框架以Card为最小单位布局（一个Card就是实现ICard接口的自定义View或ViewGroup），不关心Card内部的布局结构</li><li>框架解析服务端数据从而生成View，因此可实现真正的动态化布局</li><li>框架支持Card的自动嵌套（比如LinearLayout的VERTICAL与HORIZONTAL）和手动嵌套（预先占坑ViewGroup）</li><li>框架支持树形节点的Card数据部分为统一数据Bean或独自数据bean（通过json字符串支持，框架提供的<code>Node</code>节点模型即为此种类型）</li><li>框架支持以注解（<code>CardModel</code>）形式设置独自数据bean的类型</li><li>框架支持的独自数据bean的类型可以为普通对象（对应json对象）和列表对象（对应json数组）</li></ol><h2 id="设置Gradle依赖"><a href="#设置Gradle依赖" class="headerlink" title="设置Gradle依赖"></a><strong>设置Gradle依赖</strong></h2><ol><li><p>Add the JitPack repository to your build file</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ...</span><br><span class="line">        maven &#123; url &apos;https://jitpack.io&apos; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Add the dependency</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        compile &apos;com.github.seasonfif:matrix:1.0.5&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h2><p>框架使用特别简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 应用开始执行的地方使用IFactory对象初始化Matrix</span><br><span class="line">   Matrix.init(<span class="keyword">new</span> CardFactory());</span><br><span class="line">   </span><br><span class="line"><span class="number">2</span>. 需要动态生成View的地方（node为INode对象）</span><br><span class="line">   View view = Matrix.getEngine().produce(MainActivity.<span class="keyword">this</span>, node);</span><br><span class="line">   setContentView(view);</span><br></pre></td></tr></table></figure><p>除以上的框架调用之外，使用时应该优先完成以下的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 一个实现INode接口的节点数据模型（如果计划使用json字符串作为Card数据模型的下发方式则可以使用框架提供的Node对象）</span><br><span class="line">   </span><br><span class="line">2. 一个实现IFactory抽象工厂接口的Card工厂类</span><br><span class="line"></span><br><span class="line">3. 至少有一个实现ICard接口的卡片以及与之对应的卡片数据模型（如果为独自的Card数据模型需要在ICard实现类加上类注解@CardModel(xxx.class)）</span><br><span class="line"></span><br><span class="line">总而言之就是事先准备好项目需要动态布局各种的Card</span><br></pre></td></tr></table></figure></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>提供代码片段以帮助大家更快地理解其使用方法</p><p><strong>1. 一个实现INode接口的节点数据模型</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">以框架中的实现为例</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">INode</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">  <span class="keyword">private</span> String des;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">  <span class="keyword">private</span> String data;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Node&gt; children;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> des;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> List&lt;? extends INode&gt; getChildren() &#123;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2. 一个实现IFactory抽象工厂接口的Card工厂类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CardFactory</span> <span class="keyword">implements</span> <span class="title">ICardFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_CONTAINER_CARD = <span class="number">0x0000</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_ITEM_CARD = <span class="number">0x0001</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ICard <span class="title">createCard</span><span class="params">(Context context, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    ICard card;</span><br><span class="line">    <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">      <span class="keyword">case</span> TYPE_CONTAINER_CARD:</span><br><span class="line">        card = <span class="keyword">new</span> ContainerCard(context);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> TYPE_ITEM_CARD:</span><br><span class="line">        card = <span class="keyword">new</span> ItemCard(context);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        card = <span class="keyword">new</span> ContainerCard(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> card;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 一个实现ICard接口的卡片以及与之对应的卡片数据模型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">卡片实现</span><br><span class="line"><span class="meta">@CardModel</span>(TextCardBean.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextCard</span> <span class="keyword">extends</span> <span class="title">TextView</span> <span class="keyword">implements</span> <span class="title">ICard</span>&lt;<span class="title">TextCardBean</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TextCard</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TextCard</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TextCard</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setBackgroundColor(Color.parseColor(<span class="string">"#9ccc65"</span>));</span><br><span class="line">    setTextColor(Color.WHITE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNestMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> NestMode.NONE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(TextCardBean data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span>)&#123;</span><br><span class="line">      setText(data.text);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCard</span><span class="params">(<span class="keyword">int</span> index, ICard card)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">卡片对应的数据Bean</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextCardBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h2><ol><li>Card缓存机制（由于View体系中同一View对象不能嵌套，因此将缓存Card添加到同为自己的父布局时会异常），如果有好的实现思路可以提issue </li></ol><h2 id="第三方"><a href="#第三方" class="headerlink" title="第三方"></a><strong>第三方</strong></h2><p>框架使用<a href="https://github.com/google/gson" target="_blank" rel="noopener">Gson</a> （A Java serialization/deserialization library to convert Java Objects into JSON and back）作为json字符串转化为数据对象的工具</p><h1 id="开源许可"><a href="#开源许可" class="headerlink" title="开源许可"></a>开源许可</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copyright 2017 seasonfif.</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">you may not use this file except in compliance with the License.</span><br><span class="line">You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">  http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">    </span><br><span class="line">Unless required by applicable law or agreed to in writing, software</span><br><span class="line">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">See the License for the specific language governing permissions and</span><br><span class="line">limitations under the License.</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Gradle插件编写</title>
      <link href="/2016/06/07/gradle/gradle%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/"/>
      <url>/2016/06/07/gradle/gradle%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Gradle </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Gradle高级使用</title>
      <link href="/2016/05/30/gradle/Gradle%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/05/30/gradle/Gradle%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="Gradle简介"><a href="#Gradle简介" class="headerlink" title="Gradle简介"></a>Gradle简介</h3><p>　　Gradle傲居构建江湖盟主一位已有好几载，Google Android Studio的推出又将之引入到Android的世界，让我们有幸认识到他的强大。博主在使用之后对他的称赞也是不绝于口，那现在就让我带领你认识这个被称为“神器”的构建工具吧。</p><h3 id="Gradle是什么"><a href="#Gradle是什么" class="headerlink" title="Gradle是什么"></a>Gradle是什么</h3><p>　　Gradle跟ant/maven一样，是一种依赖管理/自动化构建工具。但是跟ant/maven不一样，它并没有使用xml语言，而是采用了Groovy语言，这使得它更加简洁、灵活，更加强大的是，gradle完全兼容maven和ivy。官方称它是 java ( JVM ) 世界中构建技术的一个飞跃。</p><h3 id="Gradle的特点"><a href="#Gradle的特点" class="headerlink" title="Gradle的特点"></a>Gradle的特点</h3><ol><li><p>声明式构建和合约构建<br>Gradle 的核心是基于 Groovy 的 领域特定语言 (DSL), 具有十分优秀的扩展性. Gradle 通过提供可以随意集成的声明式语言元素将声明性构建推到了一个新的高度. 这些元素也为 Java, Groovy, OSGi, Web 和Scala 等项目提供基于合约构建的支持. 而且, 这种声明式语言是可扩展的. 你可以添加自己的语言元素或加强现有的语言元素, 从而提供简洁, 易于维护和易于理解的构建.</p></li><li><p>基于依赖的编程语言<br>声明式语言位于通用任务图 ( general purpose task graph ) 的顶端，它可以被充分利用在你的构建中. 它具有强大的灵活性, 可以满足使用者对 Gradle 的一些特别的需求.</p></li><li><p>让构建结构化<br>Gradle 的易适应性和丰富性可让你在构建里直接套用通用的设计原则. 例如, 你可以非常容易地使用一些可重用的组件来构成你的构建. 但是不必要的间接内联内容是不合适的. 不要强行拆分已经结合在一起的部分 (例如, 在你的项目层次结构中). 避免使构建难以维护. 总之, 你可以创建一个结构良好，易于维护和易于理解的构建.</p></li><li><p>API深化<br>你会非常乐意在整个构建执行的生命周期中使用 Gradle, 因为Gradle 允许你管理和定制它的配置和执行行为.</p></li><li><p>Gradle 扩展<br>Gradle 扩展得非常好. 不管是简单的独立项目还是大型的多项目构建, 它都能显著的提高效率. 这是真正的结构构建. 顶尖水平的构建功能，还可以解决许多大公司碰到的构建 性能低下的问题.</p></li><li><p>多项目构建<br>Gradle 对多项目的支持是非常出色的. 项目依赖是很重要的部分. 它允许你模拟在多项目构建中项目的关系，这正是你所要关注的地方.Gradle 提供了局部构建的功能. 如果你构建一个单独的子项目, Gradle 会构建这个子项目依赖的所有子项目. 你也可以选择依赖于另一个特别的子项目重新构建这些子项目. 这样在一些大型项目里就可以节省非常多的时间.</p></li><li><p>多种方式来管理你的依赖<br>不同的团队有不同的管理外部依赖的方法. Gradle 对于任何管理策略都提供了合适的支持. 从远程 Maven 和 Ivy 库的依赖管理到本地文件系统的 jars 或者 dirs.</p></li><li><p>Gradle 是第一个构建整合工具<br>Ant 的 tasks是 Gradle 中很重要的部分, 更有趣是 Ant 的 projects 也是十分重要的部分. Gradle 可以直接引入Ant 项目, 并在运行时直接将 Ant targets 转换成 Gradle tasks. 你可以从 Gradle 中依赖它们, 并增强它们的功能, 甚至可以在 build.xml 文件中声明 Gradle tasks 的依赖. 并且properties, paths 等也可以通过同样的方法集成进来.Gradle 完全支持你已有的 Maven 或者 lvy 仓库来构造发布或者提取依赖. Gradle 也提供了一个转化器, 用来将 maven 的 pom.xml 文件转换成 Gradle 脚本. 在运行时引入 Maven 项目也会在稍后推出.</p></li><li><p>易于迁移<br>Gradle 可以兼容任何结构. 因此你可以直接在你的产品构建的分支上开发你的 Gradle 构建, 并且二者可以并行. 通常建议编写一些测试代码来确保它们的功能是相同的. 通过这种方式, 在迁移的时候就不会显得那么混乱和不可靠, 这是通过婴儿学步的方式来获得最佳的实践.</p></li><li><p>基于Groovy<br>Gradle 的构建脚本是通过 Groovy 编写的而不是 XML. 但是并不像其他方式, 这并不是为了简单的展示用动态语言编写的原始脚本有多么强大. 不然的话, 只会导致维护构建变得非常困难. Gradle 的整个设计是朝着一种语言的方向开发的, 并不是一种死板的框架. Groovy 就像胶水一样, 把你像实现的构想和抽象的 Gradle 粘在一起. Gradle提供了一些标准的构想, 但是他们并不享有任何形式的特权. 相比于其他声明式构建系统，这是一个比较突出的特点.</p></li><li><p>Gradle 包装器<br>Gradle 包装器允许你在没有安装 Gradle 的机器上运行 Gradle 构建. 在一些持续集成的服务器上, 这个功能将非常有用. 它同样也能降低使用一个开源项目的门槛, 也就是说构建它将会非常简单. 这个包装器对于公司来说也是很有吸引力的. 它并不需要为客户机提供相应的管理防范. 这种方式同样也能强制某一个版本 Gradle 的使用从而最小化某些支持问题.</p></li><li><p>免费和开源<br>Gradle 是一个开源项目, 遵循 ASL 许可.</p></li></ol><h3 id="Gradle与Maven的区别"><a href="#Gradle与Maven的区别" class="headerlink" title="Gradle与Maven的区别"></a>Gradle与Maven的区别</h3><p>　　Java世界中主要有三大构建工具：Ant、Maven和Gradle。经过几年的发展，Ant几乎销声匿迹、Maven也日薄西山，而Gradle的发展则如日中天。</p><h4 id="依赖管理系统"><a href="#依赖管理系统" class="headerlink" title="依赖管理系统"></a>依赖管理系统</h4><p>　　Maven为Java世界引入了一个新的依赖管理系统。<br>　　1. 在Java世界中，可以用groupId、artifactId、version组成的Coordination（坐标）唯一标识一个依赖。任何基于Maven构建的项目自身也必须定义这三项属性，生成的包可以是Jar包，也可以是war包或者ear包。一个典型的依赖引用如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line"> &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>　　从上面可以看出当引用一个依赖时，version可以省略掉，这样在获取依赖时会选择最新的版本。而存储这些组件的仓库有远程仓库和本地仓库之分。远程仓库可以使用世界公用的central仓库，也可以使用Apache Nexus自建私有仓库；本地仓库则在本地计算机上。通过Maven安装目录下的settings.xml文件可以配置本地仓库的路径，以及采用的远程仓库的地址。<br>　　Gradle在设计的时候基本沿用了Maven的这套依赖管理体系。不过它在引用依赖时还是进行了一些改进。首先引用依赖方面变得非常简洁。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line"> <span class="keyword">compile</span> <span class="string">'org.hibernate:hibernate-core:3.6.7.Final'</span></span><br><span class="line"> testCompile ‘junit:junit:<span class="number">4</span>.+<span class="string">'</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>　　2. Maven和Gradle对依赖项的scope有所不同。在Maven世界中，一个依赖项有6种scope，分别是complie(默认)、provided、runtime、test、system、import。而grade将其简化为了4种，compile、runtime、testCompile、testRuntime。那么如果想在gradle使用类似于provided的scope怎么办？别着急，由于gradle语言的强大表现力，我们可以轻松编写代码来实现类似于provided scope的概念（例如How to use provided scope for jar file in Gradle build?）。<br>　　3. Gradle支持动态的版本依赖。在版本号后面使用+号的方式可以实现动态的版本管理。如下所示：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line"> <span class="keyword">compile</span> ‘junit:junit:<span class="number">4</span>.+<span class="string">'</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>　　4. 在解决依赖冲突方面Gradle的实现机制更加明确。使用Maven和Gradle进行依赖管理时都采用的是传递性依赖；而如果多个依赖项指向同一个依赖项的不同版本时就会引起依赖冲突。而Maven处理这种依赖关系往往是噩梦一般的存在。而Gradle在解决依赖冲突方面相对来说比较明确.</p><h4 id="多模块构建"><a href="#多模块构建" class="headerlink" title="多模块构建"></a>多模块构建</h4><p>　　在SOA和微服务的浪潮下，将一个项目分解为多个模块已经是很通用的一种方式。在Maven中需要定义个parent POM作为一组module的聚合POM。在该POM中可以使用<modules>标签来定义一组子模块。parent POM不会有什么实际构建产出。而parent POM中的build配置以及依赖配置都会自动继承给子module。<br>　　而Gradle也支持多模块构建。而在parent的build.gradle中可以使用allprojects和subprojects代码块来分别定义里面的配置是应用于所有项目还是子项目。对于子模块的定义是放置在setttings.gradle文件中的。在gradle的设计当中，每个模块都是Project的对象实例。而在parent build.gradle中通过allprojects或subprojects可以对这些对象进行各种操作。这无疑比Maven要灵活的多。<br>比如在parent的build.gradle中有以下代码：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line"> <span class="keyword">task</span> hello &lt;&lt; &#123; <span class="keyword">task</span> -&gt; <span class="keyword">println</span> <span class="string">"I'm $task.project.name"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></modules></p><p>　　执行命令gradle -q hello会依次打印出父module以及各个submodule的项目名称。这种强大的能力能让gradle对各个模块具有更强的定制化。</p><h4 id="一致的项目结构"><a href="#一致的项目结构" class="headerlink" title="一致的项目结构"></a>一致的项目结构</h4><p>　　在Ant时代大家创建Java项目目录时比较随意，然后通过Ant配置指定哪些属于source，那些属于testSource等。而Maven在设计之初的理念就是Conversion over configuration（约定大于配置）。其制定了一套项目目录结构作为标准的Java项目结构。一个典型的Maven项目结构如下：<br><img src="https://raw.githubusercontent.com/seasonfif/picture/master/other/mulujiegou.png" alt="mulu"><br>　　Gradle也沿用了这一标准的目录结构。如果你在Gradle项目中使用了标准的Maven项目结构的话，那么在Gradle中也无需进行多余的配置,只需在文件中包含apply plugin:’java’,系统会自动识别source、resource、test srouce、 test resource等相应资源。不过Gradle作为JVM上的构建工具，也同时支持groovy、scala等源代码的构建，甚至支持Java、groovy、scala语言的混合构建。虽然Maven通过一些插件（比如maven-scala-plugin）也能达到相同目的，但配置方面显然Gradle要更优雅一些。</p><h4 id="一致的构建模型"><a href="#一致的构建模型" class="headerlink" title="一致的构建模型"></a>一致的构建模型</h4><p>　　为了解决Ant中对项目构建活动缺乏标准化的问题，Maven特意设置了标准的项目构建周期，其默认的构建周期如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;phases&gt;</span><br><span class="line"> &lt;phase&gt;validate&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;initialize&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;generate-sources&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;process-sources&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;generate-resources&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;process-resources&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;compile&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;process-classes&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;generate-test-sources&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;process-test-sources&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;generate-test-resources&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;process-test-resources&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;test-compile&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;process-test-classes&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;test&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;prepare-package&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;pre-integration-test&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;integration-test&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;post-integration-test&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;verify&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;install&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;deploy&lt;/phase&gt;</span><br><span class="line">&lt;/phases&gt;</span><br></pre></td></tr></table></figure></p><p>　　而这种构建周期也是Maven最为人诟病的地方。因为Maven将项目的构建周期限制的太死，你无法在构建周期中添加新的phase，只能将插件绑定到已有的phase上。而现在项目的构建过程变得越来越复杂，而且多样化，显然Maven对这种复杂度缺少足够的应变能力。比如你想在项目构建过程中进行一项压缩所有javascript的任务，那么就要绑定到Maven的现有的某个phase上，而显然貌似放在哪个phase都不太合适。而且这些phase都是串行的，整个执行下来是一条线，这也限制了Maven的构建效率。而Gradle在构建模型上则非常灵活。在Gradle世界里可以轻松创建一个task，并随时通过depends语法建立与已有task的依赖关系。甚至对于Java项目的构建来说，Gradle是通过名为java的插件来包含了一个对Java项目的构建周期，这等于Gradle本身直接与项目构建周期是解耦的。</p><h4 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h4><p>　　Maven和Gradle设计时都采用了插件机制。但显然Gradle更胜一筹。主要原因在于Maven是基于XML进行配置。所以其配置语法太受限于XML。即使实现很小的功能都需要设计一个插件，建立其与XML配置的关联。比如想在Maven中执行一条shell命令，其配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line"> &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line"> &lt;executions&gt;</span><br><span class="line"> &lt;execution&gt;</span><br><span class="line"> &lt;id&gt;drop DB =&gt; db_name&lt;/id&gt;</span><br><span class="line"> &lt;phase&gt;pre-integration-test&lt;/phase&gt;</span><br><span class="line"> &lt;goals&gt;</span><br><span class="line"> &lt;goal&gt;exec&lt;/goal&gt;</span><br><span class="line"> &lt;/goals&gt;</span><br><span class="line"> &lt;configuration&gt;</span><br><span class="line"> &lt;executable&gt;curl&lt;/executable&gt;</span><br><span class="line"> &lt;arguments&gt;</span><br><span class="line"> &lt;argument&gt;-s&lt;/argument&gt;</span><br><span class="line"> &lt;argument&gt;-S&lt;/argument&gt;</span><br><span class="line"> &lt;argument&gt;-X&lt;/argument&gt;</span><br><span class="line"> &lt;argument&gt;DELETE&lt;/argument&gt;</span><br><span class="line"> &lt;argument&gt;http://$&#123;db.server&#125;:$&#123;db.port&#125;/db_name&lt;/argument&gt;</span><br><span class="line"> &lt;/arguments&gt;</span><br><span class="line"> &lt;/configuration&gt;</span><br><span class="line"> &lt;/execution&gt;</span><br><span class="line"> &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure></p><p>　　而在Gradle中则一切变得非常简单。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> dropDB(type: Exec) &#123;</span><br><span class="line"> commandLine ‘curl’,’-s’,’s’,’-x’,’<span class="keyword">DELETE</span>’,<span class="string">"http://$&#123;db.server&#125;:&#123;db.port&#125;/db_name"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="为什使用Gradle"><a href="#为什使用Gradle" class="headerlink" title="为什使用Gradle"></a>为什使用Gradle</h3><p>　　在脚本构建时, 一个内部的 DSL（基于一个动态语言）相对于 XML 的优势是巨大的. 有这么多的动态语言, 为什么选择 Groovy? 答案在于 Gradle 的运行环境. 虽然 Gradle 以一个通用构建工具为核心, 但是它的重点是Java项目. 在这样的项目中, 显然团队每个成员都对 Java 非常熟悉. 而且构建应尽可能对所有团队成员都是透明的,所以选择了 Groovy.<br>　　那么，为什么不直接使用 Java 作为构建脚本的语言. 这是一个很好的问题. 对于你的团队, 它要有最高的透明度和最低的学习曲线, 也就是说容易掌握. 但由于 Java 的限制, 这样的构建语言不会那么完美和强大. 而像 Python，Groovy 或 Ruby 语言用来作为构建语言会更好. 之所以使用 Groovy 是因为它给 Java 开发人员提供了迄今为止最大的透明度. 其基本的符号和类型与 Java 是一样的，其封装结构和许多其他的地方也是如此. Groovy 在这基础上提供了更多的功能, 而且与 java 有共同的基础。</p>]]></content>
      
      <categories>
          
          <category> Gradle </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Gradle初级使用</title>
      <link href="/2016/05/21/gradle/Gradle%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/05/21/gradle/Gradle%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>　　Gradle的超强构建能力在Android Studio中可以说表现的淋漓尽致。下面我就将如何上手Gradle展开讨论。</p><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>　　需要明确gradle跟maven一样，也有一个配置文件，maven里面是叫pom.xml，而在gradle中是叫build.gradle。Android Studio中的android项目通常至少包含两个build.gradle文件，一个是project范围的，另一个是module范围的，由于一个project可以有多个module，所以每个module下都会对应一个build.gradle。这么说有点抽象，看下面这个图：<br><img src="https://raw.githubusercontent.com/seasonfif/picture/master/other/gradle-setup.png" alt="setup"><br>　　这是一个android工程的project视图，上面那个是module下的build.gradle文件。下面那个是project下的build.gradle文件。这两个文件是有区别的，project下的build.gradle是基于整个project的配置，而module下的build.gradle是每个模块自己的配置。</p><h4 id="认识build-gradle"><a href="#认识build-gradle" class="headerlink" title="认识build.gradle"></a>认识build.gradle</h4><p>　　下面看下这两个build.gradle里面的内容：<br>　　1. project里面的build.gradle:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="comment">//构建过程依赖的仓库</span></span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建过程需要依赖的库</span></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">     <span class="comment">//下面声明的是gradle插件的版本</span></span><br><span class="line">     <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:1.1.0'</span></span><br><span class="line">     <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">     <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里面配置整个项目依赖的仓库,这样每个module就不用配置仓库了</span></span><br><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">     <span class="keyword">repositories</span> &#123;</span><br><span class="line">          jcenter()</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这里的仓库repositories需要声明两次，这其实是由于它们作用不同，buildscript中的仓库是gradle脚本自身需要的资源，而allprojects下的仓库是项目所有模块需要的资源。所以配配的时候要注意一下。<br>　　2. module里面的build.gradle:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明插件，这是一个android程序，如果是android库，应该是com.android.library</span></span><br><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line">android &#123;</span><br><span class="line">     <span class="comment">//安卓构建过程需要配置的参数</span></span><br><span class="line">     compileSdkVersion <span class="number">21</span><span class="comment">//编译版本</span></span><br><span class="line">     buildToolsVersion <span class="string">"21.1.2"</span><span class="comment">//buildtool版本</span></span><br><span class="line">     defaultConfig &#123;<span class="comment">//默认配置，会同时应用到debug和release版本上</span></span><br><span class="line">     applicationId <span class="string">"com.taobao.startupanim"</span><span class="comment">//包名</span></span><br><span class="line">     minSdkVersion <span class="number">15</span></span><br><span class="line">     targetSdkVersion <span class="number">21</span></span><br><span class="line">     versionCode <span class="number">1</span></span><br><span class="line">     versionName <span class="string">"1.0"</span></span><br><span class="line">&#125;</span><br><span class="line"> buildTypes &#123;</span><br><span class="line">     <span class="comment">//这里面可以配置debug和release版本的一些参数，比如混淆、签名配置等</span></span><br><span class="line">     release &#123;</span><br><span class="line">         <span class="comment">//release版本</span></span><br><span class="line">         minifyEnabled <span class="keyword">false</span><span class="comment">//是否开启混淆</span></span><br><span class="line">         proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span><span class="comment">//混淆文件位置</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">     <span class="comment">//模块依赖</span></span><br><span class="line">     <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])<span class="comment">//依赖libs目录下所有jar包</span></span><br><span class="line">     <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:21.0.3'</span><span class="comment">//依赖appcompat库</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　defaultConfig中是一些基本配置，它会同时应用到debug/release版本上，下面列举了所有可配项及对应的值：<br><img src="https://raw.githubusercontent.com/seasonfif/picture/master/other/defaultConfig.png" alt="defaultConfig"><br>　　buildTypes结点很重要，这里可以配置构建的版本的一些参数，默认有两个构建版本release/debug，当然你可以自定义一个构建版本，比如叫develop,然后通过gradlew assembleDevelop就可以生成对应的apk了。<br>　　buildTypes里还有很多可配置项，下面列举了所有可配项以及debug/release版本的默认值：<br><img src="https://raw.githubusercontent.com/seasonfif/picture/master/other/buildTypes.png" alt="buildTypes"></p><h4 id="认识gradle-properties"><a href="#认识gradle-properties" class="headerlink" title="认识gradle.properties"></a>认识gradle.properties</h4><p>　　gradle相关的配置文件-gradle.properties：<br>　　从名字上就知道它是一个配置文件，没错，这里面可以定义一些常量供build.gradle使用，比如可以配置签名相关信息如keystore位置，密码，keyalias等。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">Project</span>-wide Gradle settings.</span><br><span class="line"></span><br><span class="line"># IDE (e.g. Android Studio) users:</span><br><span class="line"># Gradle settings configured through the IDE *will override*</span><br><span class="line"># <span class="keyword">any</span> settings specified in <span class="keyword">this</span> <span class="keyword">file</span>.</span><br><span class="line"></span><br><span class="line"># <span class="keyword">For</span> more details on how to configure your build environment visit</span><br><span class="line"># http:<span class="comment">//www.gradle.org/docs/current/userguide/build_environment.html</span></span><br><span class="line"></span><br><span class="line"># Specifies the JVM arguments used <span class="keyword">for</span> the daemon process.</span><br><span class="line"># The setting is particularly useful <span class="keyword">for</span> tweaking memory settings.</span><br><span class="line"># <span class="keyword">Default</span> value: -Xmx10248m -XX:MaxPermSize=<span class="number">256</span>m</span><br><span class="line">#org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=<span class="number">512</span>m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"># When configured, Gradle will run in incubating parallel mode.</span><br><span class="line"># <span class="keyword">This</span> option should only be used with decoupled projects. More details, visit</span><br><span class="line"># http:<span class="comment">//www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects</span></span><br><span class="line">org.gradle.parallel=<span class="keyword">true</span></span><br><span class="line">org.gradle.daemon=<span class="keyword">true</span></span><br><span class="line">org.gradle.configureondemand=<span class="keyword">true</span></span><br></pre></td></tr></table></figure></p><h4 id="认识settings-gradle"><a href="#认识settings-gradle" class="headerlink" title="认识settings.gradle"></a>认识settings.gradle</h4><p>　　模块配置文件settings.gradle：<br>　　这个文件是用来配置多模块的，比如你的项目有两个模块module-a,module-b,那么你就需要在这个文件中进行配置，格式如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">':module-a'</span>,<span class="string">':module-b'</span></span><br></pre></td></tr></table></figure></p><h4 id="gradle文件夹"><a href="#gradle文件夹" class="headerlink" title="gradle文件夹"></a>gradle文件夹</h4><p>　　gradle文件夹里面有两个文件，gradle-wrapper.jar和gradle-wrapper.properties,它们就是gradle wrapper。gradle项目都会有，你可以通过命令gradle init来创建它们（前提是本地安装了gradle并且配置到了环境变量中）。<br>　　gradle-wrapper.properties里面配置了gradle版本，具体内容如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#Mon Oct <span class="number">30</span> <span class="number">18</span>:<span class="number">06</span>:<span class="number">12</span> CST <span class="number">2017</span></span><br><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper<span class="regexp">/dists</span></span><br><span class="line"><span class="regexp">zipStoreBase=GRADLE_USER_HOME</span></span><br><span class="line"><span class="regexp">zipStorePath=wrapper/</span>dists</span><br><span class="line">distributionUrl=https\:<span class="comment">//services.gradle.org/distributions/gradle-4.1-all.zip</span></span><br></pre></td></tr></table></figure></p><h4 id="gradlew和gradlew-bat"><a href="#gradlew和gradlew-bat" class="headerlink" title="gradlew和gradlew.bat"></a>gradlew和gradlew.bat</h4><p>　　这分别是linux下的shell脚本和windows下的批处理文件，它们的作用是根据gradle-wrapper.properties文件中的distributionUrl下载对应的gradle版本。这样就可以保证在不同的环境下构建时都是使用的统一版本的gradle，即使该环境没有安装gradle也可以，因为gradle wrapper会自动下载对应的gradle版本。<br>　　gradlew的用法跟gradle一模一样，比如执行构建gradle build命令，你可以用gradlew build。gradlew即gradle wrapper的缩写。</p><h4 id="gradle仓库"><a href="#gradle仓库" class="headerlink" title="gradle仓库"></a>gradle仓库</h4><p>gradle有三种仓库，maven仓库，ivy仓库以及flat本地仓库。声明方式如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">maven&#123;</span><br><span class="line">      url <span class="string">"..."</span></span><br><span class="line">&#125;</span><br><span class="line">ivy&#123;</span><br><span class="line">      url <span class="string">"..."</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">flatDir</span>&#123;</span><br><span class="line">      dirs <span class="string">'xxx'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>单独的引入一个本地仓库可以这样写<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">  <span class="keyword">flatDir</span> &#123;</span><br><span class="line">    dirs <span class="string">'../im/libs2'</span></span><br><span class="line">    dirs <span class="string">'../lib/libs2'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有一些仓库提供了别名，可直接使用：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repositories</span>&#123;</span><br><span class="line">     mavenCentral()</span><br><span class="line">     jcenter()</span><br><span class="line">     mavenLocal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="gradle任务"><a href="#gradle任务" class="headerlink" title="gradle任务"></a>gradle任务</h4><p>gradle中有一个核心概念叫任务，跟maven中的插件目标类似。<br>gradle的android插件提供了四个顶级任务<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assemble 构建项目输出</span><br><span class="line">check 运行检测和测试任务</span><br><span class="line">build 运行assemble和check</span><br><span class="line">clean 清理输出任务</span><br></pre></td></tr></table></figure></p><p>执行任务可以通过gradle/gradlew+任务名称的方式执，执行一个顶级任务会同时执行与其依赖的任务，比如你执行<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew assemble</span><br></pre></td></tr></table></figure></p><p>它通常会执行:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gradlew assembleDebug</span><br><span class="line">gradlew assembleRelease</span><br></pre></td></tr></table></figure></p><p>这时会在你项目的build/outputs/apk或者build/outputs/aar目录生成输出文件<br><code>gradlew assemble</code>命令只能执行主module的编译任务，如果只想单独编译某一个module可以使用<code>-p</code>参数来指定：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew -p module-a assembleDebug</span><br></pre></td></tr></table></figure></p><p>可以通过：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew tasks</span><br></pre></td></tr></table></figure></p><p>列出所有可用的任务。在Android Studio中可以打开右侧gradle视图查看所有任务。</p><p>有一个命令可以很方便的列出工程的依赖关系：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle module-a:<span class="keyword">dependencies</span> --configuration <span class="keyword">compile</span></span><br></pre></td></tr></table></figure></p><p>这样就能知module-a编译的依赖项了。</p><h3 id="工程配置"><a href="#工程配置" class="headerlink" title="工程配置"></a>工程配置</h3><p>　　了解过gradle的基本配置之后，我们就可以来看看gradle在Android Studio的具体应用了。</p><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>　　下面的这份清单是一个比较详细的build.gradle配置文件，包含了buildType、flavor、定义资源目录、multiDex相关等细节。完全可以满足平常一般的使用需求<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//说明module的类型，com.android.application为程序，com.android.library为库</span></span><br><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="comment">//编译的SDK版本</span></span><br><span class="line">    compileSdkVersion <span class="number">22</span></span><br><span class="line">    <span class="comment">//编译的Tools版本</span></span><br><span class="line">    buildToolsVersion <span class="string">"22.0.1"</span></span><br><span class="line">    <span class="comment">//默认配置</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        <span class="comment">//应用程序的包名</span></span><br><span class="line">        applicationId <span class="string">"com.xxx.xxx"</span></span><br><span class="line">        <span class="comment">//支持的最低版本</span></span><br><span class="line">        minSdkVersion <span class="number">14</span></span><br><span class="line">        <span class="comment">//支持的目标版本</span></span><br><span class="line">        targetSdkVersion <span class="number">19</span></span><br><span class="line">        <span class="comment">//版本号</span></span><br><span class="line">        versionCode <span class="number">100200200</span></span><br><span class="line">        <span class="comment">//版本名</span></span><br><span class="line">        versionName <span class="string">"1.2.2"</span></span><br><span class="line">        <span class="comment">// 单元测试相关的配置</span></span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭Android Studio的PNG合法性检查的</span></span><br><span class="line">    aaptOptions.cruncherEnabled = <span class="keyword">false</span></span><br><span class="line">    aaptOptions.useNewCruncher = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//目录指向配置,比如从Eclipse迁过来的代码，和AS的文件位置不同，就需要手动设置</span></span><br><span class="line">    <span class="keyword">sourceSets</span> &#123;</span><br><span class="line"></span><br><span class="line">        main &#123;</span><br><span class="line">            <span class="comment">//指定AndroidManifest文件</span></span><br><span class="line">            manifest.srcFile <span class="string">'AndroidManifest.xml'</span></span><br><span class="line">            <span class="comment">//指定source目录</span></span><br><span class="line">            java.srcDirs = [<span class="string">'src'</span>]</span><br><span class="line">            <span class="comment">//指定source目录</span></span><br><span class="line">            resources.srcDirs = [<span class="string">'src'</span>]</span><br><span class="line">            <span class="comment">//指定source目录</span></span><br><span class="line">            aidl.srcDirs = [<span class="string">'src'</span>]</span><br><span class="line">            <span class="comment">//指定source目录</span></span><br><span class="line">            renderscript.srcDirs = [<span class="string">'src'</span>]</span><br><span class="line">            <span class="comment">//指定资源目录</span></span><br><span class="line">            res.srcDirs = [<span class="string">'res'</span>]</span><br><span class="line">            <span class="comment">//指定assets目录</span></span><br><span class="line">            assets.srcDirs = [<span class="string">'assets'</span>]</span><br><span class="line">            <span class="comment">//指定lib库目录</span></span><br><span class="line">            jniLibs.srcDirs = [<span class="string">'libs'</span>]</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指定debug模式的路径</span></span><br><span class="line">        debug.setRoot(<span class="string">'build-types/debug'</span>)</span><br><span class="line">        <span class="comment">//指定release模式的路径</span></span><br><span class="line">        release.setRoot(<span class="string">'build-types/release'</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//签名配置</span></span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        <span class="comment">//发布版签名配置</span></span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">//密钥文件路径</span></span><br><span class="line">            storeFile <span class="keyword">file</span>(<span class="string">"xxx.keystore"</span>)</span><br><span class="line">            <span class="comment">//密钥文件密码</span></span><br><span class="line">            storePassword <span class="string">"xxx"</span></span><br><span class="line">            <span class="comment">//key别名</span></span><br><span class="line">            keyAlias <span class="string">"xxx"</span></span><br><span class="line">            <span class="comment">//key密码</span></span><br><span class="line">            keyPassword <span class="string">"xxx"</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//debug版签名配置</span></span><br><span class="line">        debug &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//密钥文件路径，可以跟release配置不同的密钥路径</span></span><br><span class="line">            storeFile <span class="keyword">file</span>(<span class="string">"xxx.keystore"</span>)</span><br><span class="line">            <span class="comment">//密钥文件密码</span></span><br><span class="line">            storePassword <span class="string">"xxx"</span></span><br><span class="line">            <span class="comment">//key别名</span></span><br><span class="line">            keyAlias <span class="string">"xxx"</span></span><br><span class="line">            <span class="comment">//key密码</span></span><br><span class="line">            keyPassword <span class="string">"xxx"</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//build类型</span></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        <span class="comment">//发布</span></span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">//在编译时生成一些静态变量，这样就会在BuildConfig类中生成type字段，当然gradle默认会在BuildConfig中生成一些默认字段</span></span><br><span class="line">            buildConfigField <span class="string">"string"</span>,<span class="string">"type"</span>,<span class="string">"release"</span></span><br><span class="line">            <span class="comment">//是否支持zip</span></span><br><span class="line">            zipAlignEnabled <span class="keyword">true</span></span><br><span class="line">            <span class="comment">// 移除无用的resource文件</span></span><br><span class="line">            shrinkResources <span class="keyword">true</span></span><br><span class="line">            <span class="comment">//是否支持调试</span></span><br><span class="line">            debuggable <span class="keyword">false</span></span><br><span class="line">            <span class="comment">//混淆开启</span></span><br><span class="line">            minifyEnabled <span class="keyword">true</span></span><br><span class="line">            <span class="comment">//指定混淆规则文件</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-project.txt'</span></span><br><span class="line">            <span class="comment">//设置签名信息</span></span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">            <span class="comment">//设置ndk支持平台</span></span><br><span class="line">            ndk &#123;</span><br><span class="line">                abiFilters <span class="string">"armeabi"</span>, <span class="string">"x86"</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调试</span></span><br><span class="line">        debug &#123;</span><br><span class="line">            <span class="comment">//在编译时生成一些静态变量，这样就会在BuildConfig类中生成type字段，当然gradle默认会在BuildConfig中生成一些默认字段</span></span><br><span class="line">            buildConfigField <span class="string">"string"</span>,<span class="string">"type"</span>,<span class="string">"debug"</span></span><br><span class="line">            <span class="comment">//混淆不开启</span></span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            <span class="comment">//设置签名信息</span></span><br><span class="line">            signingConfig signingConfigs.debug</span><br><span class="line">            <span class="comment">//设置ndk支持平台</span></span><br><span class="line">            ndk &#123;</span><br><span class="line">                abiFilters <span class="string">"armeabi"</span>, <span class="string">"x86"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打包时的相关配置。当项目中依赖的第三方库越来越多时，有可能会出现两个依赖库中存在同一个（名称）文件。</span></span><br><span class="line">    <span class="comment">// 如果这样，Gradle在打包时就会提示错误（警告）。那么就可以根据提示，然后使用以下方法将重复的文件剔除。</span></span><br><span class="line">    packagingOptions &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">exclude</span> <span class="string">'META-INF/ASL2.0'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">exclude</span> <span class="string">'META-INF/LICENSE'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">exclude</span> <span class="string">'META-INF/NOTICE'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">exclude</span> <span class="string">'META-INF/MANIFEST.MF'</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        <span class="comment">//lint时候终止错误上报,防止编译的时候莫名的失败</span></span><br><span class="line">        abortOnError <span class="keyword">false</span></span><br><span class="line">        <span class="comment">//打包release版本的时候是否进行检测</span></span><br><span class="line">        checkReleaseBuilds <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// multiDex的一些相关配置，这样配置可以让你的编译速度更快</span></span><br><span class="line">    dexOptions &#123;</span><br><span class="line">        <span class="comment">// 让它不要对Lib做preDexing</span></span><br><span class="line">        preDexLibraries = <span class="keyword">false</span></span><br><span class="line">        <span class="comment">// 开启incremental dexing,优化编译效率，这个功能android studio默认是关闭的。</span></span><br><span class="line">        incremental <span class="keyword">true</span></span><br><span class="line">        <span class="comment">// 设置java堆内存大小</span></span><br><span class="line">        javaMaxHeapSize <span class="string">"4g"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置产品特性，即多渠道打包的东西，比如不同的应用名，图标、AndroidManifest.xml</span></span><br><span class="line">    <span class="comment">// 配合manifest merger使用的时候就可以达成在一次编译过程中产生多个具有自己特性配置的版本。</span></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        xiaomi &#123;</span><br><span class="line">            <span class="comment">// 渠道包配置</span></span><br><span class="line">            manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"xiaomi"</span>]     </span><br><span class="line">            manifest.srcFile <span class="string">'exampleapk/AndroidManifest1.xml'</span></span><br><span class="line">            applicationId <span class="string">"com.xxx.xxx.xiaomi"</span></span><br><span class="line">        &#125;</span><br><span class="line">        googlePlay &#123;</span><br><span class="line">            applicationId <span class="string">"com.xxx.xxx.googleplay"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// productFlavors的批量方法，类似一个循序遍历作用。</span></span><br><span class="line">    productFlavors.all &#123;</span><br><span class="line">        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置自定义打包名称</span></span><br><span class="line">    applicationVariants.all &#123; variant -&gt;</span><br><span class="line">        variant.outputs.<span class="keyword">each</span> &#123; output -&gt;</span><br><span class="line">            <span class="keyword">def</span> flavor = variant.productFlavors[<span class="number">0</span>].name</span><br><span class="line">            <span class="keyword">def</span> build_type = variant.buildType.name</span><br><span class="line">            output.outputFile = <span class="keyword">new</span> <span class="keyword">File</span>(</span><br><span class="line">                    output.outputFile.parent,</span><br><span class="line">                    <span class="string">"apkname_$&#123;flavor&#125;_$&#123;build_type&#125;_$&#123;variant.versionName&#125;.apk"</span>.toLowerCase())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// java版本</span></span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        <span class="keyword">sourceCompatibility</span> JavaVersion.VERSION_1_7</span><br><span class="line">        <span class="keyword">targetCompatibility</span> JavaVersion.VERSION_1_7</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//占位编译lib下所有jar包</span></span><br><span class="line">    provided <span class="keyword">fileTree</span>(<span class="keyword">include</span>: [<span class="string">'*.jar'</span>], dir: <span class="string">'lib'</span>)</span><br><span class="line">    <span class="comment">//占位编译xxx.jar</span></span><br><span class="line">    provided files(<span class="string">'../xxx.jar'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编译lib目录下的.jar文件</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">exclude</span>: [<span class="string">'android-support*.jar'</span>], <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    <span class="comment">//编译附加的项目</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':module-a'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':module-b'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':module-c'</span>)</span><br><span class="line">    <span class="comment">//编译第三方开源库</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.nostra13.universalimageloader:universal-image-loader:1.9.3'</span></span><br><span class="line">    <span class="comment">//设置缓存时间，0即不缓存</span></span><br><span class="line">    <span class="keyword">configurations</span>.all &#123;</span><br><span class="line">      resolutionStrategy.cacheChangingModulesFor(<span class="number">0</span>, <span class="string">'seconds'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基本配置的精华都在上面代码段中，仔细阅读。</p>]]></content>
      
      <categories>
          
          <category> Gradle </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Gradle简介</title>
      <link href="/2016/05/19/gradle/gradle%E7%AE%80%E4%BB%8B/"/>
      <url>/2016/05/19/gradle/gradle%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h3 id="Gradle简介"><a href="#Gradle简介" class="headerlink" title="Gradle简介"></a>Gradle简介</h3><p>　　Gradle傲居构建江湖盟主一位已有好几载，Google Android Studio的推出又将之引入到Android的世界，让我们有幸认识到他的强大。博主在使用之后对他的称赞也是不绝于口，那现在就让我带领你认识这个被称为“神器”的构建工具吧。</p><h3 id="Gradle是什么"><a href="#Gradle是什么" class="headerlink" title="Gradle是什么"></a>Gradle是什么</h3><p>　　Gradle跟ant/maven一样，是一种依赖管理/自动化构建工具。但是跟ant/maven不一样，它并没有使用xml语言，而是采用了Groovy语言，这使得它更加简洁、灵活，更加强大的是，gradle完全兼容maven和ivy。官方称它是 java ( JVM ) 世界中构建技术的一个飞跃。</p><h3 id="Gradle的特点"><a href="#Gradle的特点" class="headerlink" title="Gradle的特点"></a>Gradle的特点</h3><ol><li><p>声明式构建和合约构建<br>Gradle 的核心是基于 Groovy 的 领域特定语言 (DSL), 具有十分优秀的扩展性. Gradle 通过提供可以随意集成的声明式语言元素将声明性构建推到了一个新的高度. 这些元素也为 Java, Groovy, OSGi, Web 和Scala 等项目提供基于合约构建的支持. 而且, 这种声明式语言是可扩展的. 你可以添加自己的语言元素或加强现有的语言元素, 从而提供简洁, 易于维护和易于理解的构建.</p></li><li><p>基于依赖的编程语言<br>声明式语言位于通用任务图 ( general purpose task graph ) 的顶端，它可以被充分利用在你的构建中. 它具有强大的灵活性, 可以满足使用者对 Gradle 的一些特别的需求.</p></li><li><p>让构建结构化<br>Gradle 的易适应性和丰富性可让你在构建里直接套用通用的设计原则. 例如, 你可以非常容易地使用一些可重用的组件来构成你的构建. 但是不必要的间接内联内容是不合适的. 不要强行拆分已经结合在一起的部分 (例如, 在你的项目层次结构中). 避免使构建难以维护. 总之, 你可以创建一个结构良好，易于维护和易于理解的构建.</p></li><li><p>API深化<br>你会非常乐意在整个构建执行的生命周期中使用 Gradle, 因为Gradle 允许你管理和定制它的配置和执行行为.</p></li><li><p>Gradle 扩展<br>Gradle 扩展得非常好. 不管是简单的独立项目还是大型的多项目构建, 它都能显著的提高效率. 这是真正的结构构建. 顶尖水平的构建功能，还可以解决许多大公司碰到的构建 性能低下的问题.</p></li><li><p>多项目构建<br>Gradle 对多项目的支持是非常出色的. 项目依赖是很重要的部分. 它允许你模拟在多项目构建中项目的关系，这正是你所要关注的地方.Gradle 提供了局部构建的功能. 如果你构建一个单独的子项目, Gradle 会构建这个子项目依赖的所有子项目. 你也可以选择依赖于另一个特别的子项目重新构建这些子项目. 这样在一些大型项目里就可以节省非常多的时间.</p></li><li><p>多种方式来管理你的依赖<br>不同的团队有不同的管理外部依赖的方法. Gradle 对于任何管理策略都提供了合适的支持. 从远程 Maven 和 Ivy 库的依赖管理到本地文件系统的 jars 或者 dirs.</p></li><li><p>Gradle 是第一个构建整合工具<br>Ant 的 tasks是 Gradle 中很重要的部分, 更有趣是 Ant 的 projects 也是十分重要的部分. Gradle 可以直接引入Ant 项目, 并在运行时直接将 Ant targets 转换成 Gradle tasks. 你可以从 Gradle 中依赖它们, 并增强它们的功能, 甚至可以在 build.xml 文件中声明 Gradle tasks 的依赖. 并且properties, paths 等也可以通过同样的方法集成进来.Gradle 完全支持你已有的 Maven 或者 lvy 仓库来构造发布或者提取依赖. Gradle 也提供了一个转化器, 用来将 maven 的 pom.xml 文件转换成 Gradle 脚本. 在运行时引入 Maven 项目也会在稍后推出.</p></li><li><p>易于迁移<br>Gradle 可以兼容任何结构. 因此你可以直接在你的产品构建的分支上开发你的 Gradle 构建, 并且二者可以并行. 通常建议编写一些测试代码来确保它们的功能是相同的. 通过这种方式, 在迁移的时候就不会显得那么混乱和不可靠, 这是通过婴儿学步的方式来获得最佳的实践.</p></li><li><p>基于Groovy<br>Gradle 的构建脚本是通过 Groovy 编写的而不是 XML. 但是并不像其他方式, 这并不是为了简单的展示用动态语言编写的原始脚本有多么强大. 不然的话, 只会导致维护构建变得非常困难. Gradle 的整个设计是朝着一种语言的方向开发的, 并不是一种死板的框架. Groovy 就像胶水一样, 把你像实现的构想和抽象的 Gradle 粘在一起. Gradle提供了一些标准的构想, 但是他们并不享有任何形式的特权. 相比于其他声明式构建系统，这是一个比较突出的特点.</p></li><li><p>Gradle 包装器<br>Gradle 包装器允许你在没有安装 Gradle 的机器上运行 Gradle 构建. 在一些持续集成的服务器上, 这个功能将非常有用. 它同样也能降低使用一个开源项目的门槛, 也就是说构建它将会非常简单. 这个包装器对于公司来说也是很有吸引力的. 它并不需要为客户机提供相应的管理防范. 这种方式同样也能强制某一个版本 Gradle 的使用从而最小化某些支持问题.</p></li><li><p>免费和开源<br>Gradle 是一个开源项目, 遵循 ASL 许可.</p></li></ol><h3 id="Gradle与Maven的区别"><a href="#Gradle与Maven的区别" class="headerlink" title="Gradle与Maven的区别"></a>Gradle与Maven的区别</h3><p>　　Java世界中主要有三大构建工具：Ant、Maven和Gradle。经过几年的发展，Ant几乎销声匿迹、Maven也日薄西山，而Gradle的发展则如日中天。</p><h4 id="依赖管理系统"><a href="#依赖管理系统" class="headerlink" title="依赖管理系统"></a>依赖管理系统</h4><p>　　Maven为Java世界引入了一个新的依赖管理系统。<br>　　1. 在Java世界中，可以用groupId、artifactId、version组成的Coordination（坐标）唯一标识一个依赖。任何基于Maven构建的项目自身也必须定义这三项属性，生成的包可以是Jar包，也可以是war包或者ear包。一个典型的依赖引用如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line"> &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>　　从上面可以看出当引用一个依赖时，version可以省略掉，这样在获取依赖时会选择最新的版本。而存储这些组件的仓库有远程仓库和本地仓库之分。远程仓库可以使用世界公用的central仓库，也可以使用Apache Nexus自建私有仓库；本地仓库则在本地计算机上。通过Maven安装目录下的settings.xml文件可以配置本地仓库的路径，以及采用的远程仓库的地址。<br>　　Gradle在设计的时候基本沿用了Maven的这套依赖管理体系。不过它在引用依赖时还是进行了一些改进。首先引用依赖方面变得非常简洁。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line"> <span class="keyword">compile</span> <span class="string">'org.hibernate:hibernate-core:3.6.7.Final'</span></span><br><span class="line"> testCompile ‘junit:junit:<span class="number">4</span>.+<span class="string">'</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>　　2. Maven和Gradle对依赖项的scope有所不同。在Maven世界中，一个依赖项有6种scope，分别是complie(默认)、provided、runtime、test、system、import。而grade将其简化为了4种，compile、runtime、testCompile、testRuntime。那么如果想在gradle使用类似于provided的scope怎么办？别着急，由于gradle语言的强大表现力，我们可以轻松编写代码来实现类似于provided scope的概念（例如How to use provided scope for jar file in Gradle build?）。<br>　　3. Gradle支持动态的版本依赖。在版本号后面使用+号的方式可以实现动态的版本管理。如下所示：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line"> <span class="keyword">compile</span> ‘junit:junit:<span class="number">4</span>.+<span class="string">'</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>　　4. 在解决依赖冲突方面Gradle的实现机制更加明确。使用Maven和Gradle进行依赖管理时都采用的是传递性依赖；而如果多个依赖项指向同一个依赖项的不同版本时就会引起依赖冲突。而Maven处理这种依赖关系往往是噩梦一般的存在。而Gradle在解决依赖冲突方面相对来说比较明确.</p><h4 id="多模块构建"><a href="#多模块构建" class="headerlink" title="多模块构建"></a>多模块构建</h4><p>　　在SOA和微服务的浪潮下，将一个项目分解为多个模块已经是很通用的一种方式。在Maven中需要定义个parent POM作为一组module的聚合POM。在该POM中可以使用<modules>标签来定义一组子模块。parent POM不会有什么实际构建产出。而parent POM中的build配置以及依赖配置都会自动继承给子module。<br>　　而Gradle也支持多模块构建。而在parent的build.gradle中可以使用allprojects和subprojects代码块来分别定义里面的配置是应用于所有项目还是子项目。对于子模块的定义是放置在setttings.gradle文件中的。在gradle的设计当中，每个模块都是Project的对象实例。而在parent build.gradle中通过allprojects或subprojects可以对这些对象进行各种操作。这无疑比Maven要灵活的多。<br>比如在parent的build.gradle中有以下代码：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line"> <span class="keyword">task</span> hello &lt;&lt; &#123; <span class="keyword">task</span> -&gt; <span class="keyword">println</span> <span class="string">"I'm $task.project.name"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></modules></p><p>　　执行命令gradle -q hello会依次打印出父module以及各个submodule的项目名称。这种强大的能力能让gradle对各个模块具有更强的定制化。</p><h4 id="一致的项目结构"><a href="#一致的项目结构" class="headerlink" title="一致的项目结构"></a>一致的项目结构</h4><p>　　在Ant时代大家创建Java项目目录时比较随意，然后通过Ant配置指定哪些属于source，那些属于testSource等。而Maven在设计之初的理念就是Conversion over configuration（约定大于配置）。其制定了一套项目目录结构作为标准的Java项目结构。一个典型的Maven项目结构如下：<br><img src="https://raw.githubusercontent.com/seasonfif/picture/master/other/mulujiegou.png" alt="mulu"><br>　　Gradle也沿用了这一标准的目录结构。如果你在Gradle项目中使用了标准的Maven项目结构的话，那么在Gradle中也无需进行多余的配置,只需在文件中包含apply plugin:’java’,系统会自动识别source、resource、test srouce、 test resource等相应资源。不过Gradle作为JVM上的构建工具，也同时支持groovy、scala等源代码的构建，甚至支持Java、groovy、scala语言的混合构建。虽然Maven通过一些插件（比如maven-scala-plugin）也能达到相同目的，但配置方面显然Gradle要更优雅一些。</p><h4 id="一致的构建模型"><a href="#一致的构建模型" class="headerlink" title="一致的构建模型"></a>一致的构建模型</h4><p>　　为了解决Ant中对项目构建活动缺乏标准化的问题，Maven特意设置了标准的项目构建周期，其默认的构建周期如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;phases&gt;</span><br><span class="line"> &lt;phase&gt;validate&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;initialize&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;generate-sources&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;process-sources&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;generate-resources&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;process-resources&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;compile&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;process-classes&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;generate-test-sources&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;process-test-sources&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;generate-test-resources&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;process-test-resources&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;test-compile&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;process-test-classes&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;test&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;prepare-package&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;pre-integration-test&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;integration-test&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;post-integration-test&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;verify&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;install&lt;/phase&gt;</span><br><span class="line"> &lt;phase&gt;deploy&lt;/phase&gt;</span><br><span class="line">&lt;/phases&gt;</span><br></pre></td></tr></table></figure></p><p>　　而这种构建周期也是Maven最为人诟病的地方。因为Maven将项目的构建周期限制的太死，你无法在构建周期中添加新的phase，只能将插件绑定到已有的phase上。而现在项目的构建过程变得越来越复杂，而且多样化，显然Maven对这种复杂度缺少足够的应变能力。比如你想在项目构建过程中进行一项压缩所有javascript的任务，那么就要绑定到Maven的现有的某个phase上，而显然貌似放在哪个phase都不太合适。而且这些phase都是串行的，整个执行下来是一条线，这也限制了Maven的构建效率。而Gradle在构建模型上则非常灵活。在Gradle世界里可以轻松创建一个task，并随时通过depends语法建立与已有task的依赖关系。甚至对于Java项目的构建来说，Gradle是通过名为java的插件来包含了一个对Java项目的构建周期，这等于Gradle本身直接与项目构建周期是解耦的。</p><h4 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h4><p>　　Maven和Gradle设计时都采用了插件机制。但显然Gradle更胜一筹。主要原因在于Maven是基于XML进行配置。所以其配置语法太受限于XML。即使实现很小的功能都需要设计一个插件，建立其与XML配置的关联。比如想在Maven中执行一条shell命令，其配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line"> &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line"> &lt;executions&gt;</span><br><span class="line"> &lt;execution&gt;</span><br><span class="line"> &lt;id&gt;drop DB =&gt; db_name&lt;/id&gt;</span><br><span class="line"> &lt;phase&gt;pre-integration-test&lt;/phase&gt;</span><br><span class="line"> &lt;goals&gt;</span><br><span class="line"> &lt;goal&gt;exec&lt;/goal&gt;</span><br><span class="line"> &lt;/goals&gt;</span><br><span class="line"> &lt;configuration&gt;</span><br><span class="line"> &lt;executable&gt;curl&lt;/executable&gt;</span><br><span class="line"> &lt;arguments&gt;</span><br><span class="line"> &lt;argument&gt;-s&lt;/argument&gt;</span><br><span class="line"> &lt;argument&gt;-S&lt;/argument&gt;</span><br><span class="line"> &lt;argument&gt;-X&lt;/argument&gt;</span><br><span class="line"> &lt;argument&gt;DELETE&lt;/argument&gt;</span><br><span class="line"> &lt;argument&gt;http://$&#123;db.server&#125;:$&#123;db.port&#125;/db_name&lt;/argument&gt;</span><br><span class="line"> &lt;/arguments&gt;</span><br><span class="line"> &lt;/configuration&gt;</span><br><span class="line"> &lt;/execution&gt;</span><br><span class="line"> &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure></p><p>　　而在Gradle中则一切变得非常简单。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> dropDB(type: Exec) &#123;</span><br><span class="line"> commandLine ‘curl’,’-s’,’s’,’-x’,’<span class="keyword">DELETE</span>’,<span class="string">"http://$&#123;db.server&#125;:&#123;db.port&#125;/db_name"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　从以上五个方面可以看出Maven和Gradle的主要差异。Maven的设计核心Convention Over Configuration被Gradle更加发扬光大，而Gradle的配置即代码又超越了Maven。在Gradle中任何配置都可以作为代码被执行的，我们也可以随时使用已有的Ant脚本（Ant task是Gradle中的一等公民）、Java类库、Groovy类库来辅助完成构建任务的编写。<br>　　这种采用本身语言实现的DSL对本身语言项目进行构建管理的例子比比皆是。比如Rake和Ruby、Grunt和JavaScript、Sbt和Ruby…..而Gradle之所以使用Groovy语言实现，是因为Groovy比Java语言更具表现力，其语法特性更丰富，又兼具函数式的特点。这几年兴起的语言（比如Scala、Go、Swift）都属于强类型的语言，兼具面向对象和函数式的特点。</p><h3 id="为什使用Gradle"><a href="#为什使用Gradle" class="headerlink" title="为什使用Gradle"></a>为什使用Gradle</h3><p>　　在脚本构建时, 一个内部的 DSL（基于一个动态语言）相对于 XML 的优势是巨大的. 有这么多的动态语言, 为什么选择 Groovy? 答案在于 Gradle 的运行环境. 虽然 Gradle 以一个通用构建工具为核心, 但是它的重点是Java项目. 在这样的项目中, 显然团队每个成员都对 Java 非常熟悉. 而且构建应尽可能对所有团队成员都是透明的,所以选择了 Groovy.<br>　　那么，为什么不直接使用 Java 作为构建脚本的语言. 这是一个很好的问题. 对于你的团队, 它要有最高的透明度和最低的学习曲线, 也就是说容易掌握. 但由于 Java 的限制, 这样的构建语言不会那么完美和强大. 而像 Python，Groovy 或 Ruby 语言用来作为构建语言会更好. 之所以使用 Groovy 是因为它给 Java 开发人员提供了迄今为止最大的透明度. 其基本的符号和类型与 Java 是一样的，其封装结构和许多其他的地方也是如此. Groovy 在这基础上提供了更多的功能, 而且与 java 有共同的基础。</p>]]></content>
      
      <categories>
          
          <category> Gradle </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HandlerThread学习</title>
      <link href="/2016/05/14/android/HandlerThread%E5%AD%A6%E4%B9%A0/"/>
      <url>/2016/05/14/android/HandlerThread%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>　　回想一下，我们要在主线程中使用Handler发消息给子线程的场景。大概类似于下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Looper myLooper;</span><br><span class="line"><span class="keyword">private</span> Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Looper.prepare();</span><br><span class="line">    myLooper = Looper.myLooper();</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler(myLooper)&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">handler.sendEmptyMessage(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>　　上面的代码不仅需要自己产生Looper，而且还会有myLooper对象空指针的错误。那么有没有什么方式来避免这些不足呢？答案是有的，那就是使用HandlerThread。</p><h3 id="HandlerThread是什么"><a href="#HandlerThread是什么" class="headerlink" title="HandlerThread是什么"></a>HandlerThread是什么</h3><p>　　首先我们来看一下类签名：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handy class for starting a new thread that has a looper. The looper can then be </span></span><br><span class="line"><span class="comment"> * used to create handler classes. Note that start() must still be called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  Looper mLooper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这里很明确HandlerThread继承自Thread，它本质是一个线程。通过注释还可以了解到这个线程拥有一个可以创建Handler的Looper成员属性，这一点通过成员变量mLooper可以佐证。<br>　　既然是一个线程我们很有必要看一下它的run方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>　　有木有觉得这跟我们开场那段代码很像，但是这里还有一些额外的设置，其中最主要的就是synchronized同步代码块这部分了，它就是用来保证mLooper不为空的关键。需要注意的是代码块中还调了notifyAll()方法，既然有notify那很自然就想到什么时间wait的呢，不要着急，我们继续往下看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * This method returns the Looper associated with this thread. If this thread not been started</span></span><br><span class="line"><span class="comment">  * or for any reason is isAlive() returns false, this method will return null. If this thread </span></span><br><span class="line"><span class="comment">  * has been started, this method will block until the looper has been initialized.  </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> The looper.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mLooper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　可以看出我们在外部通过getLooper方法获取looper对象时会先先判断当前线程是否启动了，如果线程已经启动，那么将会进入同步语句并判断Looper是否为null，为null则代表Looper对象还没有被赋值，也就是还没被创建，此时当前调用线程进入等待阶段，直到Looper对象被创建并通过 notifyAll()方法唤醒等待线程，最后才返回Looper对象，之所以需要等待唤醒机制，是因为Looper的创建是在子线程中执行的，而调用getLooper方法则是在主线程进行的，这样我们就无法保障我们在调用getLooper方法时Looper已经被创建，到这里我们也清楚了为什么在获取mLooper时会存在对象空指针异常了，只有当线程创建成功并且Looper对象也创建成功之后才能获得mLooper的值，HandlerThread内部通过等待唤醒机制解决了同步问题。<br>　　除此之外HandlerThread还为我们提供了退出消息循环的方法，帮我们解决内存泄漏等隐患：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Quits the handler thread's looper.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;</span></span><br><span class="line"><span class="comment">  * Causes the handler thread's looper to terminate without processing any</span></span><br><span class="line"><span class="comment">  * more messages in the message queue.</span></span><br><span class="line"><span class="comment">  * &lt;/p&gt;&lt;p&gt;</span></span><br><span class="line"><span class="comment">  * Any attempt to post messages to the queue after the looper is asked to quit will fail.</span></span><br><span class="line"><span class="comment">  * For example, the &#123;<span class="doctag">@link</span> Handler#sendMessage(Message)&#125; method will return false.</span></span><br><span class="line"><span class="comment">  * &lt;/p&gt;&lt;p class="note"&gt;</span></span><br><span class="line"><span class="comment">  * Using this method may be unsafe because some messages may not be delivered</span></span><br><span class="line"><span class="comment">  * before the looper terminates.  Consider using &#123;<span class="doctag">@link</span> #quitSafely&#125; instead to ensure</span></span><br><span class="line"><span class="comment">  * that all pending work is completed in an orderly manner.</span></span><br><span class="line"><span class="comment">  * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> True if the looper looper has been asked to quit or false if the</span></span><br><span class="line"><span class="comment">  * thread had not yet started running.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #quitSafely</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper looper = getLooper();</span><br><span class="line">    <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">        looper.quit();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　从源码可以看出当我们调用quit方法时，内部实际上是调用Looper的quit方法而最终执行的则是MessageQueue中的removeAllMessagesLocked方法，这里默认你熟悉Handler消息机制，该方法主要是把MessageQueue消息池中所有的消息全部清空，无论是延迟消息（延迟消息是指通过sendMessageDelayed或通过postDelayed等方法发送）还是非延迟消息。<br>　　还有一个退出的方法quitSafely，暂叫安全的退出方式吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Quits the handler thread's looper safely.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;</span></span><br><span class="line"><span class="comment">  * Causes the handler thread's looper to terminate as soon as all remaining messages</span></span><br><span class="line"><span class="comment">  * in the message queue that are already due to be delivered have been handled.</span></span><br><span class="line"><span class="comment">  * Pending delayed messages with due times in the future will not be delivered.</span></span><br><span class="line"><span class="comment">  * &lt;/p&gt;&lt;p&gt;</span></span><br><span class="line"><span class="comment">  * Any attempt to post messages to the queue after the looper is asked to quit will fail.</span></span><br><span class="line"><span class="comment">  * For example, the &#123;<span class="doctag">@link</span> Handler#sendMessage(Message)&#125; method will return false.</span></span><br><span class="line"><span class="comment">  * &lt;/p&gt;&lt;p&gt;</span></span><br><span class="line"><span class="comment">  * If the thread has not been started or has finished (that is if</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #getLooper&#125; returns null), then false is returned.</span></span><br><span class="line"><span class="comment">  * Otherwise the looper is asked to quit and true is returned.</span></span><br><span class="line"><span class="comment">  * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> True if the looper looper has been asked to quit or false if the</span></span><br><span class="line"><span class="comment">  * thread had not yet started running.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper looper = getLooper();</span><br><span class="line">    <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">        looper.quitSafely();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　从源码看到跟quit方法只有一处不同就是调用的looper方法不同。这里调用quitSafely方法，其内部调用的是Looper的quitSafely方法而最终执行的是MessageQueue中的removeAllFutureMessagesLocked方法，该方法只会清空MessageQueue消息池中所有的延迟消息，并将消息池中所有的非延迟消息派发出去让Handler去处理完成后才停止Looper循环，quitSafely相比于quit方法安全的原因在于清空消息之前会派发所有的非延迟消息。</p><p>　　通过上面的分析，我们可以总结HandlerThread的特点如下：<br>　　1、HandlerThread本质上是一个线程类，它继承了Thread；<br>　　2、HandlerThread有自己的内部Looper对象，可以进行looper循环；<br>　　3、获取HandlerThread的looper对象绑定给Handler对象，可以在handleMessage方法中执行异步任务；<br>　　4、创建HandlerThread后必须先调用HandlerThread.start()方法，Thread会先调用run方法，创建Looper对象；<br>　　5、HandlerThread可以退出消息循环。</p><h3 id="怎么使用HandlerThread"><a href="#怎么使用HandlerThread" class="headerlink" title="怎么使用HandlerThread"></a>怎么使用HandlerThread</h3><p>　　HandlerThread的使用也是很简单的，只需要初始化一个HandlerThread，并将它的getLooper对象绑定给一个Handler就ok了。具体代码如下小例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.HandlerThread;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HandlerThread myHandlerThread ;</span><br><span class="line">    <span class="keyword">private</span> Handler handler ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建HandlerThread线程,线程名字：I'm a handlerthread</span></span><br><span class="line">        myHandlerThread = <span class="keyword">new</span> HandlerThread( <span class="string">"I'm a handlerthread"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启HandlerThread线程</span></span><br><span class="line">        myHandlerThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在这个线程中创建一个handler对象，并绑定myHandlerThread的looper对象</span></span><br><span class="line">        handler = <span class="keyword">new</span> Handler( myHandlerThread.getLooper() )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                <span class="comment">//这个方法是运行在myHandlerThread线程中的</span></span><br><span class="line">                Log.d( <span class="string">"handler "</span> , <span class="string">"发送的消息是： "</span> + msg.what + <span class="string">"  所在线程为： "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在主线程给handler发送消息</span></span><br><span class="line">        handler.sendEmptyMessage( <span class="number">1</span> ) ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//在子线程给handler发送数据</span></span><br><span class="line">             handler.sendEmptyMessage( <span class="number">2</span> ) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start() ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//退出消息循环，释放资源</span></span><br><span class="line">        myHandlerThread.quit() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后看到的日志输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D/handler: 发送的消息是： 1  所在线程为： I&apos;m a handlerthread</span><br><span class="line">D/handler: 发送的消息是： 2  所在线程为： I&apos;m a handlerthread</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java线程同步机制</title>
      <link href="/2016/05/12/java/Java%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
      <url>/2016/05/12/java/Java%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>　　多个执行线程共享一个资源的情景，是并发编程中最常见的情景之一。多个线程读或者写相同的数据等情况时可能会导致数据不一致。为了解决这些问题，引入了临界区概念。临界区是一个用以访问共享资源的代码块，这个代码块在同一时间内只允许一个线程执行。<br>　　Java多线程使用锁机制来实现同步以保证数据安全。当一个线程试图访问一个临界区时，它将使用一种同步机制来查看是不是已有其他线程进入临界区。如果没有其他线程进入临界区，它就可以进入临界区；如果已有线程进入了临界区，它就被同步机制挂起，直到进入的线程离开这个临界区。如果在等待进入临界区的线程不止一个，JVM会随机选择其中的一个，其余的将继续等待。</p><h3 id="使用synchronized实现同步"><a href="#使用synchronized实现同步" class="headerlink" title="使用synchronized实现同步"></a>使用synchronized实现同步</h3><p>　　每一个用synchronized关键字声明的方法都是临界区。在Java中，同一个对象的临界区，在同一时间只有一个允许被访问。<br>　　注意：用synchronized关键字声明的静态方法，同时只能被一个执行线程访问，但是其他线程可以访问这个对象的非静态方法。即：两个线程可以同时访问一个对象的两个不同的synchronized方法，其中一个是静态方法，一个是非静态方法。了解了synchronized关键字的作用，再来看一下synchronized关键字的使用方式。<br>　　首先看修饰静态方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　或<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(Demo.class)&#123;</span><br><span class="line">    <span class="comment">//something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　下面是修饰非静态方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　或<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="comment">//something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　需要注意的是，synchronized修饰静态方法防止多个线程同时访问这个类中的synchronized static 方法。它会对对类的所有对象实例起作用。然而，synchronized修饰非静态方法则可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线 程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的 synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法。</p><h3 id="synchronized-代码块"><a href="#synchronized-代码块" class="headerlink" title="synchronized 代码块"></a>synchronized 代码块</h3><p>　　除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){/区块/}，它的作用域是当前对象。这时锁就是对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的instance变量（它得是一个对象）来充当锁：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">byte</span>[] lock = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]; <span class="comment">// 特殊的instance变量    </span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">         <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            <span class="comment">//something</span></span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　需要注意下面的问题：<br>　　1、synchronized关键字会降低应用程序的性能，因此只能在并发场景中修改共享数据的方法上使用它。<br>　　2、临界区的访问应该尽可能的短。方法的其余部分保持在synchronized代码块之外，以获取更好的性能</p><h3 id="使用Lock实现同步"><a href="#使用Lock实现同步" class="headerlink" title="使用Lock实现同步"></a>使用Lock实现同步</h3><p>　　除了使用synchronized外，还可以使用Lock对象来创建临界区。它比synchronized关键字更强大也更加灵活。这种机制基于Lock接口及其实现类（例如：ReentrantLock）<br>　　它比synchronized关键字好的地方：<br>　　1、提供了更多的功能。tryLock()方法的实现，这个方法试图获取锁，如果锁已经被其他线程占用，它将返回false并继续往下执行代码。<br>　　2、Lock接口允许分离读和写操作，允许多个线程读和只有一个写线程。ReentrantReadWriteLock<br>　　3、具有更好的性能<br>　　使用范式如下示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();  </span><br><span class="line">lock.lock();  </span><br><span class="line"><span class="keyword">try</span> &#123;   </span><br><span class="line">  <span class="comment">// update object state  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">finally</span> &#123;  </span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　可以看到 Lock 和 synchronized 有一点明显的区别 —— lock 必须在 finally 块中释放。否则，如果受保护的代码将抛出异常，锁就有可能永远得不到释放。</p><h3 id="锁的概念以及分类"><a href="#锁的概念以及分类" class="headerlink" title="锁的概念以及分类"></a>锁的概念以及分类</h3><p>　　公平锁和非公平锁<br>　　公平锁是指多个线程在等待同一个锁时，必须按照申请锁的先后顺序来一次获得锁。<br>　　公平锁的好处是等待锁的线程不会饿死，但是整体效率相对低一些；非公平锁的好处是整体效率相对高一些，但是有些线程可能会饿死或者说很早就在等待锁，但要等很久才会获得锁。其中的原因是公平锁是严格按照请求所的顺序来排队获得锁的，而非公平锁时可以抢占的，即如果在某个时刻有线程需要获取锁，而这个时候刚好锁可用，那么这个线程会直接抢占，而这时阻塞在等待队列的线程则不会被唤醒。<br>　　公平锁可以使用new ReentrantLock(true)实现。</p><p>　　自旋锁<br>　　Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态装换需要耗费很多的处理器时间，对于代码简单的同步块（如被synchronized修饰的getter()和setter()方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。<br>　　虚拟机的开发团队注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间取挂起和恢复现场并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下“，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。<br>　　自旋等待不能代替阻塞。自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋当代的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会拜拜浪费处理器资源。因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当使用传统的方式去挂起线程了。<br>　　自旋是在轻量级锁中使用的，在重量级锁中，线程不使用自旋。<br>　　如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。</p><p>　　锁消除<br>　　锁消除是虚拟机JIT在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判断依据是来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而能被其他线程访问到，那就可以把他们当做栈上数据对待，认为他们是线程私有的，同步加锁自然就无需进行。<br>来看这样一个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">       sb.append(s1);</span><br><span class="line">       sb.append(s2);</span><br><span class="line">       sb.append(s3);</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>　　可以知道StringBuffer 的append方法定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(StringBuffer sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(sb);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>　　也就是说在concatString()方法中涉及了同步操作。但是可以观察到sb对象它的作用域被限制在方法的内部，也就是sb对象不会“逃逸”出去，其他线程无法访问。因此，虽然这里有锁，但是可以被安全的消除，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。</p><p>　　锁粗化<br>　　原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制的尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁禁止，那等待的线程也能尽快拿到锁。大部分情况下，这些都是正确的。但是，如果一些列的联系操作都是同一个对象反复加上和解锁，甚至加锁操作是出现在循环体中的，那么即使没有线程竞争，频繁地进行互斥同步操作也导致不必要的性能损耗。<br>　　举个案例，类似锁消除的concatString()方法。如果StringBuffer sb = new StringBuffer();定义在方法体之外，那么就会有线程竞争，但是每个append()操作都对同一个对象反复加锁解锁，那么虚拟机探测到有这样的情况的话，会把加锁同步的范围扩展到整个操作序列的外部，即扩展到第一个append()操作之前和最后一个append()操作之后，这样的一个锁范围扩展的操作就称之为锁粗化。</p><p>　　可重入锁<br>　　可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在JAVA环境下 ReentrantLock 和synchronized 都是可重入锁。可重入锁最大的作用是避免死锁。</p><p>　　悲观锁和乐观锁<br>　　悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。<br>　　乐观锁：假定不会发生并发冲突，只在提交操作时检测是否违反数据完整性。（使用版本号或者时间戳来配合实现）</p><p>　　共享锁和排它锁<br>　　共享锁：如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排它锁。获准共享锁的事务只能读数据，不能修改数据。<br>　　排它锁：如果事务T对数据A加上排它锁后，则其他事务不能再对A加任何类型的锁。获得排它锁的事务即能读数据又能修改数据。</p><p>　　读写锁<br>　　读写锁是一个资源能够被多个读线程访问，或者被一个写线程访问但不能同时存在读线程。Java当中的读写锁通过ReentrantReadWriteLock实现。</p><p>　　互斥锁<br>　　所谓互斥锁就是指一次最多只能有一个线程持有的锁。在JDK中synchronized和JUC的Lock就是互斥锁。</p><p>　　无锁<br>　　要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。<br>　　1、线程本地存储。可以参考ThreadLocal<br>　　2、volatile<br>　　3、CAS<br>　　4、协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java线程状态梳理</title>
      <link href="/2016/04/23/java/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A2%B3%E7%90%86/"/>
      <url>/2016/04/23/java/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A2%B3%E7%90%86/</url>
      <content type="html"><![CDATA[<p>　　很多时候我们很自然的创建一个线程，紧接着启动它执行任务，然后对它不闻不问直到它替我们完成任务。那么从我们start一个线程到结束的这个过程中它都经历过什么呢？对于这个问题我们可以从线程的状态入手解答。</p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>　　首先线程的状态在源码中是以Thread类的内部类来定义的，它是一个枚举类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A thread state.  A thread can be in one of the following states:</span></span><br><span class="line"><span class="comment">* &lt;ul&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> #NEW&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">*     A thread that has not yet started is in this state.</span></span><br><span class="line"><span class="comment">*     &lt;/li&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> #RUNNABLE&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">*     A thread executing in the Java virtual machine is in this state.</span></span><br><span class="line"><span class="comment">*     &lt;/li&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> #BLOCKED&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">*     A thread that is blocked waiting for a monitor lock</span></span><br><span class="line"><span class="comment">*     is in this state.</span></span><br><span class="line"><span class="comment">*     &lt;/li&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> #WAITING&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">*     A thread that is waiting indefinitely for another thread to</span></span><br><span class="line"><span class="comment">*     perform a particular action is in this state.</span></span><br><span class="line"><span class="comment">*     &lt;/li&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> #TIMED_WAITING&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">*     A thread that is waiting for another thread to perform an action</span></span><br><span class="line"><span class="comment">*     for up to a specified waiting time is in this state.</span></span><br><span class="line"><span class="comment">*     &lt;/li&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> #TERMINATED&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">*     A thread that has exited is in this state.</span></span><br><span class="line"><span class="comment">*     &lt;/li&gt;</span></span><br><span class="line"><span class="comment">* &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* A thread can be in only one state at a given point in time.</span></span><br><span class="line"><span class="comment">* These states are virtual machine states which do not reflect</span></span><br><span class="line"><span class="comment">* any operating system thread states.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span>   1.5</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> #getState</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  NEW,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">    * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">    * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">    * such as processor.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  RUNNABLE,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">    * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">    * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">    * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  BLOCKED,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">    * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">    * following methods:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">    * perform a particular action.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">    * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">    * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">    * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">    * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  WAITING,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">    * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">    * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">    * The thread has completed execution.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这么长的类，其实就只有6个枚举值剩下的全部是注释，是的，可见这简简单单的几个值包含了多少信息；如果让我们来写肯定一行就完了，类似于这样的精炼：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    NEW, RUNNABLE,  BLOCKED, WAITING, TIMED_WAITING, TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　ok，不调侃了，毕竟jdk的作者都是大神。下面就来详细介(fan)绍(yi)一下这几个状态:</p><h4 id="NEW（新建）"><a href="#NEW（新建）" class="headerlink" title="NEW（新建）"></a>NEW（新建）</h4><p>　　线程还没有开始执行，即是在star调用之前的一种状态，那显而易见就是在声明一个线程对象的时候咯。<br>　　首先，既然已经有状态了，那肯定是已经创建好线程对象了，如果对象都没有，怎么会有状态。我们都知道当调用线程的start()方法时，线程不一定会马上执行，因为Java线程是映射到操作系统的线程进行执行，此时可能还需要等操作系统调度，即线程资源的自由竞争。</p><h4 id="RUNNABLE（可运行）"><a href="#RUNNABLE（可运行）" class="headerlink" title="RUNNABLE（可运行）"></a>RUNNABLE（可运行）</h4><p>　　该状态指线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权，转变成为运行中的线程，一个线程处于RUNNABLE状态的意思是在JVM层面它是在执行的，但是该线程可能是在等待操作系统的资源，比如说CPU。注释中说了，它表示线程在JVM层面是执行的，但在操作系统层面不一定，它举例是CPU，毫无疑问CPU是一个操作系统资源，但这也就意味着在等操作系统其他资源的时候，线程也会是这个状态，比如io操作。</p><h4 id="BLOCKED（阻塞）"><a href="#BLOCKED（阻塞）" class="headerlink" title="BLOCKED（阻塞）"></a>BLOCKED（阻塞）</h4><p>　　该状态表示线程在阻塞等待monitor lock(监视器锁)。一个线程在进入synchronized修饰的临界区的时候,或者在synchronized临界区中调用Object.wait然后被唤醒重新进入synchronized临界区都对应该状态。通常是它在等待一个“锁”，当尝试进入一个synchronized语句块/方法时，锁已经被其它线程占有，就会被阻塞，直到另一个线程走完临界区或发生了相应锁对象的wait()操作后，它才有机会去争夺进入临界区的权利。结合上面RUNNABLE的分析,也就是IO阻塞不会进入BLOCKED状态,只有synchronized会导致线程进入该状态。<br>　　关于BLOCKED状态，注释里只提到一种情况就是进入synchronized声明的临界区时会导致，这个也很好理解，synchronized是JVM自己控制的，所以这个阻塞事件它自己能够知道（对比理解上面的操作系统层面）。</p><h4 id="WAITING（无限期等待）"><a href="#WAITING（无限期等待）" class="headerlink" title="WAITING（无限期等待）"></a>WAITING（无限期等待）</h4><p>　　处于这种状态的线程不会被分配CPU执行时间，它们要等待显示的被其它线程唤醒。这种状态通常是指一个线程拥有对象锁后进入到相应的代码区域后，调用相应的“锁对象”的wait()方法操作后产生的一种结果。变相的实现还有LockSupport.park()、Thread.join()等，它们也是在等待另一个事件的发生，也就是描述了等待的意思。<br>　　以下方法会让线程陷入无限期等待状态：<br>　　1.没有设置timeout参数的Object.wait()<br>　　2.没有设置timeout参数的Thread.join()<br>　　3.LockSupport.park()<br>　　处在这个状态的线程是在等另一个线程做一些特殊的操作。比如Object.wait()方法在等另一个线程调用Object.notify()或者Object.notifyAll()，Thread.join()方法在等一个指定线程完成,即变为TERMINATED状态，当然，LockSupport.park则是在等另一个线程调用LockSupport.unpark方法。<br>　　注意：<br>　　LockSupport.park(Object blocker) 会挂起当前线程，参数blocker是用于设置当前线程的“volatile Object parkBlocker 成员变量”<br>　　parkBlocker 是用于记录线程是被谁阻塞的，可以通过LockSupport.getBlocker()获取到阻塞的对象，用于监控和分析线程用的。<br>　　“阻塞”与“等待”的区别：<br>　　1.“阻塞”状态是等待着获取到一个排他锁，进入“阻塞”状态都是被动的，离开“阻塞”状态是因为其它线程释放了锁，不阻塞了；<br>　　2.“等待”状态是在等待一段时间 或者 唤醒动作的发生，进入“等待”状态是主动的<br>　　如主动调用Object.wait()，如无法获取到ReentraantLock，主动调用LockSupport.park()，如主线程主动调用 subThread.join()，让主线程等待子线程执行完毕再执行<br>离开“等待”状态是因为其它线程发生了唤醒动作或者到达了等待时间</p><h4 id="TIMED-WAITING（限期等待）"><a href="#TIMED-WAITING（限期等待）" class="headerlink" title="TIMED_WAITING（限期等待）"></a>TIMED_WAITING（限期等待）</h4><p>　　处于这种状态的线程也不会被分配CPU执行时间，不过无需等待被其它线程显示的唤醒，在一定时间之后它们会由系统自动的唤醒。<br>以下方法会让线程进入TIMED_WAITING限期等待状态：<br>　　1.Thread.sleep()方法<br>　　2.设置了timeout参数的Object.wait()方法<br>　　3.设置了timeout参数的Thread.join()方法<br>　　4.LockSupport.parkNanos()方法<br>　　5.LockSupport.parkUntil()方法</p><h4 id="TERMINATED（结束）"><a href="#TERMINATED（结束）" class="headerlink" title="TERMINATED（结束）"></a>TERMINATED（结束）</h4><p>　　已终止线程的线程状态，线程已经结束执行。换句话说，run()方法走完了，线程就处于这种状态。其实这只是Java语言级别的一种状态，在操作系统内部可能已经注销了相应的线程，或者将它复用给其他需要使用线程的请求，而在Java语言级别只是通过Java代码看到的线程状态而已。</p><h3 id="线程状态的装换"><a href="#线程状态的装换" class="headerlink" title="线程状态的装换"></a>线程状态的装换</h3><p>　　通过以上对线程状态的了解，我们知道这几个状态在线程执行过程中是有条件转换的。总结如下图：<br><img src="https://raw.githubusercontent.com/seasonfif/picture/master/other/thread-trans-state.png" alt="thread-trans-state|100x0"></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IntentService为何物？</title>
      <link href="/2016/04/21/android/IntentService%E4%B8%BA%E4%BD%95%E7%89%A9%EF%BC%9F/"/>
      <url>/2016/04/21/android/IntentService%E4%B8%BA%E4%BD%95%E7%89%A9%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>　　熟悉Android的人都知道，Androi系统为我们提供了一个专门处理后台耗时任务的组件，即Service。使用它可以很方便的完成一些需要长期执行但是却不需要UI界面的任务，比如音乐播放、同步数据库等等。那么我们今天的主角IntentService到底是何方神圣呢？</p><h3 id="重要点梳理"><a href="#重要点梳理" class="headerlink" title="重要点梳理"></a>重要点梳理</h3><p>　　首先我们来看一下类的签名<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>　　由此可知IntentService其实是一个Service，它继承自Service拥有Service的所有特性，当然青出于蓝而胜于蓝，IntentService比Service强大的地方在哪里呢？接着往下看：</p><h4 id="ServiceHandler"><a href="#ServiceHandler" class="headerlink" title="ServiceHandler"></a>ServiceHandler</h4><p>　　IntentService有一个内部类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>　　可以看到ServiceHandler继承自Handler，实现了它的handleMessage方法，就是说IntentService内部实现了一套线程间发送消息和处理消息的机制。但是它只是处理了特定的事件即stopSelf。大家都知道stopSelf为Service处理完成释放资源的方法。不错，IntentService为我们启动了Service的“自毁”程序。</p><h4 id="onCreate操作"><a href="#onCreate操作" class="headerlink" title="onCreate操作"></a>onCreate操作</h4><p>　　既然有了Handler消息的处理，那么是怎么初始化Handler的呢？请看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></span><br><span class="line">        <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></span><br><span class="line">        <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        mServiceLooper = thread.getLooper();</span><br><span class="line">        mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>　　在这个onCreate方法中初始化了一个HandlerThread，此处如果不理解HandlerThread是什么，可以简单理解为一个自带Handler功能的Thread，是的，它就是一个线程。这里通过实例化HandlerThread新建线程并启动，所以使用IntentService时不需要额外新建线程，并且拿到工作线程的Looper维护自己的工作队列，最后将Looper与新建的ServiceHandler绑定由其分发处理事件。<br>　　由于onCreate()方法只会调用一次，所以只会创建一个工作线程；当多次调用 startService(Intent) 时（onStartCommand也会调用多次）其实并不会创建新的工作线程，只是把消息加入消息队列中等待执行，所以，多次启动 IntentService 会按顺序执行事件。</p><h4 id="onCreate操作-1"><a href="#onCreate操作-1" class="headerlink" title="onCreate操作"></a>onCreate操作</h4><p>　　处理消息、以及Handler都准备好了，那么我们的消息到底是在什么时候添加的呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>　　从这里我们就能知道，每当启动一个IntentService时会把intent包装到message的obj中，然后发送消息，即添加到消息队列里。最后在消息处理的时候拿出这个intent作为事件处理的参数。参见ServiceHandler的handleMessage方法。</p><h4 id="Redelivery"><a href="#Redelivery" class="headerlink" title="Redelivery"></a>Redelivery</h4><p>　　除此之外IntentService还额外附赠了一个setIntentRedelivery方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets intent redelivery preferences.  Usually called from the constructor</span></span><br><span class="line"><span class="comment">     * with your preferred semantics.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If enabled is true,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #onStartCommand(Intent, int, int)&#125; will return</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Service#START_REDELIVER_INTENT&#125;, so if this process dies before</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #onHandleIntent(Intent)&#125; returns, the process will be restarted</span></span><br><span class="line"><span class="comment">     * and the intent redelivered.  If multiple Intents have been sent, only</span></span><br><span class="line"><span class="comment">     * the most recent one is guaranteed to be redelivered.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If enabled is false (the default),</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #onStartCommand(Intent, int, int)&#125; will return</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Service#START_NOT_STICKY&#125;, and if the process dies, the Intent</span></span><br><span class="line"><span class="comment">     * dies along with it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntentRedelivery</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        mRedelivery = enabled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>　　在源码中我们可以发现，该方法改变了boolean变量mRedelivery的值，而mRedelivery得值关系到onStartCommand的返回变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * You should not override this method for your IntentService. Instead,</span></span><br><span class="line"><span class="comment">     * override &#123;<span class="doctag">@link</span> #onHandleIntent&#125;, which the system calls when the IntentService</span></span><br><span class="line"><span class="comment">     * receives a start request.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> android.app.Service#onStartCommand</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        onStart(intent, startId);</span><br><span class="line">        <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>　　可以看到，mRedelivery不同，会返回两个不同的标志START_REDELIVER_INTENT 和START_NOT_STICKY，那么他们有什么不同呢？<br>　　区别就在于如果系统在服务完成之前关闭它，则两种类型就表现出不同了：<br>　　START_NOT_STICKY型服务会直接被关闭，而START_REDELIVER_INTENT 型服务会在可用资源不再吃紧的时候尝试再次启动服务。由此我们可以发现，当我们的操作不是十分重要的时候，我们可以选择START_NOT_STICKY，这也是IntentService的默认选项，当我们认为操作十分重要时，则应该选择START_REDELIVER_INTENT 型服务。</p><h3 id="与Service的异同"><a href="#与Service的异同" class="headerlink" title="与Service的异同"></a>与Service的异同</h3><p>　　1、Service任务默认执行于应用程序的主线程，而IntentService会创建一个工作线程来处理任务<br>　　2、Service需要主动调用stopSelft()来结束服务，而IntentService不需要（在所有intent被处理完后，系统会自动关闭服务）<br>　　3、此外：<br>　　　　IntentService为Service的onBingd()方式提供了默认实现：返回null<br>　　　　IntentService为Service的onStartCommand（）方法提供了默认实现：将请求的intent添加到队列中</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>由于IntentService为抽象类，因此我们在使用时必须继承它并实现它的onHandleIntent方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.IntentService;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造函数参数为工作线程的名字</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"myIntentService"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现耗时任务的操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据Intent的不同进行不同的事务处理</span></span><br><span class="line">        String taskName = intent.getExtras().getString(<span class="string">"taskName"</span>);</span><br><span class="line">        <span class="keyword">switch</span> (taskName) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"task1"</span>:</span><br><span class="line">                <span class="comment">//do something</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"task2"</span>:</span><br><span class="line">                <span class="comment">//do something</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认实现将请求的Intent添加到工作队列里</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到很简单的继承只需要实现自己的onHandleIntent方法就可以了，然后使用它也很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同一服务只会开启一个工作线程</span></span><br><span class="line"><span class="comment">//在onHandleIntent函数里依次处理intent请求。</span></span><br><span class="line">Intent i = <span class="keyword">new</span> Intent(<span class="string">"balabala"</span>);</span><br><span class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">bundle.putString(<span class="string">"taskName"</span>, <span class="string">"task1"</span>);</span><br><span class="line">i.putExtras(bundle);</span><br><span class="line">startService(i);</span><br><span class="line"></span><br><span class="line">Intent i2 = <span class="keyword">new</span> Intent(<span class="string">"balabala"</span>);</span><br><span class="line">Bundle bundle2 = <span class="keyword">new</span> Bundle();</span><br><span class="line">bundle2.putString(<span class="string">"taskName"</span>, <span class="string">"task2"</span>);</span><br><span class="line">i2.putExtras(bundle2);</span><br><span class="line">startService(i2);</span><br><span class="line"></span><br><span class="line">startService(i);  <span class="comment">//多次启动，会将i再次加入到消息队列，处理，然后分发结果</span></span><br></pre></td></tr></table></figure></p><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>　　IntentService中，onBind()是默认返回null的，而采用bindService() 启动 IntentService的生命周期是：onCreate()—&gt;onBind()—&gt;onunbind()—&gt;onDestory()，并不会调用onstart()或者onstartcommand()方法，所以不会将消息发送到消息队列，那么onHandleIntent()将不会回调，即无法实现多线程的操作。切记!</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解Java8之后的HashMap</title>
      <link href="/2016/04/09/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java8%E4%B9%8B%E5%90%8E%E7%9A%84HashMap/"/>
      <url>/2016/04/09/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java8%E4%B9%8B%E5%90%8E%E7%9A%84HashMap/</url>
      <content type="html"><![CDATA[<p>　　HashMap的存储结构如图：一个桶（bucket）上的节点多于8个则存储结构是红黑树，小于8个是单向链表。<br><img src="https://raw.githubusercontent.com/seasonfif/picture/master/other/hashmap-java8.jpg" alt="hashmap"><br>　　jdk8之前一直是链表，链表查询的复杂度是O(n)而红黑树由于其自身的特点，查询的复杂度是O(log(n))。如果hash的结果不均匀会极大影响操作的复杂度。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git文件系统</title>
      <link href="/2015/10/21/git/git%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2015/10/21/git/git%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<h3 id="Git的基本原理"><a href="#Git的基本原理" class="headerlink" title="Git的基本原理"></a>Git的基本原理</h3><p>　　本质上，Git是一套内容寻址（content-addressable）文件系统，而和我们直接接触的Git界面，只不过是封装在其之上的一个应用层。这个关系颇有点类似于计算机网络中应用层和下属层的关系。在Git中，那些和应用层相关的命令（也就是我们最常用的命令，如git commit、 git push等），我们称之为porcelain命令（瓷器之意，意为成品、高级命令）；而和底层相关的命令（几乎不会在日常中使用，如git hash-object、git update-index等），则称之为plumbing命令（管道之意，是连接git应用界面和git底层实现的一个管道，类似于shell，底层命令）。要了解Git的底层原理，就需要了解Git是如何利用底层命令来实现高层命令的。在此之前，让我们先来看一下Git的目录结构，和各个文件在Git中的作用。</p><h3 id="Git的目录结构"><a href="#Git的目录结构" class="headerlink" title="Git的目录结构"></a>Git的目录结构</h3><p>　　在操作系统中，我们的仓库就是一个文件夹。但是为什么这些文件夹就是Git仓库呢？这是因为Git在初始化的时候会生成一个.git的文件夹，而Git进行版本控制所需要的文件，则都放在这个文件夹中。在桌面上新建一个目录，然后利用命令行在该目录下运行git init命令即可完成git仓库的初始化。如果这个时候你看不到.git目录，这是因为你的操作系统自动隐藏了该文件夹，需要在系统设置中设置隐藏文件可见。进入.git目录，便可以看到其中有很多的文件和文件夹，这每一个文件都有各自的作用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls .git</span><br><span class="line">COMMIT_EDITMSG  description  HEAD   index  logs     ORIG_HEAD    refs</span><br><span class="line">config          FETCH_HEAD   hooks  info   objects  packed-refs</span><br></pre></td></tr></table></figure></p><p>核心文件包括：config文件、objects文件夹、HEAD文件、index文件以及refs文件夹。下面依次对其进行说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config文件：该文件主要记录针对该项目的一些配置信息，例如是否以bare方式初始化、remote的信息等，通过git remote add命令增加的远程分支的信息就保存在这里；</span><br><span class="line">objects文件夹：该文件夹主要包含git对象。关于什么是git对象，将会在下一节进行详细介绍。Git中的文件和一些操作都会以git对象来保存，git对象分为BLOB、tree和commit三种类型，例如git commit便是git中的commit对象，而各个版本之间是通过版本树来组织的，比如当前的HEAD会指向某个commit对象，而该commit对象又会指向几个BLOB对象或者tree对象。objects文件夹中会包含很多的子文件夹，其中Git对象保存在以其sha-1值的前两位为子文件夹、后38位位文件名的文件中；除此以外，Git为了节省存储对象所占用的磁盘空间，会定期对Git对象进行压缩和打包，其中pack文件夹用于存储打包压缩的对象，而info文件夹用于从打包的文件中查找git对象；</span><br><span class="line">HEAD文件：该文件指明了git branch（即当前分支）的结果，比如当前分支是master，则该文件就会指向master，但是并不是存储一个master字符串，而是分支在refs中的表示，例如ref: refs/heads/master。</span><br><span class="line">index文件：该文件保存了暂存区域的信息。该文件某种程度就是缓冲区（staging area），内容包括它指向的文件的时间戳、文件名、sha1值等；</span><br><span class="line">Refs文件夹：该文件夹存储指向数据（分支）的提交对象的指针。其中heads文件夹存储本地每一个分支最近一次commit的sha-1值（也就是commit对象的sha-1值），每个分支一个文件；remotes文件夹则记录你最后一次和每一个远程仓库的通信，Git会把你最后一次推送到这个remote的每个分支的值都记录在这个文件夹中；tag文件夹则是分支的别名，这里不需要对其有过多的了解；</span><br></pre></td></tr></table></figure><p>　　除此以外，.git目录下还有很多其他的文件和文件夹，这些文件和文件夹会额外支撑一些其他的功能，但是不是Git的核心部分，因此稍作了解即可。hooks主要定义了客户端或服务端钩子脚本，这些脚本主要用于在特定的命令和操作之前或者之后进行特定的处理，比如：当你把本地仓库push到服务器的远程仓库时，可以在服务器仓库的hooks文件夹下定义post_update脚本，在该脚本中可以通过脚本代码将最新的代码部署到服务器的web服务器上，从而将版本控制和代码发布无缝连接起来；description文件仅供GitWeb程序使用，这里不需要过多的关心；logs则记录了本地仓库和远程仓库的每一个分支的提交记录，即所有的commit对象（包括时间、作者等信息）都会被记录在这个文件夹中，因此这个文件夹中的内容是我们查看最频繁的，不管是Git log命令还是tortoiseGit的show log，都需要从该文件夹中获取提交日志；info文件夹保存了一份不希望在.gitignore 文件中管理的忽略模式的全局可执行文件，基本也用不上；COMMIT_EDITMSG文件则记录了最后一次提交时的注释信息。从以上的描述中我们可以发现，.git文件夹中包含了众多功能不一的文件夹和文件，这些文件夹和文件是描述Git仓库所必不可少的信息，不可以随意更改或删除；尤其需要注意的是，.git文件夹随着项目的演进，可能会变得越来越大，因为任何文件的任何一个变动，都需要Git在objects文件夹下将其重新存储为一个新的对象文件，因此如果一个文件非常大，那么你提交几次改动就会造成.git文件夹容量成倍增长。因此，.git文件夹更像是一本书，每一个版本的每一个变动都存储在这本书中，而且这本书还有一个目录，指明了不同的版本的变动内容存储在这本书的哪一页上，这就是Git的最基本的原理。</p><h3 id="Git对象"><a href="#Git对象" class="headerlink" title="Git对象"></a>Git对象</h3><p>　　之前提到过，Git是一套内容寻址（content-addressable）文件系统，那么Git是怎么进行寻址呢？其实，寻址无非就是查找，而Git采用HashTable的方式进行查找，也就是说，Git只是通过简单的存储键值对（key-value pair）的方式来实现内容寻址的，而key就是文件（头+内容）的哈希值（采用sha-1的方式，40位），value就是经过压缩后的文件内容。因此，在接下来的实践中，我们会经常通过40位的hash值来进行plumbing操作，几乎每一个plumbing命令都需要通过key来指定所要操作的对象。<br>　　Git对象的类型包括：BLOB、tree对象、commit对象。BLOB对象可以存储几乎所有的文件类型，全称为binary large object，顾名思义，就是大的二进制表示的对象，这种对象类型和数据库中的BLOB类型（经常用来在数据库中存储图片、视频等）是一样的，当作一种数据类型即可；tree对象是用来组织BLOB对象的一种数据类型，你完全可以把它想象成二叉树中的树节点，只不过Git中的树不是二叉树，而是”多叉树”；commit对象表示每一次的提交操作，由tree对象衍生，每一个commit对象表示一次提交，在创建的过程中可以指定该commit对象的父节点，这样所有的commit操作便可以连接在一起，而这些commit对象便组成了提交树，branch只不过是这个树中的某一个子树罢了。如果你能理解commit树，那Git几乎就已经理解了一半了。<br>　　Git对象的存储方式也很简单，基本可以用如下表达式来表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Key = sha1(file_header + file_content)</span><br><span class="line"></span><br><span class="line">Value = zlib(file_content)</span><br></pre></td></tr></table></figure></p><p>　　简单来说，Git 将文件头与原始数据内容拼接起来，并计算拼接后的新内容的 40位的sha-1校验和，将该校验和的前2位作为object目录中的子目录的名称，后38位作为子目录中的文件名；然后，Git 用zlib的方式对数据内容进行压缩，最后将用 zlib 压缩后的内容写入磁盘。文件头的格式为 “blob #{content.length}\0”，例如”blob 16\000”，这种文件头格式也是经常采用的格式。对于tree对象和commit对象，文件头的格式都是一样的，但是其文件数据却是有固定格式的，鉴于本次只是Git原理的基本介绍，这里不再详细描述，有兴趣的可以去Git的官网查找相关文档进行了解；其实也可以自己按照理解构思一下，如果让你来设计这种格式，应该如何设计：tree对象类似于树中节点的定义，在tree对象中要包含对连接的BLOB对象的引用，而commit对象与tree对象类似，要包含提交的tree对象的引用。</p><h3 id="对象暂存区"><a href="#对象暂存区" class="headerlink" title="对象暂存区"></a>对象暂存区</h3><p>　　在procelain命令中，为了将修改的文件加入暂存区（也叫索引库，将修改的文件key-value化，.git根目录下的index文件记录该暂存区中的文件索引），我们会使用git add filename命令。那么在git add这个命令的背后，Git是如何使用plumbing命令来完成文件的索引操作呢？其实，git add命令对应着两个基本的plumbing命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git hash-object #获取指定文件的key，如果带上-w选项，则会将该对象的value进行存储</span><br><span class="line"></span><br><span class="line">git update-index #将指定的object加入索引库，需要带上—add选项</span><br></pre></td></tr></table></figure></p><p>　　因此，git add命令在plumbing命令中其实是分成了两步：首先，通过hash-object命令将需要暂存的文件进行key-value化转换成Git对象，并进行存储，拿到这些文件的key；然后，通过update-index命令将这些对象加入到索引库进行暂存，这样便完成了Git文件的暂存操作。</p><h3 id="创建树节点"><a href="#创建树节点" class="headerlink" title="创建树节点"></a>创建树节点</h3><p>　　在Git中，所有的内容以tree或者BLOB对象进行存储，如果把Git比作UNIX的文件系统，则tree对象对应于UNIX文件系统中的目录，而BLOB对象则对应于inodes或文件内容。在Git对象小节中，我们大致猜想了tree对象的存储格式。其实，一个单独的tree对象包含一条或多条tree记录，每一条记录含有一个指向BLOB对象或子tree对象的sha-1指针（也就是一个40位的key值），并附有该对象的权限模式 、类型和文件名信息，因此，我们的猜想也是八九不离十的。为什么要创建tree对象呢？我们都知道，在Git中，我们add完已修改的文件之后，一般就直接commit暂存区中的内容到本地仓库了，似乎并没有tree这个概念。其实，创建tree对象只是add和commit中间的一个缓冲步骤，因为commit对象要根据tree对象来创建。那么如何创建tree对象呢？只需要如下命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git write-tree #根据索引库中的信息创建tree对象</span><br></pre></td></tr></table></figure></p><p>　　实际上，由于index暂存区包括了项目仓库中所有的文件，因此commit对象所对应的tree对象，永远都是工作目录的根tree对象。也就是说，每次commit，都是把工作目录的根目录所对应的tree对象，链接给此次的commit对象；而且，在Git中，每个子目录都对应一个tree对象，每个文件对应一个BLOB对象，因此整个工作目录对应一棵Git对象树，根节点就是commit对象所引用的tree节点，而每个子文件夹又分别对应一棵子树。所以任何一个文件的更改，都会导致其上层所有父对象的更改和重新存储。这里不再进行演示，你可以通过git add和git commit进行多次提交，并在每次提交之后使用git log查看commit对象的key，使用cat-file获取对应的tree对象的key，并再次使用cat-file获取该tree对象下所有的子对象，这时你可以发现，子文件夹都对应一个tree节点，文件都对应一个BLOB节点。</p><h3 id="Commit对象"><a href="#Commit对象" class="headerlink" title="Commit对象"></a>Commit对象</h3><p>　　在Git中，每一次commit都对应一个commit对象，而一个commit对象对应一个tree对象。为了创建commit对象，需要使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit-tree key –p key2 #根据tree对象创建commit对象，-p表示前继commit对象</span><br></pre></td></tr></table></figure></p><p>　　该方法有点类似于数据结构中树的增加节点操作：都是向父节点中增加子节点。其中，-p选项指明了前继commit对象的key值，也就是父节点的key值，这样，这两个commit节点便连接在了一起，而不断的连接便构成了一棵树，也就是我们接下来要讲的提交树。<br>　　在该命令中，我们只需要指定key的前六位即可，由于这是第一次提交，因此不需要带上-p选项来指明父节点。通过cat-file命令可以看到，commit对象已创建成功，该commit对象中包含了与之关联的tree对象的key值，以及author和committer的信息。如果要查看完整的提交记录，可以通过git log –stat key命令，该命令会打印指定commit对象之前的所有提交记录。至此，commit对象已经创建完成，而我们也利用plumbing命令，完整的实现了Git的add和commit操作。</p>]]></content>
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>git常用命令</title>
      <link href="/2015/10/19/git/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2015/10/19/git/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>　　Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目，刚开始是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件，由于其灵活的授权目前已经在很多自由软件项目中广泛使用。</p><h3 id="Git创建仓库"><a href="#Git创建仓库" class="headerlink" title="Git创建仓库"></a>Git创建仓库</h3><h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h4><p>　　Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。<br>使用当前目录作为Git仓库，我们只需使它初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></p><p>该命令执行完后会在当前目录生成一个 .git 目录。</p><p>使用我们指定目录作为Git仓库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init repo-path</span><br></pre></td></tr></table></figure></p><p>初始化后，会在repo-path目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m &apos;初始化项目版本&apos;</span><br></pre></td></tr></table></figure></p><p>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p><h4 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h4><p>　　使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。克隆仓库的命令格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt;</span><br></pre></td></tr></table></figure></p><p>如果我们需要克隆到指定的目录，可以使用以下命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt; &lt;directory&gt;</span><br><span class="line">参数说明：</span><br><span class="line">    repo:Git 仓库。</span><br><span class="line">    directory:本地目录。</span><br></pre></td></tr></table></figure></p><h3 id="Git内容操作"><a href="#Git内容操作" class="headerlink" title="Git内容操作"></a>Git内容操作</h3><h4 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h4><p>git add 命令可将该文件添加到缓存，如我们添加以下两个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ touch README</span><br><span class="line">$ touch hello.java</span><br><span class="line">$ ls</span><br><span class="line">README        hello.java</span><br><span class="line">$ git status -s</span><br><span class="line">?? README</span><br><span class="line">?? hello.java</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><p>git status 命令用于查看项目的当前状态。<br>接下来我们执行 git add 命令来添加文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add README hello.php</span><br></pre></td></tr></table></figure></p><p>现在我们再执行 git status，就可以看到这两个文件已经加上去了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">A  README</span><br><span class="line">A  hello.java</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h4><p>git status 以查看在你上次提交之后是否有修改。<br>-s 参数，以简短的结果输出。如果没加该参数会详细输出内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    new file:   hello.java</span><br></pre></td></tr></table></figure></p><h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4><p>git diff 来查看执行 git status 的结果的详细信息。<br>git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。<br>    尚未缓存的改动：git diff<br>    查看已缓存的改动： git diff –cached<br>    查看已缓存的与未缓存的所有改动：git diff HEAD<br>    显示摘要而非整个 diff：git diff –stat</p><h4 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h4><p>使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。<br>Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &apos;seasonfif&apos;</span><br><span class="line">$ git config --global user.email xxx@gmail.com</span><br></pre></td></tr></table></figure></p><p>接下来我们写入缓存，并提交对 hello.java 的所有改动。在首个例子中，我们使用 -m 选项以在命令行中提供提交注释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git add hello.java</span><br><span class="line">$ git status -s</span><br><span class="line">A  README</span><br><span class="line">A  hello.java</span><br><span class="line">$ $ git commit -m &apos;第一次版本提交&apos;</span><br><span class="line">[master (root-commit) d32cf1f] 第一次版本提交</span><br><span class="line"> 2 files changed, 4 insertions(+)</span><br><span class="line"> create mode 100644 README</span><br><span class="line"> create mode 100644 hello.java</span><br></pre></td></tr></table></figure></p><p>现在我们已经记录了快照。如果我们再执行 git status:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure></p><p>以上输出说明我们在最近一次提交之后，没有做任何改动，是一个”working directory clean：干净的工作目录”。<br>如果你没有设置 -m 选项，Git 会尝试为你打开一个编辑器以填写提交信息。 如果 Git 在你对它的配置中找不到相关信息，默认会打开 vim。屏幕会像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &apos;#&apos; will be ignored, and an empty message aborts the commit.</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line"># modified:   hello.php</span><br><span class="line">#</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">&quot;.git/COMMIT_EDITMSG&quot; 9L, 257C</span><br></pre></td></tr></table></figure></p><p>如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。命令格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am &apos;message&apos;</span><br></pre></td></tr></table></figure><h4 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h4><p>如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。<br>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;file&gt;</span><br></pre></td></tr></table></figure></p><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -f &lt;file&gt;</span><br></pre></td></tr></table></figure></p><p>如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 –cached 选项即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached &lt;file&gt;</span><br></pre></td></tr></table></figure></p><p>可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm –r *</span><br></pre></td></tr></table></figure></p><h4 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h4><p>git mv 命令用于移动或重命名一个文件、目录、软连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git mv README  README.md</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure></p><h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h4><p>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 14b4dcadbdc847207651d5a9fae0d315057f346e</span><br><span class="line">Author: seasonfif &lt;xxx@gmail.com&gt;</span><br><span class="line">Date:   Sun Mar 1 14:53:15 2015 +0800</span><br><span class="line"></span><br><span class="line">    新增加一行</span><br></pre></td></tr></table></figure></p><p>我们可以用 –oneline 选项来查看历史记录的简洁的版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline</span><br><span class="line">88afe0e Merge branch &apos;change_site&apos;</span><br><span class="line">14b4dca 新增加一行</span><br><span class="line">d7e7346 changed the site</span><br><span class="line">556f0a0 removed test2.txt</span><br><span class="line">2e082b7 add test2.txt</span><br><span class="line">048598f add test.txt</span><br></pre></td></tr></table></figure></p><p>这告诉我们的是，此项目的开发历史。<br>我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --graph</span><br><span class="line">*   88afe0e Merge branch &apos;change_site&apos;</span><br><span class="line">|\  </span><br><span class="line">| * d7e7346 changed the site</span><br><span class="line">* | 14b4dca 新增加一行</span><br><span class="line">|/  </span><br><span class="line">* 556f0a0 removed test2.txt</span><br><span class="line">* 2e082b7 add test2.txt</span><br><span class="line">* 048598f add test.txt</span><br></pre></td></tr></table></figure></p><p>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。<br>也可以用 ‘–reverse’参数来逆向显示所有日志。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --reverse --oneline</span><br><span class="line">048598f add test.txt</span><br><span class="line">2e082b7 add test2.txt</span><br><span class="line">556f0a0 removed test2.txt</span><br><span class="line">d7e7346 changed the site</span><br><span class="line">14b4dca 新增加一行</span><br><span class="line">88afe0e Merge branch &apos;change_site&apos;</span><br></pre></td></tr></table></figure></p><p>如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --author=Linus --oneline -5</span><br><span class="line">81b50f3 Move &apos;builtin-*&apos; into a &apos;builtin/&apos; subdirectory</span><br><span class="line">3bb7256 make &quot;index-pack&quot; a built-in</span><br><span class="line">377d027 make &quot;git pack-redundant&quot; a built-in</span><br><span class="line">b532581 make &quot;git unpack-file&quot; a built-in</span><br><span class="line">112dd51 make &quot;mktag&quot; a built-in</span><br></pre></td></tr></table></figure></p><p>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。<br>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges</span><br><span class="line">5469e2d Git 1.7.1-rc2</span><br><span class="line">d43427d Documentation/remote-helpers: Fix typos and improve language</span><br><span class="line">272a36b Fixup: Second argument may be any arbitrary string</span><br><span class="line">b6c8d2d Documentation/remote-helpers: Add invocation section</span><br><span class="line">5ce4f4e Documentation/urls: Rewrite to accomodate transport::address</span><br><span class="line">00b84e9 Documentation/remote-helpers: Rewrite description</span><br><span class="line">03aa87e Documentation: Describe other situations where -z affects git diff</span><br><span class="line">77bc694 rebase-interactive: silence warning when no commits rewritten</span><br><span class="line">636db2c t3301: add tests to use --format=&quot;%N&quot;</span><br></pre></td></tr></table></figure></p><h3 id="Git标签管理"><a href="#Git标签管理" class="headerlink" title="Git标签管理"></a>Git标签管理</h3><p>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。</p><p>比如说，我们想为我们的项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。</p><p>-a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。<br>创建带注解的标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.0</span><br></pre></td></tr></table></figure></p><p>当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p><p>现在，注意当我们执行 git log –decorate 时，我们可以看到我们的标签了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --decorate --graph</span><br><span class="line">*   88afe0e (HEAD, tag: v1.0, master) Merge branch &apos;change_site&apos;</span><br><span class="line">|\  </span><br><span class="line">| * d7e7346 (change_site) changed the site</span><br><span class="line">* | 14b4dca 新增加一行</span><br><span class="line">|/  </span><br><span class="line">* 556f0a0 removed test2.txt</span><br><span class="line">* 2e082b7 add test2.txt</span><br><span class="line">* 048598f add test.txt</span><br></pre></td></tr></table></figure></p><p>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。<br>例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.9 85fc7e7</span><br><span class="line">$ git log --oneline --decorate --graph</span><br><span class="line">*   88afe0e (HEAD, tag: v1.0, master) Merge branch &apos;change_site&apos;</span><br><span class="line">|\  </span><br><span class="line">| * d7e7346 (change_site) changed the site</span><br><span class="line">* | 14b4dca 新增加一行</span><br><span class="line">|/  </span><br><span class="line">* 556f0a0 removed test2.txt</span><br><span class="line">* 2e082b7 add test2.txt</span><br><span class="line">* 048598f add test.txt</span><br></pre></td></tr></table></figure></p><p>如果我们要查看所有标签可以使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure></p><p>指定标签信息命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;tagname&gt; -m &quot;标签&quot;</span><br></pre></td></tr></table></figure></p><p>PGP签名标签命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -s &lt;tagname&gt; -m &quot;标签&quot;</span><br></pre></td></tr></table></figure></p><p>删除标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v1.1</span><br><span class="line">Deleted tag ‘v1.1’ (was 91388f0)</span><br></pre></td></tr></table></figure></p><p>查看此tag的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show v1.0</span><br></pre></td></tr></table></figure></p><h3 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h3><p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。Git 的分支模型是最具优势的特性 ，而正是因为它，将 Git 从版本控制系统家族里区分出来。</p><h4 id="列出分支"><a href="#列出分支" class="headerlink" title="列出分支"></a>列出分支</h4><p>列出分支基本命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></p><p>没有参数时，git branch 会列出你在本地的分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></p><p>此例的意思就是，我们有一个叫做”master”的分支，并且该分支是当前分支。</p><p>当你执行 git init 的时候，缺省情况下 Git 就会为你创建”master”分支。</p><p>如果我们要手动创建一个分支。执行 git branch (branchname) 即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch testing</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure></p><p>在我们可以看到，有了一个新分支 testing。</p><p>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了”testing”分支，Git 将还原你的工作目录到你创建分支时候的样子</p><p>使用 git checkout (branch) 切换到我们要修改的分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout testing</span><br><span class="line">Switched to branch &apos;testing&apos;</span><br></pre></td></tr></table></figure></p><p>我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b newtest</span><br><span class="line">Switched to a new branch &apos;newtest&apos;</span><br></pre></td></tr></table></figure></p><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><p>删除分支命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d (branchname)</span><br></pre></td></tr></table></figure></p><p>例如我们要删除”testing”分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br><span class="line">$ git branch -d testing</span><br><span class="line">Deleted branch testing (was 85fc7e7).</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></p><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  newtest</span><br><span class="line">$ ls</span><br><span class="line">README        test.txt    test2.txt</span><br><span class="line">$ git merge newtest</span><br><span class="line">Updating 2e082b7..556f0a0</span><br><span class="line">Fast-forward</span><br><span class="line"> test2.txt | 1 -</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test2.txt</span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>深入理解ConcurrentHashMap</title>
      <link href="/2015/07/25/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ConcurrentHashMap/"/>
      <url>/2015/07/25/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ConcurrentHashMap/</url>
      <content type="html"><![CDATA[<h3 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h3><p>　　ConcurrentHashMap是一种线程安全的HashMap。它是基于分段锁技术的Map实现类，即对分段加锁同步以期在多线程环境下快速达到插入数据的一致性，因此只有在同一个分段内才存在竞态关系，不同的分段锁之间没有锁竞争。相比于对整个Map加锁的设计，分段锁大大的提高了高并发环境下的处理能力。但同时，由于不是对整个Map加锁，导致一些需要扫描整个Map的方法（如size(), containsValue()）需要使用特殊的实现，另外一些方法（如get()、clear()）甚至放弃了对一致性的要求，因此ConcurrentHashMap是弱一致性的。<br>　　ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。ConcurrentHashMap中的HashEntry相对于HashMap中的Entry有一定的差异性：HashEntry中的value以及next都被volatile修饰，这样在多线程读写过程中能够保持它们的可见性，从如下源码片段可有个大概了解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure></p><p>　　与HashMap不同的是，ConcurrentHashMap并不允许key或者value为null，按照作者Doug Lea的说法，这么设计的原因是因为在ConcurrentHashMap中，一旦value出现null，则代表HashEntry的key/value没有映射完成就被其他线程所见，而并不只是简单的空值而已。<br>Doug Lea为util.concurrent包的作者。<br><img src="https://raw.githubusercontent.com/seasonfif/picture/master/other/DougLea.jpg" alt="Doug Lea"></p><h3 id="Unsafe与CAS"><a href="#Unsafe与CAS" class="headerlink" title="Unsafe与CAS"></a>Unsafe与CAS</h3><p>　　在ConcurrentHashMap中，随处可以看到U, 大量使用了U.compareAndSwapXXX的方法，这个方法是利用一个CAS算法实现无锁化的修改值的操作，他可以大大降低锁代理的性能消耗。这个算法的基本思想就是不断地去比较当前内存中的变量值与你指定的一个变量值是否相等，如果相等，则接受你指定的修改的值，否则拒绝你的操作。因为当前线程中的值已经不是最新的值，你的修改很可能会覆盖掉其他线程修改的结果。<br>　　Unsafe代码块控制了一些属性的修改工作，比如最常用的SIZECTL 。在ConcurrentHashMap中，大量应用了CAS方法进行变量、属性的修改工作。利用CAS进行无锁操作，可以大大提高性能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SIZECTL;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TRANSFERINDEX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASECOUNT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLSBUSY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLVALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ABASE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SIZECTL = U.objectFieldOffset</span><br><span class="line">                (ConcurrentHashMap.class.getDeclaredField(<span class="string">"sizeCtl"</span>));</span><br><span class="line">            TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">                (ConcurrentHashMap.class.getDeclaredField(<span class="string">"transferIndex"</span>));</span><br><span class="line">            BASECOUNT = U.objectFieldOffset</span><br><span class="line">                (ConcurrentHashMap.class.getDeclaredField(<span class="string">"baseCount"</span>));</span><br><span class="line">            CELLSBUSY = U.objectFieldOffset</span><br><span class="line">                (ConcurrentHashMap.class.getDeclaredField(<span class="string">"cellsBusy"</span>));</span><br><span class="line"></span><br><span class="line">            CELLVALUE = U.objectFieldOffset</span><br><span class="line">                (CounterCell.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line"></span><br><span class="line">            ABASE = U.arrayBaseOffset(Node[].class);</span><br><span class="line">            <span class="keyword">int</span> scale = U.arrayIndexScale(Node[].class);</span><br><span class="line">            <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"array index scale not a power of two"</span>);</span><br><span class="line">            ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reduce the risk of rare disastrous classloading in first call to</span></span><br><span class="line">        <span class="comment">// LockSupport.park: https://bugs.openjdk.java.net/browse/JDK-8074773</span></span><br><span class="line">        Class&lt;?&gt; ensureLoaded = LockSupport.class;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Makdown富文本测试</title>
      <link href="/2015/05/17/other/Makdown%E5%AF%8C%E6%96%87%E6%9C%AC%E6%B5%8B%E8%AF%95/"/>
      <url>/2015/05/17/other/Makdown%E5%AF%8C%E6%96%87%E6%9C%AC%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! </p><p>夜空中最亮的星</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=25706282&auto=0&height=66"><br></iframe><p>Idina Menze和Caleb Hyles激情对唱Let It Go：  </p><iframe height="498" width="510" src="http://player.youku.com/embed/XNjcyMDU4Njg0" frameborder="0" allowfullscreen><br></iframe>  ]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>详解activity启动模式</title>
      <link href="/2015/04/06/android/%E8%AF%A6%E8%A7%A3activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2015/04/06/android/%E8%AF%A6%E8%A7%A3activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>　　一个应用程序当中通常都会包含很多个Activity，每个Activity都是一个具有特定的功能，并且可以让用户进行操作的组件。另外，Activity之间可以相互启动，当前应用的Activity甚至可以去启动其他应用的Activity。<a id="more"></a>比如你的应用希望去发送一封邮件，你就可以定义一个具有”send”动作的Intent，并且传入一些数据，如对方邮箱地址、邮件内容等。这样，如果另外一个应用程序中的某个Activity声明自己是可以响应这种Intent的，那么这个Activity就会被打开。当邮件发送之后，按下返回键仍然还是会回到你的应用程序当中，这让用户看起来好像刚才那个编写邮件的Activity就是你的应用程序当中的一部分。所以说，即使有很多个Activity分别都是来自于不同应用程序的，Android系统仍然可以将它们无缝地结合到一起。那这一切是怎么实现的呢？这就要讲到本文要介绍的Activity任务栈以及Activity启动模式了。</p><h3 id="任务栈是什么"><a href="#任务栈是什么" class="headerlink" title="任务栈是什么"></a>任务栈是什么</h3><p>　　任务栈Task，是一种用来放置Activity实例的容器，他是以栈的形式进行盛放，也就是所谓的先进后出，主要有2个基本操作：压栈和出栈，其所存放的Activity是不支持重新排序的，只能根据压栈和出栈操作更改Activity的顺序。</p><p>　　启动一个Application的时候，系统会为它默认创建一个对应的Task，用来放置根Activity。默认启动Activity会放在同一个Task中，新启动的Activity会被压入启动它的那个Activity的栈中，并且显示它。当用户按下回退键时，这个Activity就会被弹出栈，按下Home键回到桌面，再启动另一个应用，这时候之前那个Task就被移到后台，成为后台任务栈，而刚启动的那个Task就被调到前台，成为前台任务栈，Android系统显示的就是前台任务栈中的Top实例Activity。</p><h3 id="任务栈的作用"><a href="#任务栈的作用" class="headerlink" title="任务栈的作用"></a>任务栈的作用</h3><p>　　以往基于应用（application）的程序开发中，程序具有明确的边界，一个程序就是一个应用，一个应用为了实现功能可以采用开辟新线程甚至新进程来辅助，但是应用与应用之间不能复用资源和功能。而Android引入了基于组件开发的软件架构，虽然我们开发android程序，仍然使用一个apk工程一个Application的开发形式，但是对于Aplication的开发就用到了Activity、service等四大组件，其中的每一个组件，都是可以被跨应用复用的，这就是android的神奇之处。虽然组件可以跨应用被调用，但是一个组件所在的进程必须是在组件所在的Aplication进程中。由于android强化了组件概念，弱化了Aplication的概念，所以在android程序开发中，A应用的A组件想要使用拍照或录像的功能就可以不用去针对Camera类进行开发，直接调用系统自带的摄像头应用（称其B应用）中的组件（称其B组件）就可以了，但是这就引发了一个新问题，A组件运行在A应用中，B组件运行在B应用中，自然都不在同一个进程中，那么从B组件中返回的时候，如何实现正确返回到A组件呢？Task就是来负责实现这个功能的，它是从用户角度来理解应用而建立的一个抽象概念。因为用户所能看到的组件就是Activity，所以Task可以理解为实现一个功能而负责管理所有用到的Activity实例的栈。</p><p>　　栈是一个先进后出的线性表，根据Activity在当前栈结构中的位置，来决定该Activity的状态。正常情况下，当一个Activity启动了另一个Activity的时候，新启动的Activity就会置于任务栈的顶端，并处于活动状态，而启动它的Activity虽然成功身退，但依然保留在任务栈中，处于停止状态，当用户按下返回键或者调用finish()方法时，系统会移除顶部Activity，让后面的Activity恢复活动状态。当然，世界不可能一直这么“和谐”，可以给Activity设置一些“特权”，来打破这种“和谐”的模式，这种特权，就是通过在AndroidManifest文件中的属性andorid:launchMode来设置或者通过Intent的flag来设置的，下面就先介绍下Activity的几种启动模式。</p><h3 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h3><p>　　standard</p><p>　　默认模式，可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。应用场景：绝大多数Activity。</p><p>　　如果以这种方式启动的Activity被跨进程调用，在5.0之前新启动的Activity实例会放入发送Intent的Task的栈的顶部，尽管它们属于不同的程序，这似乎有点费解看起来也不是那么合理，所以在5.0之后，上述情景会创建一个新的Task，新启动的Activity就会放入刚创建的Task中，这样就合理的多了。</p><p>　　singleTop</p><p>　　栈顶复用模式，如果要开启的activity在任务栈的顶部已经存在，就不会创建新的实例，而是调用 onNewIntent() 方法。避免栈顶的activity被重复的创建。应用场景：在通知栏点击收到的通知，然后需要启动一个Activity，这个Activity就可以用singleTop，否则每次点击都会新建一个Activity。当然实际的开发过程中，测试妹纸没准给你提过这样的bug：某个场景下连续快速点击，启动了两个Activity。如果这个时候待启动的Activity使用 singleTop模式也是可以避免这个Bug的。</p><p>　　同standard模式，如果是外部程序启动singleTop的Activity，在Android 5.0之前新创建的Activity会位于调用者的Task中，5.0及以后会放入新的Task中。</p><p>　　singleTask</p><p>　　栈内复用模式， activity只会在任务栈里面存在一个实例。如果要激活的activity，在任务栈里面已经存在，就不会创建新的activity，而是复用这个已经存在的activity，调用 onNewIntent() 方法，并且清空这个activity任务栈上面所有的activity。应用场景：大多数App的主页。对于大部分应用，当我们在主界面点击回退按钮的时候都是退出应用，那么当我们第一次进入主界面之后，主界面位于栈底，以后不管我们打开了多少个Activity，只要我们再次回到主界面，都应该使用将主界面Activity上所有的Activity移除的方式来让主界面Activity处于栈顶，而不是往栈顶新加一个主界面Activity的实例，通过这种方式能够保证退出应用时所有的Activity都能报销毁。<br>在跨应用Intent传递时，如果系统中不存在singleTask Activity的实例，那么将创建一个新的Task，然后创建SingleTask Activity的实例，将其放入新的Task中。</p><p>　　1：假如目前有个任务栈T1中的情况是ABC，这个时候ActivityD以singleTask模式请求启动，其所需要的任务栈正是T1，则系统会直接创建D的实例并将其入栈到T1中。</p><p>　　2：假如DActivity启动所需要的任务栈为T2,由于T2和D的实例均不存在，那么系统会先创建任务栈T2，然后再创建D的实例并将其入栈到T2中。我们可以通过设置Activity的taskAffinity属性来模拟这一场景。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity </span><br><span class="line">android:name=<span class="string">".SingleTaskActivity"</span> </span><br><span class="line">android:label=<span class="string">"singleTask launchMode"</span> </span><br><span class="line">android:launchMode=<span class="string">"singleTask"</span> </span><br><span class="line">android:taskAffinity=<span class="string">""</span>&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></p><p>　　3：如果D所需的任务栈为T3，并且当前任务栈T3的情况为ADBC，根据栈内复用的原则，此时D不会重新创建，系统会把D切换到栈顶并调用其onNewIntent()方法，同时由于singleTask默认具有ClearTop的效果，会导致栈内所有在D上面的Activity全部出栈，于是最终T3的情况为AD。</p><p>　　4：假如目前有两个任务栈，前台任务栈T4的情况为AB,后台任务栈t4里存有CD,假设CD的启动模式均为singleTask，现在由B去启动D,那么整个后台任务都会被切换到前台，这个时候整个栈就变成了ABCD。</p><p>　　5:假如上面的其他条件不变，B启动的是C而不是D,那么整个栈的情况就变成了ABC,因为D在C上面，会被清理出栈。</p><p>　　singleInstance</p><p>　　单一实例模式，整个手机操作系统里面只有一个实例存在。不同的应用去打开这个activity 共享公用的同一个activity。他会运行在自己单独，独立的任务栈里面，并且任务栈里面只有他一个实例存在。应用场景：呼叫来电界面。这种模式的使用情况比较罕见，在Launcher中可能使用。或者你确定你需要使Activity只有一个实例。建议谨慎使用。</p><h3 id="设置Intent的Flag"><a href="#设置Intent的Flag" class="headerlink" title="设置Intent的Flag"></a>设置Intent的Flag</h3><p>　　系统提供了两种方式来设置一个Activity的启动模式，除了在AndroidManifest文件中设置以外，还可以通过Intent的Flag来设置一个Activity的启动模式，下面我们在简单介绍下一些Flag。</p><p>　　FLAG_ACTIVITY_NEW_TASK</p><p>　　使用一个新的Task来启动一个Activity，但启动的每个Activity都讲在一个新的Task中。该Flag通常使用在从Service中启动Activity的场景，由于Service中并不存在Activity栈，所以使用该Flag来创建一个新的Activity栈，并创建新的Activity实例。</p><p>　　FLAG_ACTIVITY_SINGLE_TOP</p><p>　　使用singletop模式启动一个Activity，与指定android：launchMode=“singleTop”效果相同。</p><p>　　FLAG_ACTIVITY_CLEAR_TOP</p><p>　　使用SingleTask模式来启动一个Activity，与指定android：launchMode=“singleTask”效果相同。</p><p>　　FLAG_ACTIVITY_NO_HISTORY</p><p>　　Activity使用这种模式启动Activity，当该Activity启动其他Activity后，该Activity就消失了，不会保留在Activity栈中。</p><p>　　LaunchMode与StartActivityForResult</p><p>　　我们在开发过程中经常会用到StartActivityForResult方法启动一个Activity，然后在onActivityResult()方法中可以接收到上个页面的回传值，但你有可能遇到过拿不到返回值的情况，那有可能是因为Activity的LaunchMode设置为了singleTask。5.0之后，android的LaunchMode与StartActivityForResult的关系发生了一些改变。ActivityStackSupervisor类中的startActivityUncheckedLocked方法在5.0中进行了修改。在5.0之前，当启动一个Activity时，系统将首先检查Activity的launchMode，如果为A页面设置为SingleInstance或者B页面设置为singleTask或者singleInstance,则会在LaunchFlags中加入FLAG_ACTIVITY_NEW_TASK标志，而如果含有FLAG_ACTIVITY_NEW_TASK标志的话，onActivityResult将会立即接收到一个cancle的信息，而5.0之后这个方法做了修改，修改之后即便启动的页面设置launchMode为singleTask或singleInstance，onActivityResult依旧可以正常工作，也就是说无论设置哪种启动方式，StartActivityForResult和onActivityResult()这一组合都是有效的。所以如果你目前正好基于5.0做相关开发，不要忘了向下兼容，这里有个坑请注意避让。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　实际开发过程中如果采用比较合理的Activity启动模式来做好任务栈的管理，可以事半功倍。在launchMode的选择上首先要搞清楚当前的Activity的作用，以及实际使用场景来做出合理选择。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Activity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解HashMap</title>
      <link href="/2015/03/25/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap/"/>
      <url>/2015/03/25/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap/</url>
      <content type="html"><![CDATA[<h2 id="HashMap概览"><a href="#HashMap概览" class="headerlink" title="HashMap概览"></a>HashMap概览</h2><p>　　HashMap是基于哈希表的Map接口实现。哈希表就是一个固定长度的数组，包含有keys，每个key（key可以是字符，字符串，或者是数字，亦或者是什么其他信息等等）都与一个数值（数值一般来说就是0到TableSize-1，TableSize就是哈希表的长度，也就是那个数组的长度）对应。<br>　　Java中的HashMap允许使用 null 值和 null 键。HashMap也不保证存取顺序。它的类簇如下：<br><img src="https://raw.githubusercontent.com/seasonfif/picture/master/other/java.util.map.png" alt="HashMap类簇"><br>　　影响HashMap性能的有两个参数：初始容量(initialCapacity) 和加载因子(loadFactor)。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有两倍的桶数。<br>　　通过HashMap源码我们可以看到它对容量以及加载因子的设定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">     * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></p><h2 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h2><h3 id="hashing的概念"><a href="#hashing的概念" class="headerlink" title="hashing的概念"></a>hashing的概念</h3><p>　　散列法（Hashing）或哈希法是一种将字符组成的字符串转换为固定长度（一般是更短长度）的数值或索引值的方法，称为散列法，也叫哈希法。由于通过更短的哈希值比用原始值进行数据库搜索更快，这种方法一般用来在数据库中建立索引并进行搜索，同时还用在各种解密算法中。<br>　　将哈希值对容量取余就能确定该值位于哪一个桶中。由于java中的HashMap初始容量为16，每次扩容也都是固定的扩大到2倍，因此可以通过一下方法快速定位桶的位置：hash&amp;(capacity-1)。通过源码我们可以看到实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns index for hash code h.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这个方法非常巧妙，它总是通过 h &amp;(table.length -1) 来得到该对象的保存位置——而 HashMap 底层数组的长度总是 2 的 n 次方。当 length 总是 2 的倍数时，h &amp; (length-1) 将是一个非常巧妙的设计：假设 h=5,length=16, 那么 h &amp; length - 1 将得到 5；如果 h=6,length=16, 那么 h &amp; length - 1 将得到 6 ……如果 h=15,length=16, 那么 h &amp; length - 1 将得到 15；但是当 h=16 时 , length=16 时，那么 h &amp; length - 1 将得到 0 了；当 h=17 时 , length=16 时，那么 h &amp; length - 1 将得到 1 了……这样保证计算得到的索引值总是位于 table 数组的索引之内。<br>　　既然是使用hash值来确定元素的位置，那么当两个元素的hash值相同时又该如何操作呢？我们把两个不同元素hash值相同的现象称之为hash冲突或者碰撞。</p><h3 id="HashMap中解决碰撞的方法"><a href="#HashMap中解决碰撞的方法" class="headerlink" title="HashMap中解决碰撞的方法"></a>HashMap中解决碰撞的方法</h3><p>　　HashMap通过“拉链法”来解决哈希冲突，所谓拉链法即是将hash相同的元素使用单链表储存，这样的结构给人的感觉就是每一个bucket上挂着一个链表如下图所示：    </p><p><img src="https://raw.githubusercontent.com/seasonfif/picture/master/other/hashmap_entry.jpg" alt="拉链结构"></p><p>　　为什么会形成这样的结构呢？我们从HashMap源码一探究竟吧！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates new entry.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;</span><br><span class="line">        Object k1 = getKey();</span><br><span class="line">        Object k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            Object v1 = getValue();</span><br><span class="line">            Object v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key==<span class="keyword">null</span>   ? <span class="number">0</span> : key.hashCode()) ^</span><br><span class="line">                (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * This method is invoked whenever the value in an entry is</span></span><br><span class="line"><span class="comment">    * overwritten by an invocation of put(k,v) for a key k that's already</span></span><br><span class="line"><span class="comment">    * in the HashMap.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * This method is invoked whenever the entry is</span></span><br><span class="line"><span class="comment">    * removed from the table.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　从静态内部类Entry的成员变量我们可以很清楚的看到，它具有一个指向下一个节点的对象next，类型即为Entry本身。我们知道HashMap每一个bucket中存放的就是一个Entry，这样就能在遇到碰撞的时候将该值继续保存在next之中存而形成单向链表有效的防止hash冲突。但是在大量冲突之后，HashMap近似相等于链表，查找速度会急剧下降，影响使用性能。</p><h3 id="equals-和hashCode-的应用"><a href="#equals-和hashCode-的应用" class="headerlink" title="equals()和hashCode()的应用"></a>equals()和hashCode()的应用</h3><p>　　hashCode()和equals()方法在HashMap的get与put方法有比较关键的使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将“key-value”添加到HashMap中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取key对应的value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">            e != <span class="keyword">null</span>;</span><br><span class="line">            e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　根据上面put方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该key的hashCode()决定该Entry的存储位置：如果两个Entry的key的hashCode()返回值相同，那它们的存储位置相同。如果这两个Entry的key通过equals比较返回true，新添加Entry的value将覆盖集合中原有Entry的value，但key不会覆盖。如果这两个Entry的key通过equals比较返回false，新添加的Entry将与集合中原有Entry形成Entry链，而且新添加的Entry位于Entry链的头部。<br>　　根据get方法的源码可以看出，当从HashMap中取元素时，第一步还是根据该key的hashCode()决定该Entry的存储位置，然后遍历该entry链表直到找到目标元素。</p><h3 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h3><p>　　向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素；当然java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组；就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。<br>　　当HashMap里的元素个数(size)大于一个阈值(threshold)时，map将自动扩容，容量扩大到原来的2倍；以默认值为例，阈值=16*0.75=12，当元素个数大于12时就要扩容；loadFactor过大时，map内的数组使用率高了，内部极有可能形成Entry链，影响查找速度；loadFactor过小时，map内的数组使用率旧低，不过内部不会生成Entry链，或者生成的Entry链很短，由此提高了查找速度，不过会占用更多的内存；所以可以根据实际硬件环境和程序的运行状态来调节loadFactor。<br>　　那么HashMap是如何扩容的呢？我们跟随源码看一下实现方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的源码实现很简单就是使用一个容量更大（原来的2倍）的数组来代替已有的容量小的数组；transfer()方法则是将原有Entry数组的元素拷贝到新的Entry数组里面。</p><h3 id="HashMap多线程的条件竞争"><a href="#HashMap多线程的条件竞争" class="headerlink" title="HashMap多线程的条件竞争"></a>HashMap多线程的条件竞争</h3><p>　　因为HashMap采用单链表结构，那么就很容易形成闭合的链路，这样在循环的时候只要有线程对这个HashMap进行get操作就会产生死循环。但是，这种闭合的链路是如何形成的呢？在单线程情况下，只有一个线程对HashMap的数据结构进行操作，是不可能产生闭合的回路的。那就只有在多线程并发的情况下才会出现这种情况，那就是在put操作的时候，如果size&gt;initialCapacity*loadFactor，那么这时候HashMap就会进行rehash操作，随之HashMap的结构就会发生翻天覆地的变化。很有可能就是在两个线程在这个时候同时触发了rehash操作，产生了闭合的回路。<br>　　当我们往HashMap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。 如果这个元素所在的位置上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，而先前加入的放在链尾。<br>　　当哈希桶容量较小，容易产生哈希碰撞，所以，Hash表的尺寸和容量非常的重要。一般来说，Hash表这个容器当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，这个过程称为resize。多个线程同时往HashMap添加新元素时，多次resize会有一定概率出现死循环，因为每次resize需要把旧的数据映射到新的哈希表，我们可以通过HashMap源码中的transfer() 方法窥探其中的奥秘：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中do…while循环就是导致产生闭合回路的原因，也是导致多线程使用hashmap出现CUP使用率骤增，从而多个线程阻塞的罪魁祸首。</p><h2 id="HashMap相关结构"><a href="#HashMap相关结构" class="headerlink" title="HashMap相关结构"></a>HashMap相关结构</h2><h3 id="线程安全的ConcurrentHashMap"><a href="#线程安全的ConcurrentHashMap" class="headerlink" title="线程安全的ConcurrentHashMap"></a>线程安全的ConcurrentHashMap</h3><p>　　ConcurrentHashMap是一种线程安全的HashMap。它是基于分段锁技术的Map实现类，即对分段加锁同步以期在多线程环境下快速达到插入数据的一致性，因此只有在同一个分段内才存在竞态关系，不同的分段锁之间没有锁竞争。相比于对整个Map加锁的设计，分段锁大大的提高了高并发环境下的处理能力。但同时，由于不是对整个Map加锁，导致一些需要扫描整个Map的方法（如size(), containsValue()）需要使用特殊的实现，另外一些方法（如get()、clear()）甚至放弃了对一致性的要求，因此ConcurrentHashMap是弱一致性的。<br>　　我们知道HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。<br><img src="https://raw.githubusercontent.com/seasonfif/picture/master/other/concurrentmap.jpeg" alt="ConcurrentHashMap存储模型"><br>　　ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。ConcurrentHashMap中的HashEntry相对于HashMap中的Entry有一定的差异性：HashEntry中的value以及next都被volatile修饰，这样在多线程读写过程中能够保持它们的可见性，从如下源码片段可有个大概了解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure></p><p>　　与HashMap不同的是，ConcurrentHashMap并不允许key或者value为null，按照作者Doug Lea的说法，这么设计的原因是因为在ConcurrentHashMap中，一旦value出现null，则代表HashEntry的key/value没有映射完成就被其他线程所见，而并不只是简单的空值而已。<br>　　本文只是简单的介绍一下ConcurrentHashMap的概念及其特点，详细的解析可以查看我的<a href="https://seasonfif.github.io/2015/03/25/java/深入理解ConcurrentHashMap/">这篇博文</a>。</p><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>　　和HashMap一样，Hashtable也是一个散列表，它存储的内容是键值对(key-value)映射。Hashtable继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。Dictionary是声明了操作”键值对”函数接口的抽象类。<br>Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。<br>通过Hashtable公开接口可以看到它线程安全的方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span>                <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> Object              <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">             <span class="keyword">boolean</span>             <span class="title">contains</span><span class="params">(Object value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">boolean</span>             <span class="title">containsKey</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">boolean</span>             <span class="title">containsValue</span><span class="params">(Object value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> Enumeration&lt;V&gt;      <span class="title">elements</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> Set&lt;Entry&lt;K, V&gt;&gt;    <span class="title">entrySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">boolean</span>             <span class="title">equals</span><span class="params">(Object object)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> V                   <span class="title">get</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">int</span>                 <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">boolean</span>             <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> Set&lt;K&gt;              <span class="title">keySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> Enumeration&lt;K&gt;      <span class="title">keys</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> V                   <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span>                <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> V                   <span class="title">remove</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">int</span>                 <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> String              <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> Collection&lt;V&gt;       <span class="title">values</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><p>由于同步效率的问题，在多线程环境下Hashtable已经被ConcurrentHashMap所取代，但是程序要求数据强一致性时还是要使用Hashtable。<br><br></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java集合框架介绍</title>
      <link href="/2015/03/18/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
      <url>/2015/03/18/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h2 id="集合框架概览"><a href="#集合框架概览" class="headerlink" title="集合框架概览"></a>集合框架概览</h2><p>　　Java集合框架由一套设计优良的接口和类组成。高度的封装使我们操作多个数据或对象元素极为方便。所有的Java集合都在java.util包中。<br>　　在编写程序的过程中，使用到集合类，要根据不同的需求，来决定使用哪种集合类，比如，要经常遍历集合内元素，就要使用List，如果要保证集合中不存在重复的数据，就要用Set;如果要通过某一键来查找某一值，就要使用Map。<br>Java中集合类主要有两大分支：</p><ol><li>Collection</li><li>Map</li></ol><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>Colloction接口继承关系<br><img src="https://raw.githubusercontent.com/seasonfif/picture/master/other/collection-mark.jpg" alt="Collection"><br>详细的类图结构<br><img src="https://raw.githubusercontent.com/seasonfif/picture/master/other/java-collection.png" alt="Collection"></p><h3 id="1、接口定义"><a href="#1、接口定义" class="headerlink" title="1、接口定义"></a>1、接口定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  Object[] toArray();</span><br><span class="line"></span><br><span class="line">  &lt;T&gt; T[] toArray(T[] var1);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; var1)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、Set实现类"><a href="#2、Set实现类" class="headerlink" title="2、Set实现类"></a>2、Set实现类</h3><p>Set<br>　　该类中的元素不按特定方式排序，只是简单的把对象加入集合中，就像往口袋里放东西。<br>对Set中成员的访问和操作是通过Set中对象的引用进行的，所以集中不能有重复对象。<br>　　Set也有多种变体，可以实现排序等功能，如TreeSet，它把对象添加到集中的操作将变为按照某种比较规则将其插入到有序的对象序列中。它实现的是SortedSet接口，也就是加入了对象比较的方法。通过对集中的对象迭代，我们可以得到一个升序的对象集合。<br>HashSet<br>　　能够快速定位一个元素，要注意的是：存入HashSet中的对象必须实现HashCode()方法；<br>TreeSet<br>　　将放入其中的元素按序存放。</p><h3 id="3、Queue实现类"><a href="#3、Queue实现类" class="headerlink" title="3、Queue实现类"></a>3、Queue实现类</h3><p>Queue<br>　　用于模拟队列这种数据结构。队列通常是指“先进先出（FIFO）”的容器。队列的头部保存在队列中存放时间最长的元素，尾部保存存放时间最短的元素。新元素插入到队列的尾部，取出元素会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。<br>PriorityQueue<br>　　保存队列元素的顺序不是按照元素添加的顺序来保存的，而是在添加元素的时候对元素的大小排序后再保存的。因此在PriorityQueue中使用peek()或pool()取出队列中头部的元素，取出的不是最先添加的元素，而是最小的元素。<br>Deque<br>　　该接口是Queue接口的子接口，它代表一个双端队列。<br>ArrayDeque<br>　　该类是Deque接口的实现类，ArrayDeque采用了循环数组的方式来完成双端队列的功能。</p><ol><li>无限的扩展，自动扩展队列大小的。（当然在不会内存溢出的情况下。）</li><li>非线程安全的，不支持并发访问和修改。</li><li>支持fast-fail.</li><li>作为栈使用的话比比栈要快.</li><li>当队列使用比linklist要快。</li><li>null元素被禁止使用。</li></ol><h3 id="4、List实现类"><a href="#4、List实现类" class="headerlink" title="4、List实现类"></a>4、List实现类</h3><p>List<br>　　该接口及其实现类是容量可变的列表，可按索引访问集合中的元素。<br>列表在数据结构中分别表现为：数组和向量、链表、堆栈、队列。<br>ArrayList<br>　　实现一个数组，它的规模可变并且能像链表一样被访问。它提供的功能类似Vector类但不同步，它是以Array方式实现的List，允许快速随机存取。<br>LinkedList<br>　　实现一个链表，提供最佳顺序存取，适合插入和移除元素。由这个类定义的链表也可以像栈或队列一样被使用。提供最佳顺序存取，适合插入和移除元素。LinkedList与ArrayList，ArrayDeque的实现机制完全不同，ArrayList和ArrayDeque内部以数组的形式来保存集合中的元素，因此随机访问集合元素时有较好的性能；而LinkedList以链表的形式来保存集合中的元素，因此随机访问集合元素时性能较差，但是插入和删除元素时性能比较出色（只需改变指针所指的地址即可），需要指出的是，虽然Vector也是以数组的形式来存储集合但因为它实现了线程同步（而且实现的机制不好），故各方面的性能都比较差。<br>Vector<br>　　Vector同步了每个方法，你几乎从不要那样做，通常有想要同步的是整个操作序列。同步单个的操作也不安全（如果你迭代一个Vector，你还是要加锁，以避免其它线程在同一时刻改变集合）.而且效率更慢。当然同样有锁的开销即使你不需要，这是个很糟糕的方法在默认情况下同步访问。你可以一直使用Collections.sychronizedList来装饰一个集合。</p><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>Map接口继承关系<br><img src="https://raw.githubusercontent.com/seasonfif/picture/master/other/map-mark.jpg" alt="Map"><br>详细的类图结构<br><img src="https://raw.githubusercontent.com/seasonfif/picture/master/other/java-map.png" alt="Map"></p><h3 id="1、接口定义-1"><a href="#1、接口定义-1" class="headerlink" title="1、接口定义"></a>1、接口定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">V <span class="title">put</span><span class="params">(K var1, V var2)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">V <span class="title">remove</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object var1, V var2)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; var1)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; var1)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> V <span class="title">putIfAbsent</span><span class="params">(K var1, V var2)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object var1, Object var2)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K var1, V var2, V var3)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> V <span class="title">replace</span><span class="params">(K var1, V var2)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> V <span class="title">computeIfAbsent</span><span class="params">(K var1, Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; var2)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> V <span class="title">computeIfPresent</span><span class="params">(K var1, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; var2)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> V <span class="title">compute</span><span class="params">(K var1, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; var2)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> V <span class="title">merge</span><span class="params">(K var1, V var2, BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; var3)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">setValue</span><span class="params">(V var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">default</span> &lt;K extends Comparable&lt;? <span class="keyword">super</span> K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">default</span> &lt;K, V extends Comparable&lt;? <span class="keyword">super</span> V&gt;&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">default</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? <span class="keyword">super</span> K&gt; var0) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">default</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? <span class="keyword">super</span> V&gt; var0) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、AbstractMap"><a href="#2、AbstractMap" class="headerlink" title="2、AbstractMap"></a>2、AbstractMap</h3><p>HashMap<br>　　基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>　　HashMap 的实例有两个参数影响其性能：初始容量 和加载因子。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>　　通常，默认加载因子 (.75) 在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。<br>　　该类不是线程安全的。<br>WeakHashMap<br>　　以弱键实现的基于哈希表的 Map。在 WeakHashMap 中，当某个键不再正常使用时，将自动移除其条目。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。丢弃某个键时，其条目从映射中有效地移除，因此，该类的行为与其他的 Map 实现有所不同。 </p><h3 id="3、LinkedHashMap"><a href="#3、LinkedHashMap" class="headerlink" title="3、LinkedHashMap"></a>3、LinkedHashMap</h3><p>LinkedHashMap<br>　　该类是 Map 接口的哈希表和链表实现。该类维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序），亦即它保留插入的顺序，输出的顺序即为输入时的插入顺序。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>　　根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用 get 方法)的链表。<br>　　默认是按插入顺序排序，如果指定按访问顺序排序，那么调用 get 方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。  可以重写 removeEldestEntry 方法返回 true 值指定插入元素时移除最老的元素。<br>　　注意，此实现不是同步的。</p><h3 id="4、SortedMap"><a href="#4、SortedMap" class="headerlink" title="4、SortedMap"></a>4、SortedMap</h3><p>TreeMap<br>　　基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。<br>　　在添加、删除和定位映射关系上，TreeMap类要比HashMap类的性能差一些，但是其中的映射关系具有一定的顺序，如果不需要一个有序的集合，则建议使用HashMap类；如果需要进行有序的遍历输出，则建议使用TreeMap类，在这种情况下，可以先使用由HashMap类实现的Map集合，在需要顺序输出时，再利用现有的HashMap类的实例，创建一个具有完全相同映射关系的TreeMap类型的实例。</p><h3 id="5、ConcurrentMap"><a href="#5、ConcurrentMap" class="headerlink" title="5、ConcurrentMap"></a>5、ConcurrentMap</h3><p>　　该类是线程安全的 Map 实现。与 Hashtable 相似，但 Hashtable 的 synchronized 是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap 允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对 hash 表的不同部分进行的修改。ConcurrentHashMap 内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。<br>　　Hashtable 对 get,put,remove 都使用了同步操作，它的同步级别是正对 Hashtable 来进行同步的，也就是说如果有线程正在遍历集合，其他的线程就暂时不能使用该集合了，这样无疑就很容易对性能和吞吐量造成影响，从而形成单点。而ConcurrentHashMap 则不同，它只对 put,remove 操作使用了同步操作，get 操作并不影响。<br>　　该类不允许将 null 用作键或值。 </p><h3 id="6、Hashtable"><a href="#6、Hashtable" class="headerlink" title="6、Hashtable"></a>6、Hashtable</h3><p>　　Hashtable 的实例有两个参数影响其性能：初始容量 和加载因子。容量 是哈希表中桶 的数量，初始容量就是哈希表创建时的容量。注意，哈希表的状态为 open：在发生“哈希冲突”的情况下，单个桶会存储多个条目，这些条目必须按顺序搜索。加载因子 是对哈希表在其容量自动增加之前可以达到多满的一个尺度。初始容量和加载因子这两个参数只是对该实现的提示。关于何时以及是否调用 rehash 方法的具体细节则依赖于该实现。<br>　　通常，默认加载因子(.75)在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查找某个条目的时间（在大多数 Hashtable 操作中，包括 get 和 put 操作，都反映了这一点）。<br>　　初始容量主要控制空间消耗与执行 rehash 操作所需要的时间损耗之间的平衡。如果初始容量大于 Hashtable 所包含的最大条目数除以加载因子，则永远 不会发生 rehash 操作。但是，将初始容量设置太高可能会浪费空间。<br>　　Hashtable 是同步的，现在一般情况下，都使用 HashMap ，而不使用陈旧的 Hashtbale，即便需要同步的时候，也是采用加同步的HashMap或者ConcurrentHashMap等实现。</p><p><br></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用HEXO+Github搭建自己的博客</title>
      <link href="/2015/03/07/other/%E4%BD%BF%E7%94%A8HEXO+Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2015/03/07/other/%E4%BD%BF%E7%94%A8HEXO+Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>安装Node（必须）</p><p>作用：用来生成静态页面的</p><p>到Node.js官网下载相应平台的最新版本，一路安装即可。</p><p>安装Git（必须）</p><p>作用：把本地的hexo内容提交到github上去.</p><p>安装Xcode就自带有Git，我就不多说了。</p><p>申请GitHub（必须）</p><p>作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。</p><p>github账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。<br>正式安装Hexo</p><p>Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。</p><p>执行如下命令安装Hexo：</p><p>sudo npm install -g hexo</p><p>初始化然后，执行init命令初始化hexo,命令：</p><p>hexo init</p><p>好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。</p><p>生成静态页面</p><p>hexo generate（hexo g也可以）</p><p>本地启动</p><p>启动本地服务，进行文章预览调试，命令：</p><p>hexo s</p><p>浏览器输入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p><h2 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h2><p>建立Repository</p><p>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法</p><p>然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：</p><pre><code>_config.yml    node_modules    public      sourcedb.json        package.json    scaffolds  themes</code></pre><p>现在我们需要_config.yml文件，来建立关联，命令：</p><p>vim _config.yml</p><p>翻到最下面，改成这样</p><p>deploy:<br>  type: git<br>  repo: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:seasonfif/seasonfif.github.io.git<br>  branch: master</p><p>然后执行命令：</p><p>npm install hexo-deployer-git –save</p><p>然后，执行配置命令：</p><p>hexo deploy</p><h2 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h2><p><a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank" rel="noopener">https://github.com/lewis-geek/hexo-theme-Aath</a><br><img src="https://camo.githubusercontent.com/063c5a8aecdefe228efea177f3bfc55a513997cd/687474703a2f2f6f6c6e7a70646932752e626b742e636c6f7564646e2e636f6d2f556e7469746c65642d313838302e706e67" alt="icon"><br><a href="https://github.com/CodeDaraW/Hacker" target="_blank" rel="noopener">https://github.com/CodeDaraW/Hacker</a><br><img src="https://camo.githubusercontent.com/9f682a6ea902cea665d6bbd52fe6e89f31e6d6c0/68747470733a2f2f6f6f6f2e306f302e6f6f6f2f323031362f30382f30342f353761333036663536626565322e706e67" alt="icon"><br><a href="https://github.com/Kaijun/hexo-theme-huxblog" target="_blank" rel="noopener">https://github.com/Kaijun/hexo-theme-huxblog</a><br><img src="https://camo.githubusercontent.com/51586abd6e60f0bd7d85a532d7c0017cbe781421/687474703a2f2f6875616e677875616e2e6d652f696d672f626c6f672d6465736b746f702e6a7067" alt="icon"><br><a href="https://github.com/YenYuHsuan/hexo-theme-beantech/" target="_blank" rel="noopener">https://github.com/YenYuHsuan/hexo-theme-beantech/</a><br><img src="https://camo.githubusercontent.com/905786536d4c9f111d965f29aac8bc8c36fede47/687474703a2f2f6265616e746563682e6f72672f696d672f6265616e746563682d6465736b746f702e706e67" alt="icon"></p><h2 id="增加字数统计"><a href="#增加字数统计" class="headerlink" title="增加字数统计"></a>增加字数统计</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><p>使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-count"</span>&gt;字数统计：&lt;%= wordcount(page.content) %&gt;字&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;span class="post-count"&gt;阅读时长：&lt;%= min2read(page.content) %&gt;分钟&lt;/</span>span&gt;</span><br></pre></td></tr></table></figure></p><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><p>  1、文件大小写引起的找不到路径<br>  进入到博客项目中 .deploy_git文件夹，修改 .git 下的 config 文件，将 ignorecase=true 改为 ignorecase=false<br>  删除博客项目中 .deploy_git 文件夹下的所有文件，并 push 到 Github 上, 这一步会清空<code>github.io</code>项目中所有文件。<br>  使用 Hexo 再次生成及部署</p>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell编程</title>
      <link href="/2015/03/04/linux/shell%E7%BC%96%E7%A8%8B/"/>
      <url>/2015/03/04/linux/shell%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>　　Shell 脚本（shell script），是一种为 shell 编写的脚本程序。Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。<br>　　最常用的Shell是Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。在一般情况下，并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash。<br>　　“#!”告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。</p><h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "Hello World"</span><br></pre></td></tr></table></figure><p>只需要打开文本编辑工具，编辑成以上的样子,然后保存成test.sh。运行该脚本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd 到该目录下</span><br><span class="line">chmod +x ./test.sh  #给脚本执行权限</span><br><span class="line">./test.sh  #执行脚本</span><br></pre></td></tr></table></figure></p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myText="hello world"</span><br><span class="line">muNum=100</span><br></pre></td></tr></table></figure><p>这里面需要注意的就是，“=”前后不能有空格，命名规则就和其它语言一样了。</p><h4 id="访问变量"><a href="#访问变量" class="headerlink" title="访问变量"></a>访问变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myText="hello world"</span><br><span class="line">muNum=100</span><br><span class="line">echo $myText</span><br><span class="line">echo muNum</span><br></pre></td></tr></table></figure><p>当想要访问变量的时候，需要使用$，否则输出的将是纯文本内容。</p><h4 id="Shell中的四则运算"><a href="#Shell中的四则运算" class="headerlink" title="Shell中的四则运算"></a>Shell中的四则运算</h4><table><thead><tr><th>运算符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td>+</td><td style="text-align:center">加法运算</td></tr><tr><td>-</td><td style="text-align:center">减法运算</td></tr><tr><td>*</td><td style="text-align:center">乘法运算</td></tr><tr><td>/</td><td style="text-align:center">除法运算</td></tr></tbody></table><p>示例如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">echo "Hello World !" </span><br><span class="line">a=3 b=5 </span><br><span class="line">val=`expr $a + $b` </span><br><span class="line">echo "Total value : $val" </span><br><span class="line">val=`expr $a - $b` </span><br><span class="line">echo "Total value : $val" </span><br><span class="line">val=`expr $a \* $b` </span><br><span class="line">echo "Total value : $val" </span><br><span class="line">val=`expr $a / $b` </span><br><span class="line">echo "Total value : $val"</span><br></pre></td></tr></table></figure></p><p>这里面需要注意的就是，定义变量的时候“=”前后是不能有空格的，但是进行四则运算的时候运算符号前后一定要有空格，乘法的时候需要进行转义。</p><h4 id="Shell中逻辑运算"><a href="#Shell中逻辑运算" class="headerlink" title="Shell中逻辑运算"></a>Shell中逻辑运算</h4><table><thead><tr><th>运算符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td>%</td><td style="text-align:center">求余</td></tr><tr><td>==</td><td style="text-align:center">相等</td></tr><tr><td>=</td><td style="text-align:center">赋值</td></tr><tr><td>!=</td><td style="text-align:center">不相等</td></tr><tr><td>!</td><td style="text-align:center">非</td></tr><tr><td>-o</td><td style="text-align:center">或</td></tr><tr><td>-a</td><td style="text-align:center">与</td></tr></tbody></table><p>示例如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a=3 b=5 </span><br><span class="line">val=`expr $a / $b` </span><br><span class="line">echo "Total value : $val" </span><br><span class="line">val=`expr $a % $b` </span><br><span class="line">echo "Total value : $val" </span><br><span class="line">if [ $a == $b ] </span><br><span class="line">then </span><br><span class="line">  echo "a is equal to b" </span><br><span class="line">fi </span><br><span class="line">if [ $a != $b ] </span><br><span class="line">then </span><br><span class="line">  echo "a is not equal to b" </span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><h4 id="Shell中关系运算"><a href="#Shell中关系运算" class="headerlink" title="Shell中关系运算"></a>Shell中关系运算</h4><table><thead><tr><th>运算符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td>-eq</td><td style="text-align:center">两个数相等返回true</td></tr><tr><td>-ne</td><td style="text-align:center">两个数不相等返回true</td></tr><tr><td>-gt</td><td style="text-align:center">左侧数大于右侧数返回true</td></tr><tr><td>-It</td><td style="text-align:center">左侧数小于右侧数返回true</td></tr><tr><td>-ge</td><td style="text-align:center">左侧数大于等于右侧数返回true</td></tr><tr><td>-le</td><td style="text-align:center">左侧数小于等于右侧数返回true</td></tr></tbody></table><p>示例如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [ $a -eq $b ]</span><br><span class="line">then</span><br><span class="line">   echo "true"</span><br><span class="line">else</span><br><span class="line">   echo "false"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a -ne $b ]</span><br><span class="line">then</span><br><span class="line">   echo "true"</span><br><span class="line">else</span><br><span class="line">   echo "false"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo "true"</span><br><span class="line">else</span><br><span class="line">   echo "false"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo "true"</span><br><span class="line">else</span><br><span class="line">   echo "false"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a -ge $b ]</span><br><span class="line">then</span><br><span class="line">   echo "true"</span><br><span class="line">else</span><br><span class="line">   echo "false"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a -le $b ]</span><br><span class="line">then</span><br><span class="line">   echo "true"</span><br><span class="line">else</span><br><span class="line">   echo "false"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><h4 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h4><table><thead><tr><th>运算符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td>=</td><td style="text-align:center">两个字符串相等返回true</td></tr><tr><td>!=</td><td style="text-align:center">两个字符串不相等返回true</td></tr><tr><td>-z</td><td style="text-align:center">字符串长度为0返回true</td></tr><tr><td>-n</td><td style="text-align:center">字符串长度不为0返回true</td></tr></tbody></table><p>示例如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mtext="hello"  #定义字符串</span><br><span class="line">mtext2="world"</span><br><span class="line">mtext3=$mtext" "$mtext2  #字符串的拼接</span><br><span class="line">echo $mtext3  #输出字符串</span><br><span class="line">echo $&#123;#mtext3&#125;  #输出字符串长度</span><br><span class="line">echo $&#123;mtext3:1:4&#125;  #截取字符串</span><br></pre></td></tr></table></figure></p><h4 id="文件检测"><a href="#文件检测" class="headerlink" title="文件检测"></a>文件检测</h4><table><thead><tr><th>运算符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td>-d file</td><td style="text-align:center">检测文件是否是目录，如果是，则返回 true</td></tr><tr><td>-r file</td><td style="text-align:center">检测文件是否可读，如果是，则返回 true</td></tr><tr><td>-w file</td><td style="text-align:center">检测文件是否可写，如果是，则返回 true</td></tr><tr><td>-x file</td><td style="text-align:center">检测文件是否可执行，如果是，则返回 true</td></tr><tr><td>-s file</td><td style="text-align:center">检测文件是否为空（文件大小是否大于0，不为空返回 true</td></tr><tr><td>-e file</td><td style="text-align:center">检测文件（包括目录）是否存在，如果是，则返回 true</td></tr></tbody></table><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array=(1 2 3 4 5) #定义数组 </span><br><span class="line">array2=(aa bb cc dd ee) #定义数组 </span><br><span class="line">value=$&#123;array[3]&#125; #找到某一个下标的数，然后赋值 </span><br><span class="line">echo $value #打印 value2=$&#123;array2[3]&#125; #找到某一个下标的数，然后赋值 </span><br><span class="line">echo $value2 #打印 length=$&#123;#array[*]&#125; #获取数组长度 echo $length</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo "hello world" </span><br><span class="line">echo hello world </span><br><span class="line">text="hello world" </span><br><span class="line">echo $text </span><br><span class="line">echo -e "hello \nworld" #输出并且换行 </span><br><span class="line">echo "hello world" &gt; a.txt #重定向到文件 </span><br><span class="line">echo `date` #输出当前系统时间</span><br></pre></td></tr></table></figure><h4 id="test语法"><a href="#test语法" class="headerlink" title="test语法"></a>test语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test $[num1] -eq $[num2]  #判断两个变量是否相等</span><br><span class="line">test num1=num2  #判断两个数字是否相等</span><br></pre></td></tr></table></figure><h4 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo "true"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo "true"</span><br><span class="line">else</span><br><span class="line">   echo "false"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo "a is equal to b"</span><br><span class="line">elif [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo "a is greater than b"</span><br><span class="line">elif [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo "a is less than b"</span><br><span class="line">else</span><br><span class="line">   echo "None of the condition met"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;1..5&#125;</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for i in 5 6 7 8 9</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for FILE in $HOME/.bash*</span><br><span class="line">do</span><br><span class="line">   echo $FILE</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">COUNTER=0</span><br><span class="line">while [ $COUNTER -lt 5 ]</span><br><span class="line">do</span><br><span class="line">    COUNTER=`expr $COUNTER + 1`</span><br><span class="line">    echo $COUNTER</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo '请输入。。。'</span><br><span class="line">echo 'ctrl + d 即可停止该程序'</span><br><span class="line">while read FILM</span><br><span class="line">do</span><br><span class="line">    echo "Yeah! great film the $FILM"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>以上是while循环的两种用法，第一种是比较常规的，执行循环，然后每次都把控制的数加1，就可以让while循环有退出的条件了。<br>第二种是用户从键盘数据，然后把用户输入的文字输出出来。</p><h4 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">break  #跳出所有循环</span><br><span class="line">break n  #跳出第n层f循环</span><br><span class="line">continue  #跳出当前循环</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sysout()&#123;</span><br><span class="line">    echo "hello world"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sysout</span><br></pre></td></tr></table></figure><p>以上为定义一个没有返回值的函数，然后调用该函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test()&#123;</span><br><span class="line"></span><br><span class="line">    aNum=3</span><br><span class="line">    anotherNum=5</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">test</span><br><span class="line">result=$?</span><br><span class="line">echo $result</span><br></pre></td></tr></table></figure><p>以上为定义一个有返回值的函数，调用该函数，输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test()&#123;</span><br><span class="line">    echo $1  #接收第一个参数</span><br><span class="line">    echo $2  #接收第二个参数</span><br><span class="line">    echo $3  #接收第三个参数</span><br><span class="line">    echo $#  #接收到参数的个数</span><br><span class="line">    echo $*  #接收到的所有参数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test aa bb cc</span><br></pre></td></tr></table></figure><p>定义了一个需要传递参数的函数</p><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $$result &gt; file  #将结果写入文件，结果不会在控制台展示，而是在文件中，覆盖写</span><br><span class="line">echo result &gt;&gt; file  #将结果写入文件，结果不会在控制台展示，而是在文件中，追加写</span><br><span class="line">echo input &lt; file  #获取输入流</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux常用命令汇总</title>
      <link href="/2015/02/15/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
      <url>/2015/02/15/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<p>Linux常用命令速查</p><h4 id="线上查询及帮助命令-2-个"><a href="#线上查询及帮助命令-2-个" class="headerlink" title="线上查询及帮助命令 (2 个)"></a>线上查询及帮助命令 (2 个)</h4><p>man<br>查看命令帮助，命令的词典，更复杂的还有 info，但不常用。</p><p>help<br>查看 Linux 内置命令的帮助，比如 cd 命令。</p><h4 id="文件和目录操作命令-18-个"><a href="#文件和目录操作命令-18-个" class="headerlink" title="文件和目录操作命令 (18 个)"></a>文件和目录操作命令 (18 个)</h4><p>ls<br>全拼 list，功能是列出目录的内容及其内容属性信息。</p><p>cd<br>全拼 change directory，功能是从当前工作目录切换到指定的工作目录。</p><p>cp<br>全拼 copy，其功能为复制文件或目录。</p><p>find<br>查找的意思，用于查找目录及目录下的文件。</p><p>mkdir<br>全拼 make directories，其功能是创建目录。</p><p>mv<br>全拼 move，其功能是移动或重命名文件。</p><p>pwd<br>全拼 print working directory，其功能是显示当前工作目录的绝对路径。</p><p>rename<br>用于重命名文件。</p><p>rm<br>全拼 remove，其功能是删除一个或多个文件或目录。</p><p>rmdir<br>全拼 remove empty directories，功能是删除空目录。</p><p>touch<br>创建新的空文件，改变已有文件的时间戳属性。</p><p>tree<br>功能是以树形结构显示目录下的内容。</p><p>basename<br>显示文件名或目录名。</p><p>dirname<br>显示文件或目录路径。</p><p>chattr<br>改变文件的扩展属性。</p><p>lsattr<br>查看文件扩展属性。</p><p>file<br>显示文件的类型。</p><p>md5sum<br>计算和校验文件的 MD5 值。</p><h4 id="查看文件及内容处理命令（21-个）"><a href="#查看文件及内容处理命令（21-个）" class="headerlink" title="查看文件及内容处理命令（21 个）"></a>查看文件及内容处理命令（21 个）</h4><p>cat<br>全拼 concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。</p><p>tac<br>tac 是 cat 的反向拼写，因此命令的功能为反向显示文件内容。</p><p>more<br>分页显示文件内容。</p><p>less<br>分页显示文件内容，more 命令的相反用法。</p><p>head<br>显示文件内容的头部。</p><p>tail<br>显示文件内容的尾部。</p><p>cut<br>将文件的每一行按指定分隔符分割并输出。</p><p>split<br>分割文件为不同的小片段。</p><p>paste<br>按行合并文件内容。</p><p>sort<br>对文件的文本内容排序。</p><p>uniq<br>去除重复行。oldboy</p><p>wc<br>统计文件的行数、单词数或字节数。</p><p>iconv<br>转换文件的编码格式。</p><p>dos2unix<br>将 DOS 格式文件转换成 UNIX 格式。</p><p>diff<br>全拼 difference，比较文件的差异，常用于文本文件。</p><p>vimdiff<br>命令行可视化文件比较工具，常用于文本文件。</p><p>rev<br>反向输出文件内容。</p><p>grep/egrep<br>过滤字符串，三剑客老三。</p><p>join<br>按两个文件的相同字段合并。</p><p>tr<br>替换或删除字符。</p><p>vi/vim<br>命令行文本编辑器。</p><h4 id="文件压缩及解压缩命令（4-个）"><a href="#文件压缩及解压缩命令（4-个）" class="headerlink" title="文件压缩及解压缩命令（4 个）"></a>文件压缩及解压缩命令（4 个）</h4><p>tar<br>打包压缩。oldboy</p><p>unzip<br>解压文件。</p><p>gzip<br>gzip 压缩工具。</p><p>zip<br>压缩工具。</p><h4 id="信息显示命令（11-个）"><a href="#信息显示命令（11-个）" class="headerlink" title="信息显示命令（11 个）"></a>信息显示命令（11 个）</h4><p>uname<br>显示操作系统相关信息的命令。</p><p>hostname<br>显示或者设置当前系统的主机名。</p><p>dmesg<br>显示开机信息，用于诊断系统故障。</p><p>uptime<br>显示系统运行时间及负载。</p><p>stat<br>显示文件或文件系统的状态。</p><p>du<br>计算磁盘空间使用情况。</p><p>df<br>报告文件系统磁盘空间的使用情况。</p><p>top<br>实时显示系统资源使用情况。</p><p>free<br>查看系统内存。</p><p>date<br>显示与设置系统时间。</p><p>cal<br>查看日历等时间信息。</p><h4 id="搜索文件命令（4-个）"><a href="#搜索文件命令（4-个）" class="headerlink" title="搜索文件命令（4 个）"></a>搜索文件命令（4 个）</h4><p>which<br>查找二进制命令，按环境变量 PATH 路径查找。</p><p>find<br>从磁盘遍历查找文件或目录。</p><p>whereis<br>查找二进制命令，按环境变量 PATH 路径查找。</p><p>locate<br>从数据库 (/var/lib/mlocate/mlocate.db) 查找命令，使用 updatedb 更新库。</p><h4 id="用户管理命令（10-个）"><a href="#用户管理命令（10-个）" class="headerlink" title="用户管理命令（10 个）"></a>用户管理命令（10 个）</h4><p>useradd<br>添加用户。</p><p>usermod<br>修改系统已经存在的用户属性。</p><p>userdel<br>删除用户。</p><p>groupadd<br>添加用户组。</p><p>passwd<br>修改用户密码。</p><p>chage<br>修改用户密码有效期限。</p><p>id<br>查看用户的 uid,gid 及归属的用户组。</p><p>su<br>切换用户身份。</p><p>visudo<br>编辑 / etc/sudoers 文件的专属命令。</p><p>sudo<br>以另外一个用户身份（默认 root 用户）执行事先在 sudoers 文件允许的命令。</p><h4 id="基础网络操作命令（11-个）"><a href="#基础网络操作命令（11-个）" class="headerlink" title="基础网络操作命令（11 个）"></a>基础网络操作命令（11 个）</h4><p>telnet<br>使用 TELNET 协议远程登录。</p><p>ssh<br>使用 SSH 加密协议远程登录。</p><p>scp<br>全拼 secure copy，用于不同主机之间复制文件。</p><p>wget<br>命令行下载文件。</p><p>ping<br>测试主机之间网络的连通性。</p><p>route<br>显示和设置 linux 系统的路由表。</p><p>ifconfig<br>查看、配置、启用或禁用网络接口的命令。</p><p>ifup<br>启动网卡。</p><p>ifdown<br>关闭网卡。</p><p>netstat<br>查看网络状态。</p><p>ss<br>查看网络状态。</p><h4 id="深入网络操作命令（9-个）"><a href="#深入网络操作命令（9-个）" class="headerlink" title="深入网络操作命令（9 个）"></a>深入网络操作命令（9 个）</h4><p>nmap<br>网络扫描命令。</p><p>lsof<br>全名 list open files，也就是列举系统中已经被打开的文件。</p><p>mail<br>发送和接收邮件。</p><p>mutt<br>邮件管理命令。</p><p>nslookup<br>交互式查询互联网 DNS 服务器的命令。</p><p>dig<br>查找 DNS 解析过程。</p><p>host<br>查询 DNS 的命令。</p><p>traceroute<br>追踪数据传输路由状况。</p><p>tcpdump<br>命令行的抓包工具。</p><h4 id="有关磁盘与文件系统的命令（16-个）"><a href="#有关磁盘与文件系统的命令（16-个）" class="headerlink" title="有关磁盘与文件系统的命令（16 个）"></a>有关磁盘与文件系统的命令（16 个）</h4><p>mount<br>挂载文件系统。</p><p>umount<br>卸载文件系统。</p><p>fsck<br>检查并修复 Linux 文件系统。</p><p>dd<br>转换或复制文件。</p><p>dumpe2fs<br>导出 ext2/ext3/ext4 文件系统信息。</p><p>dump<br>ext2/3/4 文件系统备份工具。</p><p>fdisk<br>磁盘分区命令，适用于 2TB 以下磁盘分区。</p><p>parted<br>磁盘分区命令，没有磁盘大小限制，常用于 2TB 以下磁盘分区。</p><p>mkfs<br>格式化创建 Linux 文件系统。</p><p>partprobe<br>更新内核的硬盘分区表信息。</p><p>e2fsck<br>检查 ext2/ext3/ext4 类型文件系统。</p><p>mkswap<br>创建 Linux 交换分区。</p><p>swapon<br>启用交换分区。</p><p>swapoff<br>关闭交换分区。</p><p>sync<br>将内存缓冲区内的数据写入磁盘。</p><p>resize2fs<br>调整 ext2/ext3/ext4 文件系统大小。</p><h4 id="系统权限及用户授权相关命令（4-个）"><a href="#系统权限及用户授权相关命令（4-个）" class="headerlink" title="系统权限及用户授权相关命令（4 个）"></a>系统权限及用户授权相关命令（4 个）</h4><p>chmod<br>改变文件或目录权限。</p><p>chown<br>改变文件或目录的属主和属组。</p><p>chgrp<br>更改文件用户组。</p><p>umask<br>显示或设置权限掩码。</p><h4 id="查看系统用户登陆信息的命令（7-个）"><a href="#查看系统用户登陆信息的命令（7-个）" class="headerlink" title="查看系统用户登陆信息的命令（7 个）"></a>查看系统用户登陆信息的命令（7 个）</h4><p>whoami<br>显示当前有效的用户名称，相当于执行 id -un 命令。</p><p>who<br>显示目前登录系统的用户信息。</p><p>w<br>显示已经登陆系统的用户列表，并显示用户正在执行的指令。</p><p>last<br>显示登入系统的用户。</p><p>lastlog<br>显示系统中所有用户最近一次登录信息。</p><p>users<br>显示当前登录系统的所有用户的用户列表。</p><p>finger<br>查找并显示用户信息。</p><h4 id="内置命令及其它（19-个）"><a href="#内置命令及其它（19-个）" class="headerlink" title="内置命令及其它（19 个）"></a>内置命令及其它（19 个）</h4><p>echo<br>打印变量，或直接输出指定的字符串</p><p>printf<br>将结果格式化输出到标准输出。</p><p>rpm<br>管理 rpm 包的命令。</p><p>yum<br>自动化简单化地管理 rpm 包的命令。</p><p>watch<br>周期性的执行给定的命令，并将命令的输出以全屏方式显示。</p><p>alias<br>设置系统别名。</p><p>unalias<br>取消系统别名。</p><p>date<br>查看或设置系统时间。</p><p>clear<br>清除屏幕，简称清屏。</p><p>history<br>查看命令执行的历史纪录。</p><p>eject<br>弹出光驱。</p><p>time<br>计算命令执行时间。</p><p>nc<br>功能强大的网络工具。</p><p>xargs<br>将标准输入转换成命令行参数。</p><p>exec<br>调用并执行指令的命令。</p><p>export<br>设置或者显示环境变量。</p><p>unset<br>删除变量或函数。</p><p>type<br>用于判断另外一个命令是否是内置命令。</p><p>bc<br>命令行科学计算器</p><h4 id="系统管理与性能监视命令-9-个"><a href="#系统管理与性能监视命令-9-个" class="headerlink" title="系统管理与性能监视命令 (9 个)"></a>系统管理与性能监视命令 (9 个)</h4><p>chkconfig<br>管理 Linux 系统开机启动项。</p><p>vmstat<br>虚拟内存统计。</p><p>mpstat<br>显示各个可用 CPU 的状态统计。</p><p>iostat<br>统计系统 IO。</p><p>sar<br>全面地获取系统的 CPU、运行队列、磁盘 I/O、分页（交换区）、内存、 CPU 中断和网络等性能数据。</p><p>ipcs<br>用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。</p><p>ipcrm</p><p>用来删除一个或更多的消息队列、信号量集或者共享内存标识。</p><p>strace<br>用于诊断、调试 Linux 用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</p><p>ltrace<br>命令会跟踪进程的库函数调用, 它会显现出哪个库函数被调用。</p><h4 id="关机-重启-注销和查看系统信息的命令（6-个）"><a href="#关机-重启-注销和查看系统信息的命令（6-个）" class="headerlink" title="关机 / 重启 / 注销和查看系统信息的命令（6 个）"></a>关机 / 重启 / 注销和查看系统信息的命令（6 个）</h4><p>shutdown<br>关机。</p><p>halt<br>关机。</p><p>poweroff<br>关闭电源。</p><p>logout<br>退出当前登录的 Shell。</p><p>exit<br>退出当前登录的 Shell。</p><p>Ctrl+d<br>退出当前登录的 Shell 的快捷键。</p><h4 id="进程管理相关命令（15-个）"><a href="#进程管理相关命令（15-个）" class="headerlink" title="进程管理相关命令（15 个）"></a>进程管理相关命令（15 个）</h4><p>bg<br>将一个在后台暂停的命令，变成继续执行  （在后台执行）。</p><p>fg<br>将后台中的命令调至前台继续运行。</p><p>jobs<br>查看当前有多少在后台运行的命令。</p><p>kill<br>终止进程。</p><p>killall<br>通过进程名终止进程。</p><p>pkill<br>通过进程名终止进程。</p><p>crontab</p><p>定时任务命令。</p><p>ps<br>显示进程的快照。</p><p>pstree<br>树形显示进程。</p><p>nice/renice<br>调整程序运行的优先级。</p><p>nohup<br>忽略挂起信号运行指定的命令。</p><p>pgrep<br>查找匹配条件的进程。</p><p>runlevel<br>查看系统当前运行级别。</p><p>init<br>切换运行级别。</p><p>service<br>启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
  
  
    
    <entry>
      <title>你穿越到了古代 :(</title>
      <link href="/404.html"/>
      <url>/404.html</url>
      <content type="html"><![CDATA[<p><br></p><h3 id="将进酒"><a href="#将进酒" class="headerlink" title="将进酒"></a><center>将进酒</center></h3><h5 id="唐●李白"><a href="#唐●李白" class="headerlink" title="唐●李白"></a><center><em>唐●李白</em></center></h5><p align="center"><br>君不见，黄河之水天上来，奔流到海不复回。<br><br>君不见，高堂明镜悲白发，朝如青丝暮成雪。<br><br>人生得意须尽欢，莫使金樽空对月。<br><br>天生我材必有用，千金散尽还复来。<br><br>烹羊宰牛且为乐，会须一饮三百杯。<br><br>岑夫子，丹丘生，将进酒，杯莫停。<br><br>与君歌一曲，请君为我倾耳听。<br><br>钟鼓馔玉不足贵，但愿长醉不复醒。<br><br>古来圣贤皆寂寞，惟有饮者留其名。<br><br>陈王昔时宴平乐，斗酒十千恣欢谑。<br><br>主人何为言少钱，径须沽取对君酌。<br><br>五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。<br></p>]]></content>
    </entry>
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<blockquote><p>他山之石，可以为错<br>他山之石，可以攻玉</p></blockquote><h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><ul><li><a href="https://seasonfif.github.io/2016/09/21/android/一个轻量级的基于卡片模板的自动化布局框架">Matrix - 基于卡片模板的自动化布局框架</a></li><li>ARecyclerView - 方便使用的RecyclerView</li><li>SwiftModule - 轻便的组件化路由框架</li></ul><h3 id="线上项目"><a href="#线上项目" class="headerlink" title="线上项目"></a>线上项目</h3><ul><li><a href="https://seasonfif.github.io/2016/10/06/android/基于MaterialDesign的GitHub客户端">基于Material Design的github客户端</a></li><li>Oh My Star - 管理GitHub star项目的客户端</li></ul>]]></content>
    </entry>
    
    <entry>
      <title>Archives</title>
      <link href="/archive/index.html"/>
      <url>/archive/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>gallery</title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>Categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>Tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
