<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>python分布式进程</title>
      <link href="/2017/10/23/python/python%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%9B%E7%A8%8B/"/>
      <url>/2017/10/23/python/python%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%9B%E7%A8%8B/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>python学习-高阶特性</title>
      <link href="/2017/08/16/python/python%E5%AD%A6%E4%B9%A0-%E9%AB%98%E9%98%B6%E7%89%B9%E6%80%A7/"/>
      <url>/2017/08/16/python/python%E5%AD%A6%E4%B9%A0-%E9%AB%98%E9%98%B6%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>python学习-基础语法</title>
      <link href="/2017/08/10/python/python%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2017/08/10/python/python%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一致性hash</title>
      <link href="/2017/07/18/algorithm/%E4%B8%80%E8%87%B4%E6%80%A7hash/"/>
      <url>/2017/07/18/algorithm/%E4%B8%80%E8%87%B4%E6%80%A7hash/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>gradle插件编写</title>
      <link href="/2017/02/21/gradle/gradle%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/"/>
      <url>/2017/02/21/gradle/gradle%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Gradle </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>gradle简介</title>
      <link href="/2017/02/19/gradle/gradle%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/02/19/gradle/gradle%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Gradle </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>基于MaterialDesign的GitHub客户端</title>
      <link href="/2016/10/06/android/%E5%9F%BA%E4%BA%8EMaterialDesign%E7%9A%84GitHub%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>/2016/10/06/android/%E5%9F%BA%E4%BA%8EMaterialDesign%E7%9A%84GitHub%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      <content type="html"><![CDATA[<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a><strong>Github</strong></h1><p><img src="https://raw.githubusercontent.com/seasonfif/github/master/icon/icon_192.png" alt="icon"></p><p>Github是专为github精心打造的一款Android客户端，该客户端功能强大，包含常用的github浏览以及部分操作功能；界面绚丽，适配Material Design；操作简便，可以说是为githuber们量身而作的口袋神器！</p><hr><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a><strong>效果图</strong></h2><p><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/main_nav.png" alt="main_nav"></p><p><em>功能Tab选择界面</em></p><p><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/main_explore.png" alt="main_explore"></p><p><em>Explore界面</em></p><p>除此以外Github还支持夜间模式，让你的夜间浏览更舒心。</p><p><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/night_theme/main_nav_n.png" alt="main_nav_n"><br><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/night_theme/main_exlpore_n.png" alt="main_exlpore_n"></p><p>怎么样！看到这里你有没有想要上手试一试他的冲动呢？别着急，我们接着往下看。</p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a><strong>功能介绍</strong></h2><p>常用的github浏览功能以及部分操作功能，包括:</p><ol><li>启动的默认Tab支持自定义（Settings里面设置）</li><li>Explore，支持仓库和用户的搜索；支持个人喜好编程语言的设定（Settings里面设置）</li><li>Event，支持动态浏览以及相关用户和仓库的快速链接</li><li>Repository，浏览名下仓库（仓库详情页），支持预览详情，fork、star、watch和代码等资源（支持分支选择）的浏览以及删除仓库</li><li>Follow， 支持查看followings和followers；个人详情页里面还支持follow与unfollow</li><li>个人详情页，以下单独介绍</li><li>仓库详情页，以下单独介绍</li><li>Starred，浏览名下已经star的仓库</li><li>Issues，浏览相关的issues，支持新建issue，查看issue详情</li><li>Issues详情页支持增加评论以及评论的删除</li><li>Gists，浏览名下的gists，支持gists删除、评论，以及查看gists文件等</li><li>Settings，设置启动Tab、设置喜好语言、切换夜间模式、分享、清除缓存等</li><li>About， 软件相关信息、项目的github主页、商业合作、用户反馈意见软件更新，支持全量更新和差量更新</li><li>源代码里面的所有文件均支持缓存，第二次加载不耗费流量，Setting里面有删除缓存以节省存储空间</li></ol><h3 id="个人详情页"><a href="#个人详情页" class="headerlink" title="个人详情页"></a>个人详情页</h3><p>承载用户所有信息的展示以及操作平台</p><p><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/userinfo1.png" alt="userinfo1"><br><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/userinfo2.png" alt="userinfo2"> </p><h3 id="仓库详情页"><a href="#仓库详情页" class="headerlink" title="仓库详情页"></a>仓库详情页</h3><p>承载仓库所有信息的展示以及操作平台</p><p><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/repoinfo1.png" alt="repoinfo1"><br><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/repoinfo2.png" alt="repoinfo2"><br><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/repoinfo3.png" alt="repoinfo3"></p><h3 id="源码查看"><a href="#源码查看" class="headerlink" title="源码查看"></a>源码查看</h3><p>承载源码文件所有信息的展示以及操作平台</p><p><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/code1.png" alt="code1"><br><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/code2.png" alt="code2"><br><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/day_theme/code_readme.png" alt="code_readme"><br><img src="https://raw.githubusercontent.com/seasonfif/github/master/preview/night_theme/code_n.png" alt="code_n"></p><p>看到这里相信你已经迫不及待想拥有它了！这就为客官奉上下载地址。</p><h2 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a><strong>下载链接</strong></h2><p>点击以下链接即可下载安装，或者在其对应的应用商店搜索<code>github</code>下载安装</p><blockquote><ul><li><a href="https://raw.githubusercontent.com/seasonfif/github/master/apk/github_release.apk" target="_blank" rel="noopener">Git Download</a></li><li><a href="http://shouji.baidu.com/software/10131158.html" target="_blank" rel="noopener">百度应用商店</a></li><li><a href="http://sj.qq.com/myapp/detail.htm?apkName=com.seasonfif.github" target="_blank" rel="noopener">腾讯应用商店</a></li><li><a href="http://zhushou.360.cn/detail/index/soft_id/3522595?recrefer=SE_D_github" target="_blank" rel="noopener">360应用商店</a></li></ul></blockquote><h2 id="建议与bug反馈"><a href="#建议与bug反馈" class="headerlink" title="建议与bug反馈"></a><strong>建议与bug反馈</strong></h2><p>如果您对软件有什么建议或是在使用过程中发现bug可以通过以下途径反馈：</p><blockquote><ul><li>软件About的<code>Feedback</code>途径</li><li>项目主页中新建<a href="https://github.com/seasonfif/github/issues/new" target="_blank" rel="noopener">issue</a></li><li>新浪微博<a href="http://weibo.com/seasonfif" target="_blank" rel="noopener">@seasonfif</a></li><li>邮件到<a href="mailto:seasonfif@gmail.com" target="_blank" rel="noopener">seasonfif@gmail.com</a></li></ul></blockquote><p>期待与诸位的交流。</p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a><strong>鸣谢</strong></h2><p>项目使用了优秀的第三方开源库，在此对以下作品表示致谢。</p><ol><li><a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a>  Type-safe HTTP client for Android and Java by Square, Inc.</li><li><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a>   RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.</li><li><a href="https://github.com/square/picasso" target="_blank" rel="noopener">picasso</a>   A powerful image downloading and caching library for Android</li><li><a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">leakcanary</a>   A memory leak detection library for Android and Java.</li><li><a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">butterknife</a>   Bind Android views and callbacks to fields and methods.</li><li><a href="https://github.com/futuresimple/android-floating-action-button" target="_blank" rel="noopener">android-floating-action-button</a>   android-floating-action-button</li><li><a href="https://github.com/Frank-Zhu/PullZoomView" target="_blank" rel="noopener">PullZoomView</a>   An Android custom ListView and ScrollView with pull to zoom-in.</li><li><a href="https://github.com/mukeshsolanki/MarkdownView-Android" target="_blank" rel="noopener">MarkdownView-Android</a>   MarkdownView is an Android webview with the capability of loading Markdown text or file and display it as HTML, it extends Android webview.</li><li><a href="https://github.com/pnikosis/materialish-progress" target="_blank" rel="noopener">Material-ish Progress</a>   A material style progress wheel compatible with 2.3</li></ol><p>再次感谢！</p><h2 id="商务合作"><a href="#商务合作" class="headerlink" title="商务合作"></a><strong>商务合作</strong></h2><p>邮件<a href="mailto:seasonfif@gmail.com" target="_blank" rel="noopener">seasonfif@gmail.com</a><br>诚挚希望与您合作</p><hr>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个轻量级的基于卡片模板的自动化布局框架</title>
      <link href="/2016/09/21/android/%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E5%9F%BA%E4%BA%8E%E5%8D%A1%E7%89%87%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E5%B1%80%E6%A1%86%E6%9E%B6/"/>
      <url>/2016/09/21/android/%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E5%9F%BA%E4%BA%8E%E5%8D%A1%E7%89%87%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%83%E5%B1%80%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<h1 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h1><p>一个轻量级的基于卡片模板的自动化布局框架</p><p><strong>关于我</strong></p><blockquote><p>我的其他项目：<br><a href="https://github.com/seasonfif/github" target="_blank" rel="noopener">github第三方Android客户端（适配Material Design）</a></p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h2><p>该框架依据View叠加的树形结构，通过与之对应的树形json快捷简便的动态控制Card的布局结构。实现原理如下：</p><ol><li>解析服务端下发的树形json数据（节点类型需实现<code>INode</code>接口）；</li><li>布局引擎深度遍历树的节点，根据节点类型生成（生成方法为<code>IFactory</code>的实现类）各节点对应的Card（Card为使用时实现<code>ICard</code>接口的View或ViewGroup）；</li><li>将同一深度的兄弟节点依据权重（权重为使用时<code>INode</code>接口获得）排序；</li><li>递归遍历非叶子节点，将Card根据嵌套类型（<code>NestMode</code>）回调给具体的Card实现布局嵌套；</li><li>递归完成之后，布局引擎将返回根据树形json布局完成的View。</li></ol><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a><strong>特性</strong></h2><p>该框架具有强大的Card布局功能，其主要功能特性如下:</p><ol><li>框架以Card为最小单位布局（一个Card就是实现ICard接口的自定义View或ViewGroup），不关心Card内部的布局结构</li><li>框架解析服务端数据从而生成View，因此可实现真正的动态化布局</li><li>框架支持Card的自动嵌套（比如LinearLayout的VERTICAL与HORIZONTAL）和手动嵌套（预先占坑ViewGroup）</li><li>框架支持树形节点的Card数据部分为统一数据Bean或独自数据bean（通过json字符串支持，框架提供的<code>Node</code>节点模型即为此种类型）</li><li>框架支持以注解（<code>CardModel</code>）形式设置独自数据bean的类型</li><li>框架支持的独自数据bean的类型可以为普通对象（对应json对象）和列表对象（对应json数组）</li></ol><h2 id="设置Gradle依赖"><a href="#设置Gradle依赖" class="headerlink" title="设置Gradle依赖"></a><strong>设置Gradle依赖</strong></h2><ol><li><p>Add the JitPack repository to your build file</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ...</span><br><span class="line">        maven &#123; url &apos;https://jitpack.io&apos; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Add the dependency</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        compile &apos;com.github.seasonfif:matrix:1.0.5&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h2><p>框架使用特别简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 应用开始执行的地方使用IFactory对象初始化Matrix</span><br><span class="line">   Matrix.init(<span class="keyword">new</span> CardFactory());</span><br><span class="line">   </span><br><span class="line"><span class="number">2</span>. 需要动态生成View的地方（node为INode对象）</span><br><span class="line">   View view = Matrix.getEngine().produce(MainActivity.<span class="keyword">this</span>, node);</span><br><span class="line">   setContentView(view);</span><br></pre></td></tr></table></figure><p>除以上的框架调用之外，使用时应该优先完成以下的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 一个实现INode接口的节点数据模型（如果计划使用json字符串作为Card数据模型的下发方式则可以使用框架提供的Node对象）</span><br><span class="line">   </span><br><span class="line">2. 一个实现IFactory抽象工厂接口的Card工厂类</span><br><span class="line"></span><br><span class="line">3. 至少有一个实现ICard接口的卡片以及与之对应的卡片数据模型（如果为独自的Card数据模型需要在ICard实现类加上类注解@CardModel(xxx.class)）</span><br><span class="line"></span><br><span class="line">总而言之就是事先准备好项目需要动态布局各种的Card</span><br></pre></td></tr></table></figure></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>提供代码片段以帮助大家更快地理解其使用方法</p><p><strong>1. 一个实现INode接口的节点数据模型</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">以框架中的实现为例</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">INode</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">  <span class="keyword">private</span> String des;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">  <span class="keyword">private</span> String data;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Node&gt; children;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> des;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> List&lt;? extends INode&gt; getChildren() &#123;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2. 一个实现IFactory抽象工厂接口的Card工厂类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CardFactory</span> <span class="keyword">implements</span> <span class="title">ICardFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_CONTAINER_CARD = <span class="number">0x0000</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_ITEM_CARD = <span class="number">0x0001</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ICard <span class="title">createCard</span><span class="params">(Context context, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    ICard card;</span><br><span class="line">    <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">      <span class="keyword">case</span> TYPE_CONTAINER_CARD:</span><br><span class="line">        card = <span class="keyword">new</span> ContainerCard(context);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> TYPE_ITEM_CARD:</span><br><span class="line">        card = <span class="keyword">new</span> ItemCard(context);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        card = <span class="keyword">new</span> ContainerCard(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> card;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 一个实现ICard接口的卡片以及与之对应的卡片数据模型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">卡片实现</span><br><span class="line"><span class="meta">@CardModel</span>(TextCardBean.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextCard</span> <span class="keyword">extends</span> <span class="title">TextView</span> <span class="keyword">implements</span> <span class="title">ICard</span>&lt;<span class="title">TextCardBean</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TextCard</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TextCard</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TextCard</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setBackgroundColor(Color.parseColor(<span class="string">"#9ccc65"</span>));</span><br><span class="line">    setTextColor(Color.WHITE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNestMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> NestMode.NONE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(TextCardBean data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span>)&#123;</span><br><span class="line">      setText(data.text);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCard</span><span class="params">(<span class="keyword">int</span> index, ICard card)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">卡片对应的数据Bean</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextCardBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h2><ol><li>Card缓存机制（由于View体系中同一View对象不能嵌套，因此将缓存Card添加到同为自己的父布局时会异常），如果有好的实现思路可以提issue </li></ol><h2 id="第三方"><a href="#第三方" class="headerlink" title="第三方"></a><strong>第三方</strong></h2><p>框架使用<a href="https://github.com/google/gson" target="_blank" rel="noopener">Gson</a> （A Java serialization/deserialization library to convert Java Objects into JSON and back）作为json字符串转化为数据对象的工具</p><h1 id="开源许可"><a href="#开源许可" class="headerlink" title="开源许可"></a>开源许可</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copyright 2017 seasonfif.</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">you may not use this file except in compliance with the License.</span><br><span class="line">You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">  http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">    </span><br><span class="line">Unless required by applicable law or agreed to in writing, software</span><br><span class="line">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">See the License for the specific language governing permissions and</span><br><span class="line">limitations under the License.</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解Java8之后的HashMap</title>
      <link href="/2016/04/09/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java8%E4%B9%8B%E5%90%8E%E7%9A%84HashMap/"/>
      <url>/2016/04/09/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java8%E4%B9%8B%E5%90%8E%E7%9A%84HashMap/</url>
      <content type="html"><![CDATA[<p>　　HashMap的存储结构如图：一个桶（bucket）上的节点多于8个则存储结构是红黑树，小于8个是单向链表。<br><img src="http://p1axtub34.bkt.clouddn.com/hashmap-java8.jpg" alt="hashmap"><br>　　jdk8之前一直是链表，链表查询的复杂度是O(n)而红黑树由于其自身的特点，查询的复杂度是O(log(n))。如果hash的结果不均匀会极大影响操作的复杂度。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git文件系统</title>
      <link href="/2015/10/21/git/git%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2015/10/21/git/git%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>git常用命令</title>
      <link href="/2015/10/19/git/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2015/10/19/git/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Makdown富文本测试</title>
      <link href="/2015/05/17/other/Makdown%E5%AF%8C%E6%96%87%E6%9C%AC%E6%B5%8B%E8%AF%95/"/>
      <url>/2015/05/17/other/Makdown%E5%AF%8C%E6%96%87%E6%9C%AC%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! </p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=25706282&auto=0&height=66"><br></iframe><p>Idina Menze和Caleb Hyles激情对唱Let It Go：  </p><iframe height="498" width="510" src="http://player.youku.com/embed/XNjcyMDU4Njg0" frameborder="0" allowfullscreen><br></iframe>  ]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>详解activity启动模式</title>
      <link href="/2015/04/06/android/%E8%AF%A6%E8%A7%A3activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2015/04/06/android/%E8%AF%A6%E8%A7%A3activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>一个应用程序当中通常都会包含很多个Activity，每个Activity都是一个具有特定的功能，并且可以让用户进行操作的组件。另外，Activity之间可以相互启动，当前应用的Activity甚至可以去启动其他应用的Activity。<a id="more"></a>比如你的应用希望去发送一封邮件，你就可以定义一个具有”send”动作的Intent，并且传入一些数据，如对方邮箱地址、邮件内容等。这样，如果另外一个应用程序中的某个Activity声明自己是可以响应这种Intent的，那么这个Activity就会被打开。当邮件发送之后，按下返回键仍然还是会回到你的应用程序当中，这让用户看起来好像刚才那个编写邮件的Activity就是你的应用程序当中的一部分。所以说，即使有很多个Activity分别都是来自于不同应用程序的，Android系统仍然可以将它们无缝地结合到一起。那这一切是怎么实现的呢？这就要讲到本文要介绍的Activity任务栈以及Activity启动模式了。</p><p>任务栈是什么</p><p>任务栈Task，是一种用来放置Activity实例的容器，他是以栈的形式进行盛放，也就是所谓的先进后出，主要有2个基本操作：压栈和出栈，其所存放的Activity是不支持重新排序的，只能根据压栈和出栈操作更改Activity的顺序。</p><p>启动一个Application的时候，系统会为它默认创建一个对应的Task，用来放置根Activity。默认启动Activity会放在同一个Task中，新启动的Activity会被压入启动它的那个Activity的栈中，并且显示它。当用户按下回退键时，这个Activity就会被弹出栈，按下Home键回到桌面，再启动另一个应用，这时候之前那个Task就被移到后台，成为后台任务栈，而刚启动的那个Task就被调到前台，成为前台任务栈，Android系统显示的就是前台任务栈中的Top实例Activity。</p><p>任务栈的作用</p><p>以往基于应用（application）的程序开发中，程序具有明确的边界，一个程序就是一个应用，一个应用为了实现功能可以采用开辟新线程甚至新进程来辅助，但是应用与应用之间不能复用资源和功能。而Android引入了基于组件开发的软件架构，虽然我们开发android程序，仍然使用一个apk工程一个Application的开发形式，但是对于Aplication的开发就用到了Activity、service等四大组件，其中的每一个组件，都是可以被跨应用复用的，这就是android的神奇之处。虽然组件可以跨应用被调用，但是一个组件所在的进程必须是在组件所在的Aplication进程中。由于android强化了组件概念，弱化了Aplication的概念，所以在android程序开发中，A应用的A组件想要使用拍照或录像的功能就可以不用去针对Camera类进行开发，直接调用系统自带的摄像头应用（称其B应用）中的组件（称其B组件）就可以了，但是这就引发了一个新问题，A组件运行在A应用中，B组件运行在B应用中，自然都不在同一个进程中，那么从B组件中返回的时候，如何实现正确返回到A组件呢？Task就是来负责实现这个功能的，它是从用户角度来理解应用而建立的一个抽象概念。因为用户所能看到的组件就是Activity，所以Task可以理解为实现一个功能而负责管理所有用到的Activity实例的栈。</p><p>栈是一个先进后出的线性表，根据Activity在当前栈结构中的位置，来决定该Activity的状态。正常情况下，当一个Activity启动了另一个Activity的时候，新启动的Activity就会置于任务栈的顶端，并处于活动状态，而启动它的Activity虽然成功身退，但依然保留在任务栈中，处于停止状态，当用户按下返回键或者调用finish()方法时，系统会移除顶部Activity，让后面的Activity恢复活动状态。当然，世界不可能一直这么“和谐”，可以给Activity设置一些“特权”，来打破这种“和谐”的模式，这种特权，就是通过在AndroidManifest文件中的属性andorid:launchMode来设置或者通过Intent的flag来设置的，下面就先介绍下Activity的几种启动模式。</p><p>standard</p><p>默认模式，可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。应用场景：绝大多数Activity。</p><p>standard.png</p><p>如果以这种方式启动的Activity被跨进程调用，在5.0之前新启动的Activity实例会放入发送Intent的Task的栈的顶部，尽管它们属于不同的程序，这似乎有点费解看起来也不是那么合理，所以在5.0之后，上述情景会创建一个新的Task，新启动的Activity就会放入刚创建的Task中，这样就合理的多了。</p><p>singleTop</p><p>栈顶复用模式，如果要开启的activity在任务栈的顶部已经存在，就不会创建新的实例，而是调用 onNewIntent() 方法。避免栈顶的activity被重复的创建。应用场景：在通知栏点击收到的通知，然后需要启动一个Activity，这个Activity就可以用singleTop，否则每次点击都会新建一个Activity。当然实际的开发过程中，测试妹纸没准给你提过这样的bug：某个场景下连续快速点击，启动了两个Activity。如果这个时候待启动的Activity使用 singleTop模式也是可以避免这个Bug的。</p><p>2(1).png<br>同standard模式，如果是外部程序启动singleTop的Activity，在Android 5.0之前新创建的Activity会位于调用者的Task中，5.0及以后会放入新的Task中。</p><p>singleTask</p><p>栈内复用模式， activity只会在任务栈里面存在一个实例。如果要激活的activity，在任务栈里面已经存在，就不会创建新的activity，而是复用这个已经存在的activity，调用 onNewIntent() 方法，并且清空这个activity任务栈上面所有的activity。应用场景：大多数App的主页。对于大部分应用，当我们在主界面点击回退按钮的时候都是退出应用，那么当我们第一次进入主界面之后，主界面位于栈底，以后不管我们打开了多少个Activity，只要我们再次回到主界面，都应该使用将主界面Activity上所有的Activity移除的方式来让主界面Activity处于栈顶，而不是往栈顶新加一个主界面Activity的实例，通过这种方式能够保证退出应用时所有的Activity都能报销毁。<br>在跨应用Intent传递时，如果系统中不存在singleTask Activity的实例，那么将创建一个新的Task，然后创建SingleTask Activity的实例，将其放入新的Task中。</p><p>1：假如目前有个任务栈T1中的情况是ABC，这个时候ActivityD以singleTask模式请求启动，其所需要的任务栈正是T1，则系统会直接创建D的实例并将其入栈到T1中。</p><p>singleTask1.png<br>2：假如DActivity启动所需要的任务栈为T2,由于T2和D的实例均不存在，那么系统会先创建任务栈T2，然后再创建D的实例并将其入栈到T2中。我们可以通过设置Activity的taskAffinity属性来模拟这一场景。</p><p><activity android:name=".SingleTaskActivity" android:label="singleTask launchMode" android:launchmode="singleTask" android:taskaffinity=""><br></activity><br>singleTask2.png<br>3：如果D所需的任务栈为T3，并且当前任务栈T3的情况为ADBC，根据栈内复用的原则，此时D不会重新创建，系统会把D切换到栈顶并调用其onNewIntent()方法，同时由于singleTask默认具有ClearTop的效果，会导致栈内所有在D上面的Activity全部出栈，于是最终T3的情况为AD。</p><p>singleTask3.png<br>4：假如目前有两个任务栈，前台任务栈T4的情况为AB,后台任务栈t4里存有CD,假设CD的启动模式均为singleTask，现在由B去启动D,那么整个后台任务都会被切换到前台，这个时候整个栈就变成了ABCD。</p><p>singleTask4.png<br>5:假如上面的其他条件不变，B启动的是C而不是D,那么整个栈的情况就变成了ABC,因为D在C上面，会被清理出栈。</p><p>singleTask5.png<br>singleInstance</p><p>单一实例模式，整个手机操作系统里面只有一个实例存在。不同的应用去打开这个activity 共享公用的同一个activity。他会运行在自己单独，独立的任务栈里面，并且任务栈里面只有他一个实例存在。应用场景：呼叫来电界面。这种模式的使用情况比较罕见，在Launcher中可能使用。或者你确定你需要使Activity只有一个实例。建议谨慎使用。</p><p>范冰冰.pic.jpg<br>设置Intent的Flag</p><p>系统提供了两种方式来设置一个Activity的启动模式，除了在AndroidManifest文件中设置以外，还可以通过Intent的Flag来设置一个Activity的启动模式，下面我们在简单介绍下一些Flag。</p><p>FLAG_ACTIVITY_NEW_TASK</p><p>使用一个新的Task来启动一个Activity，但启动的每个Activity都讲在一个新的Task中。该Flag通常使用在从Service中启动Activity的场景，由于Service中并不存在Activity栈，所以使用该Flag来创建一个新的Activity栈，并创建新的Activity实例。</p><p>FLAG_ACTIVITY_SINGLE_TOP</p><p>使用singletop模式启动一个Activity，与指定android：launchMode=“singleTop”效果相同。</p><p>FLAG_ACTIVITY_CLEAR_TOP</p><p>使用SingleTask模式来启动一个Activity，与指定android：launchMode=“singleTask”效果相同。</p><p>FLAG_ACTIVITY_NO_HISTORY</p><p>Activity使用这种模式启动Activity，当该Activity启动其他Activity后，该Activity就消失了，不会保留在Activity栈中。</p><p>LaunchMode与StartActivityForResult</p><p>我们在开发过程中经常会用到StartActivityForResult方法启动一个Activity，然后在onActivityResult()方法中可以接收到上个页面的回传值，但你有可能遇到过拿不到返回值的情况，那有可能是因为Activity的LaunchMode设置为了singleTask。5.0之后，android的LaunchMode与StartActivityForResult的关系发生了一些改变。两个Activity，A和B，现在由A页面跳转到B页面，看一下LaunchMode与StartActivityForResult之间的关系：</p><p>before5.0.png<br>after5.0.png<br>这是为什么呢？</p><p>这是因为ActivityStackSupervisor类中的startActivityUncheckedLocked方法在5.0中进行了修改。在5.0之前，当启动一个Activity时，系统将首先检查Activity的launchMode，如果为A页面设置为SingleInstance或者B页面设置为singleTask或者singleInstance,则会在LaunchFlags中加入FLAG_ACTIVITY_NEW_TASK标志，而如果含有FLAG_ACTIVITY_NEW_TASK标志的话，onActivityResult将会立即接收到一个cancle的信息，而5.0之后这个方法做了修改，修改之后即便启动的页面设置launchMode为singleTask或singleInstance，onActivityResult依旧可以正常工作，也就是说无论设置哪种启动方式，StartActivityForResult和onActivityResult()这一组合都是有效的。所以如果你目前正好基于5.0做相关开发，不要忘了向下兼容，这里有个坑请注意避让。</p><p>总结</p><p>实际开发过程中如果采用比较合理的Activity启动模式来做好任务栈的管理，可以事半功倍。在launchMode的选择上首先要搞清楚当前的Activity的作用，以及实际使用场景来做出合理选择。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Activity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解ConcurrentHashMap</title>
      <link href="/2015/03/25/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ConcurrentHashMap/"/>
      <url>/2015/03/25/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ConcurrentHashMap/</url>
      <content type="html"><![CDATA[<p>　　ConcurrentHashMap是一种线程安全的HashMap。它是基于分段锁技术的Map实现类，即对分段加锁同步以期在多线程环境下快速达到插入数据的一致性，因此只有在同一个分段内才存在竞态关系，不同的分段锁之间没有锁竞争。相比于对整个Map加锁的设计，分段锁大大的提高了高并发环境下的处理能力。但同时，由于不是对整个Map加锁，导致一些需要扫描整个Map的方法（如size(), containsValue()）需要使用特殊的实现，另外一些方法（如get()、clear()）甚至放弃了对一致性的要求，因此ConcurrentHashMap是弱一致性的。<br>　　我们知道HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。 　　ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。ConcurrentHashMap中的HashEntry相对于HashMap中的Entry有一定的差异性：HashEntry中的value以及next都被volatile修饰，这样在多线程读写过程中能够保持它们的可见性，从如下源码片段可有个大概了解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure></p><p>　　与HashMap不同的是，ConcurrentHashMap并不允许key或者value为null，按照作者Doug Lea的说法，这么设计的原因是因为在ConcurrentHashMap中，一旦value出现null，则代表HashEntry的key/value没有映射完成就被其他线程所见，而并不只是简单的空值而已。<br>Doug Lea为util.concurrent包的作者。<br><img src="http://p1axtub34.bkt.clouddn.com/DougLea.jpg" alt="Doug Lea"></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解HashMap</title>
      <link href="/2015/03/20/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap/"/>
      <url>/2015/03/20/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap/</url>
      <content type="html"><![CDATA[<h2 id="HashMap概览"><a href="#HashMap概览" class="headerlink" title="HashMap概览"></a>HashMap概览</h2><p>　　HashMap是基于哈希表的Map接口实现。哈希表就是一个固定长度的数组，包含有keys，每个key（key可以是字符，字符串，或者是数字，亦或者是什么其他信息等等）都与一个数值（数值一般来说就是0到TableSize-1，TableSize就是哈希表的长度，也就是那个数组的长度）对应。<br>　　Java中的HashMap允许使用 null 值和 null 键。HashMap也不保证存取顺序。它的类簇如下：<br><img src="http://p1axtub34.bkt.clouddn.com/java.util.map.png/b" alt="HashMap类簇"><br>　　影响HashMap性能的有两个参数：初始容量(initialCapacity) 和加载因子(loadFactor)。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有两倍的桶数。<br>　　通过HashMap源码我们可以看到它对容量以及加载因子的设定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">     * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></p><h2 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h2><h3 id="hashing的概念"><a href="#hashing的概念" class="headerlink" title="hashing的概念"></a>hashing的概念</h3><p>　　散列法（Hashing）或哈希法是一种将字符组成的字符串转换为固定长度（一般是更短长度）的数值或索引值的方法，称为散列法，也叫哈希法。由于通过更短的哈希值比用原始值进行数据库搜索更快，这种方法一般用来在数据库中建立索引并进行搜索，同时还用在各种解密算法中。<br>　　将哈希值对容量取余就能确定该值位于哪一个桶中。由于java中的HashMap初始容量为16，每次扩容也都是固定的扩大到2倍，因此可以通过一下方法快速定位桶的位置：hash&amp;(capacity-1)。通过源码我们可以看到实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns index for hash code h.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这个方法非常巧妙，它总是通过 h &amp;(table.length -1) 来得到该对象的保存位置——而 HashMap 底层数组的长度总是 2 的 n 次方。当 length 总是 2 的倍数时，h &amp; (length-1) 将是一个非常巧妙的设计：假设 h=5,length=16, 那么 h &amp; length - 1 将得到 5；如果 h=6,length=16, 那么 h &amp; length - 1 将得到 6 ……如果 h=15,length=16, 那么 h &amp; length - 1 将得到 15；但是当 h=16 时 , length=16 时，那么 h &amp; length - 1 将得到 0 了；当 h=17 时 , length=16 时，那么 h &amp; length - 1 将得到 1 了……这样保证计算得到的索引值总是位于 table 数组的索引之内。<br>　　既然是使用hash值来确定元素的位置，那么当两个元素的hash值相同时又该如何操作呢？我们把两个不同元素hash值相同的现象称之为hash冲突或者碰撞。</p><h3 id="HashMap中解决碰撞的方法"><a href="#HashMap中解决碰撞的方法" class="headerlink" title="HashMap中解决碰撞的方法"></a>HashMap中解决碰撞的方法</h3><p>　　HashMap通过“拉链法”来解决哈希冲突，所谓拉链法即是将hash相同的元素使用单链表储存，这样的结构给人的感觉就是每一个bucket上挂着一个链表如下图所示：    </p><p><img src="http://p1axtub34.bkt.clouddn.com/hashmap_entry.jpg/b" alt="拉链结构"></p><p>　　为什么会形成这样的结构呢？我们从HashMap源码一探究竟吧！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates new entry.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;</span><br><span class="line">        Object k1 = getKey();</span><br><span class="line">        Object k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            Object v1 = getValue();</span><br><span class="line">            Object v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key==<span class="keyword">null</span>   ? <span class="number">0</span> : key.hashCode()) ^</span><br><span class="line">                (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * This method is invoked whenever the value in an entry is</span></span><br><span class="line"><span class="comment">    * overwritten by an invocation of put(k,v) for a key k that's already</span></span><br><span class="line"><span class="comment">    * in the HashMap.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * This method is invoked whenever the entry is</span></span><br><span class="line"><span class="comment">    * removed from the table.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　从静态内部类Entry的成员变量我们可以很清楚的看到，它具有一个指向下一个节点的对象next，类型即为Entry本身。我们知道HashMap每一个bucket中存放的就是一个Entry，这样就能在遇到碰撞的时候将该值继续保存在next之中存而形成单向链表有效的防止hash冲突。但是在大量冲突之后，HashMap近似相等于链表，查找速度会急剧下降，影响使用性能。</p><h3 id="equals-和hashCode-的应用"><a href="#equals-和hashCode-的应用" class="headerlink" title="equals()和hashCode()的应用"></a>equals()和hashCode()的应用</h3><p>　　hashCode()和equals()方法在HashMap的get与put方法有比较关键的使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将“key-value”添加到HashMap中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取key对应的value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">            e != <span class="keyword">null</span>;</span><br><span class="line">            e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　根据上面put方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该key的hashCode()决定该Entry的存储位置：如果两个Entry的key的hashCode()返回值相同，那它们的存储位置相同。如果这两个Entry的key通过equals比较返回true，新添加Entry的value将覆盖集合中原有Entry的value，但key不会覆盖。如果这两个Entry的key通过equals比较返回false，新添加的Entry将与集合中原有Entry形成Entry链，而且新添加的Entry位于Entry链的头部。<br>　　根据get方法的源码可以看出，当从HashMap中取元素时，第一步还是根据该key的hashCode()决定该Entry的存储位置，然后遍历该entry链表直到找到目标元素。</p><h3 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h3><p>　　向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素；当然java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组；就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。<br>　　当HashMap里的元素个数(size)大于一个阈值(threshold)时，map将自动扩容，容量扩大到原来的2倍；以默认值为例，阈值=16*0.75=12，当元素个数大于12时就要扩容；loadFactor过大时，map内的数组使用率高了，内部极有可能形成Entry链，影响查找速度；loadFactor过小时，map内的数组使用率旧低，不过内部不会生成Entry链，或者生成的Entry链很短，由此提高了查找速度，不过会占用更多的内存；所以可以根据实际硬件环境和程序的运行状态来调节loadFactor。<br>　　那么HashMap是如何扩容的呢？我们跟随源码看一下实现方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的源码实现很简单就是使用一个容量更大（原来的2倍）的数组来代替已有的容量小的数组；transfer()方法则是将原有Entry数组的元素拷贝到新的Entry数组里面。</p><h3 id="HashMap多线程的条件竞争"><a href="#HashMap多线程的条件竞争" class="headerlink" title="HashMap多线程的条件竞争"></a>HashMap多线程的条件竞争</h3><p>　　因为HashMap采用单链表结构，那么就很容易形成闭合的链路，这样在循环的时候只要有线程对这个HashMap进行get操作就会产生死循环。但是，这种闭合的链路是如何形成的呢？在单线程情况下，只有一个线程对HashMap的数据结构进行操作，是不可能产生闭合的回路的。那就只有在多线程并发的情况下才会出现这种情况，那就是在put操作的时候，如果size&gt;initialCapacity*loadFactor，那么这时候HashMap就会进行rehash操作，随之HashMap的结构就会发生翻天覆地的变化。很有可能就是在两个线程在这个时候同时触发了rehash操作，产生了闭合的回路。<br>　　当我们往HashMap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。 如果这个元素所在的位置上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，而先前加入的放在链尾。<br>　　当哈希桶容量较小，容易产生哈希碰撞，所以，Hash表的尺寸和容量非常的重要。一般来说，Hash表这个容器当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，这个过程称为resize。多个线程同时往HashMap添加新元素时，多次resize会有一定概率出现死循环，因为每次resize需要把旧的数据映射到新的哈希表，我们可以通过HashMap源码中的transfer() 方法窥探其中的奥秘：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中do…while循环就是导致产生闭合回路的原因，也是导致多线程使用hashmap出现CUP使用率骤增，从而多个线程阻塞的罪魁祸首。</p><h2 id="HashMap相关结构"><a href="#HashMap相关结构" class="headerlink" title="HashMap相关结构"></a>HashMap相关结构</h2><h3 id="线程安全的ConcurrentHashMap"><a href="#线程安全的ConcurrentHashMap" class="headerlink" title="线程安全的ConcurrentHashMap"></a>线程安全的ConcurrentHashMap</h3><p>　　ConcurrentHashMap是一种线程安全的HashMap。它是基于分段锁技术的Map实现类，即对分段加锁同步以期在多线程环境下快速达到插入数据的一致性，因此只有在同一个分段内才存在竞态关系，不同的分段锁之间没有锁竞争。相比于对整个Map加锁的设计，分段锁大大的提高了高并发环境下的处理能力。但同时，由于不是对整个Map加锁，导致一些需要扫描整个Map的方法（如size(), containsValue()）需要使用特殊的实现，另外一些方法（如get()、clear()）甚至放弃了对一致性的要求，因此ConcurrentHashMap是弱一致性的。<br>　　我们知道HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。<br><img src="http://p1axtub34.bkt.clouddn.com/concurrentmap.jpeg/b" alt="ConcurrentHashMap存储模型"><br>　　ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。ConcurrentHashMap中的HashEntry相对于HashMap中的Entry有一定的差异性：HashEntry中的value以及next都被volatile修饰，这样在多线程读写过程中能够保持它们的可见性，从如下源码片段可有个大概了解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure></p><p>　　与HashMap不同的是，ConcurrentHashMap并不允许key或者value为null，按照作者Doug Lea的说法，这么设计的原因是因为在ConcurrentHashMap中，一旦value出现null，则代表HashEntry的key/value没有映射完成就被其他线程所见，而并不只是简单的空值而已。<br>　　本文只是简单的介绍一下ConcurrentHashMap的概念及其特点，详细的解析可以查看我的<a href="https://seasonfif.github.io/2015/03/25/java/深入理解ConcurrentHashMap/">这篇博文</a>。</p><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>　　和HashMap一样，Hashtable也是一个散列表，它存储的内容是键值对(key-value)映射。Hashtable继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。Dictionary是声明了操作”键值对”函数接口的抽象类。<br>Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。<br>通过Hashtable公开接口可以看到它线程安全的方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span>                <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> Object              <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">             <span class="keyword">boolean</span>             <span class="title">contains</span><span class="params">(Object value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">boolean</span>             <span class="title">containsKey</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">boolean</span>             <span class="title">containsValue</span><span class="params">(Object value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> Enumeration&lt;V&gt;      <span class="title">elements</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> Set&lt;Entry&lt;K, V&gt;&gt;    <span class="title">entrySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">boolean</span>             <span class="title">equals</span><span class="params">(Object object)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> V                   <span class="title">get</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">int</span>                 <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">boolean</span>             <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> Set&lt;K&gt;              <span class="title">keySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> Enumeration&lt;K&gt;      <span class="title">keys</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> V                   <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span>                <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> V                   <span class="title">remove</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">int</span>                 <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> String              <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> Collection&lt;V&gt;       <span class="title">values</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><p>由于同步效率的问题，在多线程环境下Hashtable已经被ConcurrentHashMap所取代，但是程序要求数据强一致性时还是要使用Hashtable。<br><br></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java集合框架介绍</title>
      <link href="/2015/03/18/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
      <url>/2015/03/18/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h2 id="集合框架概览"><a href="#集合框架概览" class="headerlink" title="集合框架概览"></a>集合框架概览</h2><p>　　Java集合框架由一套设计优良的接口和类组成。高度的封装使我们操作多个数据或对象元素极为方便。所有的Java集合都在java.util包中。<br>　　在编写程序的过程中，使用到集合类，要根据不同的需求，来决定使用哪种集合类，比如，要经常遍历集合内元素，就要使用List，如果要保证集合中不存在重复的数据，就要用Set;如果要通过某一键来查找某一值，就要使用Map。<br>Java中集合类主要有两大分支：</p><ol><li>Collection</li><li>Map</li></ol><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>Colloction接口继承关系<br><img src="http://p1axtub34.bkt.clouddn.com/collection-mark.jpg/b" alt="Collection"><br>详细的类图结构<br><img src="http://p1axtub34.bkt.clouddn.com/java-collection.png/b" alt="Collection"></p><h3 id="1、接口定义"><a href="#1、接口定义" class="headerlink" title="1、接口定义"></a>1、接口定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  Object[] toArray();</span><br><span class="line"></span><br><span class="line">  &lt;T&gt; T[] toArray(T[] var1);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; var1)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、Set实现类"><a href="#2、Set实现类" class="headerlink" title="2、Set实现类"></a>2、Set实现类</h3><p>Set<br>　　该类中的元素不按特定方式排序，只是简单的把对象加入集合中，就像往口袋里放东西。<br>对Set中成员的访问和操作是通过Set中对象的引用进行的，所以集中不能有重复对象。<br>　　Set也有多种变体，可以实现排序等功能，如TreeSet，它把对象添加到集中的操作将变为按照某种比较规则将其插入到有序的对象序列中。它实现的是SortedSet接口，也就是加入了对象比较的方法。通过对集中的对象迭代，我们可以得到一个升序的对象集合。<br>HashSet<br>　　能够快速定位一个元素，要注意的是：存入HashSet中的对象必须实现HashCode()方法；<br>TreeSet<br>　　将放入其中的元素按序存放。</p><h3 id="3、Queue实现类"><a href="#3、Queue实现类" class="headerlink" title="3、Queue实现类"></a>3、Queue实现类</h3><p>Queue<br>　　用于模拟队列这种数据结构。队列通常是指“先进先出（FIFO）”的容器。队列的头部保存在队列中存放时间最长的元素，尾部保存存放时间最短的元素。新元素插入到队列的尾部，取出元素会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。<br>PriorityQueue<br>　　保存队列元素的顺序不是按照元素添加的顺序来保存的，而是在添加元素的时候对元素的大小排序后再保存的。因此在PriorityQueue中使用peek()或pool()取出队列中头部的元素，取出的不是最先添加的元素，而是最小的元素。<br>Deque<br>　　该接口是Queue接口的子接口，它代表一个双端队列。<br>ArrayDeque<br>　　该类是Deque接口的实现类，ArrayDeque采用了循环数组的方式来完成双端队列的功能。</p><ol><li>无限的扩展，自动扩展队列大小的。（当然在不会内存溢出的情况下。）</li><li>非线程安全的，不支持并发访问和修改。</li><li>支持fast-fail.</li><li>作为栈使用的话比比栈要快.</li><li>当队列使用比linklist要快。</li><li>null元素被禁止使用。</li></ol><h3 id="4、List实现类"><a href="#4、List实现类" class="headerlink" title="4、List实现类"></a>4、List实现类</h3><p>List<br>　　该接口及其实现类是容量可变的列表，可按索引访问集合中的元素。<br>列表在数据结构中分别表现为：数组和向量、链表、堆栈、队列。<br>ArrayList<br>　　实现一个数组，它的规模可变并且能像链表一样被访问。它提供的功能类似Vector类但不同步，它是以Array方式实现的List，允许快速随机存取。<br>LinkedList<br>　　实现一个链表，提供最佳顺序存取，适合插入和移除元素。由这个类定义的链表也可以像栈或队列一样被使用。提供最佳顺序存取，适合插入和移除元素。LinkedList与ArrayList，ArrayDeque的实现机制完全不同，ArrayList和ArrayDeque内部以数组的形式来保存集合中的元素，因此随机访问集合元素时有较好的性能；而LinkedList以链表的形式来保存集合中的元素，因此随机访问集合元素时性能较差，但是插入和删除元素时性能比较出色（只需改变指针所指的地址即可），需要指出的是，虽然Vector也是以数组的形式来存储集合但因为它实现了线程同步（而且实现的机制不好），故各方面的性能都比较差。<br>Vector<br>　　Vector同步了每个方法，你几乎从不要那样做，通常有想要同步的是整个操作序列。同步单个的操作也不安全（如果你迭代一个Vector，你还是要加锁，以避免其它线程在同一时刻改变集合）.而且效率更慢。当然同样有锁的开销即使你不需要，这是个很糟糕的方法在默认情况下同步访问。你可以一直使用Collections.sychronizedList来装饰一个集合。</p><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>Map接口继承关系<br><img src="http://p1axtub34.bkt.clouddn.com/map-mark.jpg/b" alt="Map"><br>详细的类图结构<br><img src="http://p1axtub34.bkt.clouddn.com/java-map.png/b" alt="Map"></p><h3 id="1、接口定义-1"><a href="#1、接口定义-1" class="headerlink" title="1、接口定义"></a>1、接口定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">V <span class="title">put</span><span class="params">(K var1, V var2)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">V <span class="title">remove</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object var1, V var2)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; var1)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; var1)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> V <span class="title">putIfAbsent</span><span class="params">(K var1, V var2)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object var1, Object var2)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K var1, V var2, V var3)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> V <span class="title">replace</span><span class="params">(K var1, V var2)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> V <span class="title">computeIfAbsent</span><span class="params">(K var1, Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; var2)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> V <span class="title">computeIfPresent</span><span class="params">(K var1, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; var2)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> V <span class="title">compute</span><span class="params">(K var1, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; var2)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> V <span class="title">merge</span><span class="params">(K var1, V var2, BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; var3)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">setValue</span><span class="params">(V var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">default</span> &lt;K extends Comparable&lt;? <span class="keyword">super</span> K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">default</span> &lt;K, V extends Comparable&lt;? <span class="keyword">super</span> V&gt;&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">default</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? <span class="keyword">super</span> K&gt; var0) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">default</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? <span class="keyword">super</span> V&gt; var0) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、AbstractMap"><a href="#2、AbstractMap" class="headerlink" title="2、AbstractMap"></a>2、AbstractMap</h3><p>HashMap<br>　　基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>　　HashMap 的实例有两个参数影响其性能：初始容量 和加载因子。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>　　通常，默认加载因子 (.75) 在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。<br>　　该类不是线程安全的。<br>WeakHashMap<br>　　以弱键实现的基于哈希表的 Map。在 WeakHashMap 中，当某个键不再正常使用时，将自动移除其条目。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。丢弃某个键时，其条目从映射中有效地移除，因此，该类的行为与其他的 Map 实现有所不同。 </p><h3 id="3、LinkedHashMap"><a href="#3、LinkedHashMap" class="headerlink" title="3、LinkedHashMap"></a>3、LinkedHashMap</h3><p>LinkedHashMap<br>　　该类是 Map 接口的哈希表和链表实现。该类维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序），亦即它保留插入的顺序，输出的顺序即为输入时的插入顺序。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>　　根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用 get 方法)的链表。<br>　　默认是按插入顺序排序，如果指定按访问顺序排序，那么调用 get 方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。  可以重写 removeEldestEntry 方法返回 true 值指定插入元素时移除最老的元素。<br>　　注意，此实现不是同步的。</p><h3 id="4、SortedMap"><a href="#4、SortedMap" class="headerlink" title="4、SortedMap"></a>4、SortedMap</h3><p>TreeMap<br>　　基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。<br>　　在添加、删除和定位映射关系上，TreeMap类要比HashMap类的性能差一些，但是其中的映射关系具有一定的顺序，如果不需要一个有序的集合，则建议使用HashMap类；如果需要进行有序的遍历输出，则建议使用TreeMap类，在这种情况下，可以先使用由HashMap类实现的Map集合，在需要顺序输出时，再利用现有的HashMap类的实例，创建一个具有完全相同映射关系的TreeMap类型的实例。</p><h3 id="5、ConcurrentMap"><a href="#5、ConcurrentMap" class="headerlink" title="5、ConcurrentMap"></a>5、ConcurrentMap</h3><p>　　该类是线程安全的 Map 实现。与 Hashtable 相似，但 Hashtable 的 synchronized 是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap 允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对 hash 表的不同部分进行的修改。ConcurrentHashMap 内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。<br>　　Hashtable 对 get,put,remove 都使用了同步操作，它的同步级别是正对 Hashtable 来进行同步的，也就是说如果有线程正在遍历集合，其他的线程就暂时不能使用该集合了，这样无疑就很容易对性能和吞吐量造成影响，从而形成单点。而ConcurrentHashMap 则不同，它只对 put,remove 操作使用了同步操作，get 操作并不影响。<br>　　该类不允许将 null 用作键或值。 </p><h3 id="6、Hashtable"><a href="#6、Hashtable" class="headerlink" title="6、Hashtable"></a>6、Hashtable</h3><p>　　Hashtable 的实例有两个参数影响其性能：初始容量 和加载因子。容量 是哈希表中桶 的数量，初始容量就是哈希表创建时的容量。注意，哈希表的状态为 open：在发生“哈希冲突”的情况下，单个桶会存储多个条目，这些条目必须按顺序搜索。加载因子 是对哈希表在其容量自动增加之前可以达到多满的一个尺度。初始容量和加载因子这两个参数只是对该实现的提示。关于何时以及是否调用 rehash 方法的具体细节则依赖于该实现。<br>　　通常，默认加载因子(.75)在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查找某个条目的时间（在大多数 Hashtable 操作中，包括 get 和 put 操作，都反映了这一点）。<br>　　初始容量主要控制空间消耗与执行 rehash 操作所需要的时间损耗之间的平衡。如果初始容量大于 Hashtable 所包含的最大条目数除以加载因子，则永远 不会发生 rehash 操作。但是，将初始容量设置太高可能会浪费空间。<br>　　Hashtable 是同步的，现在一般情况下，都使用 HashMap ，而不使用陈旧的 Hashtbale，即便需要同步的时候，也是采用加同步的HashMap或者ConcurrentHashMap等实现。</p><p><br></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用HEXO+Github搭建自己的博客</title>
      <link href="/2015/03/07/other/%E4%BD%BF%E7%94%A8HEXO+Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2015/03/07/other/%E4%BD%BF%E7%94%A8HEXO+Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>安装Node（必须）</p><p>作用：用来生成静态页面的</p><p>到Node.js官网下载相应平台的最新版本，一路安装即可。</p><p>安装Git（必须）</p><p>作用：把本地的hexo内容提交到github上去.</p><p>安装Xcode就自带有Git，我就不多说了。</p><p>申请GitHub（必须）</p><p>作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。</p><p>github账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。<br>正式安装Hexo</p><p>Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。</p><p>执行如下命令安装Hexo：</p><p>sudo npm install -g hexo</p><p>初始化然后，执行init命令初始化hexo,命令：</p><p>hexo init</p><p>好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。</p><p>生成静态页面</p><p>hexo generate（hexo g也可以）</p><p>本地启动</p><p>启动本地服务，进行文章预览调试，命令：</p><p>hexo s</p><p>浏览器输入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p><h2 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h2><p>建立Repository</p><p>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法</p><p>然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：</p><pre><code>_config.yml    node_modules    public      sourcedb.json        package.json    scaffolds  themes</code></pre><p>现在我们需要_config.yml文件，来建立关联，命令：</p><p>vim _config.yml</p><p>翻到最下面，改成这样</p><p>deploy:<br>  type: git<br>  repo: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:seasonfif/seasonfif.github.io.git<br>  branch: master</p><p>然后执行命令：</p><p>npm install hexo-deployer-git –save</p><p>然后，执行配置命令：</p><p>hexo deploy</p><h2 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h2><p><a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank" rel="noopener">https://github.com/lewis-geek/hexo-theme-Aath</a><br><img src="https://camo.githubusercontent.com/063c5a8aecdefe228efea177f3bfc55a513997cd/687474703a2f2f6f6c6e7a70646932752e626b742e636c6f7564646e2e636f6d2f556e7469746c65642d313838302e706e67" alt="icon"><br><a href="https://github.com/CodeDaraW/Hacker" target="_blank" rel="noopener">https://github.com/CodeDaraW/Hacker</a><br><img src="https://camo.githubusercontent.com/9f682a6ea902cea665d6bbd52fe6e89f31e6d6c0/68747470733a2f2f6f6f6f2e306f302e6f6f6f2f323031362f30382f30342f353761333036663536626565322e706e67" alt="icon"><br><a href="https://github.com/Kaijun/hexo-theme-huxblog" target="_blank" rel="noopener">https://github.com/Kaijun/hexo-theme-huxblog</a><br><img src="https://camo.githubusercontent.com/51586abd6e60f0bd7d85a532d7c0017cbe781421/687474703a2f2f6875616e677875616e2e6d652f696d672f626c6f672d6465736b746f702e6a7067" alt="icon"><br><a href="https://github.com/YenYuHsuan/hexo-theme-beantech/" target="_blank" rel="noopener">https://github.com/YenYuHsuan/hexo-theme-beantech/</a><br><img src="https://camo.githubusercontent.com/905786536d4c9f111d965f29aac8bc8c36fede47/687474703a2f2f6265616e746563682e6f72672f696d672f6265616e746563682d6465736b746f702e706e67" alt="icon"></p><h2 id="增加字数统计"><a href="#增加字数统计" class="headerlink" title="增加字数统计"></a>增加字数统计</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><p>使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-count"</span>&gt;字数统计：&lt;%= wordcount(page.content) %&gt;字&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;span class="post-count"&gt;阅读时长：&lt;%= min2read(page.content) %&gt;分钟&lt;/</span>span&gt;</span><br></pre></td></tr></table></figure></p><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><p>  1、文件大小写引起的找不到路径<br>  进入到博客项目中 .deploy_git文件夹，修改 .git 下的 config 文件，将 ignorecase=true 改为 ignorecase=false<br>  删除博客项目中 .deploy_git 文件夹下的所有文件，并 push 到 Github 上, 这一步会清空<code>github.io</code>项目中所有文件。<br>  使用 Hexo 再次生成及部署</p>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell编程</title>
      <link href="/2015/03/04/linux/shell%E7%BC%96%E7%A8%8B/"/>
      <url>/2015/03/04/linux/shell%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux常用命令汇总</title>
      <link href="/2015/02/15/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
      <url>/2015/02/15/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
